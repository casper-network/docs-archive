# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, CasperLabs LLC
# This file is distributed under the same license as the CasperLabs Tech
# Spec package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CasperLabs Tech Spec \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-26 20:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../theory/naive-blockchain.rst:2
msgid "Naive Casper Blockchain"
msgstr ""

#: ../../theory/naive-blockchain.rst:5 ../../theory/naive-blockchain.rst:100
msgid "Introduction"
msgstr ""

#: ../../theory/naive-blockchain.rst:7
msgid ""
"Blockchain is a P2P network where the collection of nodes "
"(**validators**) concurrently update a decentralized, shared database. "
"They do this by collectively building an ever-growing chain of "
"**transactions**. For performance reasons transactions are bundled in "
"**blocks**."
msgstr ""

#: ../../theory/naive-blockchain.rst:9
msgid ""
"For the “outside world”, the blockchain looks like a computer. This "
"blockchain computer has a memory (= shared database) and can execute "
"programs (= transactions). Execution of a program changes the state of "
"the memory. Anybody can send a program to the computer and the computer "
"will do a best effort attempt to execute this program."
msgstr ""

#: ../../theory/naive-blockchain.rst:11
#, python-format
msgid ""
"We say that a blockchain computer is **decentralized**, i.e. there is no "
"single point of failure in the infrastructure. A significant portion of "
"the network of validators could be suddenly destroyed and nevertheless "
"the blockchain will continue to work. Also, the system is resistant to "
"malicious validators (as long as the total weight of malicious validators"
" is below 50% of the total weight of all validators)."
msgstr ""

#: ../../theory/naive-blockchain.rst:13
msgid ""
"The core of blockchain mechanics is the continuous work of validators "
"struggling to agree on a consistent history of programs executed on the "
"blockchain computer. We describe this central idea as “achieving "
"**consensus** on the chain of blocks”. Because every block contains a "
"chain of transactions, this “consistent history” results in being a "
"sequence of transactions."
msgstr ""

#: ../../theory/naive-blockchain.rst:15
msgid ""
"Note that in this spec we use the terms **shared database** and "
"**blockchain computer memory** interchangeably."
msgstr ""

#: ../../theory/naive-blockchain.rst:18
msgid "Computing model"
msgstr ""

#: ../../theory/naive-blockchain.rst:21
msgid "Memory and programs"
msgstr ""

#: ../../theory/naive-blockchain.rst:23
msgid ""
"We need to define the “computational semantics” of a blockchain computer;"
" what programs are and how they execute. However, because the consensus "
"protocol we introduce is compatible with a wide range of computing "
"models, it is convenient to approach this abstractly. Therefore, we "
"represent the “computational semantics” of a blockchain computer as a "
"triple :math:`\\langle GS, Zero, P\\rangle` where:"
msgstr ""

#: ../../theory/naive-blockchain.rst:29
msgid ""
":math:`GS` is a set of states of the shared database (think that each "
"point :math:`gs \\in GS` represents a “snapshot” of the shared database) "
"we call “global states”"
msgstr ""

#: ../../theory/naive-blockchain.rst:30
msgid ":math:`Zero \\in GS` is the initial state of the database"
msgstr ""

#: ../../theory/naive-blockchain.rst:31
msgid ""
":math:`P \\subset Partial(GS \\rightarrow GS)` is a non-empty set of "
"partial functions from :math:`GS` to :math:`GS`, closed under "
"composition; elements of :math:`P` we call **transactions** (we think of "
"them as “executable programs”)"
msgstr ""

#: ../../theory/naive-blockchain.rst:33
msgid ""
"Given a state :math:`gs \\in GS` and a transaction :math:`p \\in P`, we "
"can calculate the value :math:`p(gs)` only in the case when :math:`p` is "
"defined at :math:`gs`. We refer to this as **the execution of p**."
msgstr ""

#: ../../theory/naive-blockchain.rst:35
msgid ""
"When :math:`p` is not defined at point :math:`gs`, we say that "
"**execution of p on state gs failed**. This is how we represent errors in"
" program execution."
msgstr ""

#: ../../theory/naive-blockchain.rst:38
msgid "Executing sequences of transactions"
msgstr ""

#: ../../theory/naive-blockchain.rst:40
msgid ""
"We want to generalize this notion to sequences of transactions in such a "
"way that the information on execution errors is retained."
msgstr ""

#: ../../theory/naive-blockchain.rst:42
msgid ""
"Having a sequence of transactions :math:`p_1, p_2, ...., p_n\\in P` we'll"
" keep the information on execution success/error as a function "
":math:`status: [1,2,...,n] \\rightarrow \\{false, true\\}`."
msgstr ""

#: ../../theory/naive-blockchain.rst:44
msgid ""
"For any :math:`p \\in P` let :math:`\\triangle p: GS \\rightarrow GS` be "
"a total function that extends :math:`p` by applying identity whenever "
":math:`p` is not defined, hence formally as:"
msgstr ""

#: ../../theory/naive-blockchain.rst:46
msgid ""
"\\triangle p(x)=\\begin{cases}\n"
"p(x), & x \\in dom(p)\\\\\n"
"x, & otherwise\n"
"\\end{cases}"
msgstr ""

#: ../../theory/naive-blockchain.rst:54
msgid ""
"**Status(i)** represents the overall result (success vs failure) of the "
"execution of **i-th** transaction in the sequence."
msgstr ""

#: ../../theory/naive-blockchain.rst:56
msgid "Let:"
msgstr ""

#: ../../theory/naive-blockchain.rst:58
msgid ""
":math:`TSeq` be the set of finite sequences of transactions: :math:`TSeq "
"= P^{Int}`"
msgstr ""

#: ../../theory/naive-blockchain.rst:59
msgid ":math:`StatusTraces` be the set of finite sequences of Booleans"
msgstr ""

#: ../../theory/naive-blockchain.rst:61
msgid "We define the execution of a sequence of transactions as:"
msgstr ""

#: ../../theory/naive-blockchain.rst:63
msgid ""
"exec: GS \\times TSeq \\rightarrow GS \\times StatusTraces \\\\\n"
"exec(gs, [p1, p2, ...., pn]) = (resultGS, trace)"
msgstr ""

#: ../../theory/naive-blockchain.rst:69
msgid "… where:"
msgstr ""

#: ../../theory/naive-blockchain.rst:71
msgid ""
":math:`resultGS = \\Delta pn \\circ \\Delta pn-1 \\circ ... \\circ "
"\\Delta p1 (gs)`"
msgstr ""

#: ../../theory/naive-blockchain.rst:72
msgid ""
":math:`trace(i) = \\begin{cases} false, & execution \\space of \\space "
"p_i \\space failed \\\\ true, & otherwise \\end{cases}`"
msgstr ""

#: ../../theory/naive-blockchain.rst:74
msgid ""
"Intuitively, **exec** takes a pair - the initial global state and a "
"sequence of transactions to execute. The result is also a pair - the "
"resulting global state reached by sequentially applying all transactions "
"and a trace of this execution saying which transactions failed along the "
"way."
msgstr ""

#: ../../theory/naive-blockchain.rst:77
msgid "Executing sequences of blocks"
msgstr ""

#: ../../theory/naive-blockchain.rst:79
msgid ""
"A block contains sequences of transactions. Given some initial global "
"state :math:`gs \\in GS`, whenever we say “execute a block” we mean "
"executing the sequence of transactions it contains starting from "
":math:`gs`. We usually call :math:`gs` the **pre-state** of the block, "
"and we say **post-state** to denote the resulting global state returned "
"by :math:`exec(gs, sequence)`."
msgstr ""

#: ../../theory/naive-blockchain.rst:81
msgid ""
"Given any sequence of blocks we may also **execute the sequence of "
"blocks** because it is effectively a sequence of sequences of "
"transactions, so it may be flattened to a single sequence of "
"transactions."
msgstr ""

#: ../../theory/naive-blockchain.rst:83
msgid ""
"Given any set of blocks :math:`B`, we sometimes consider different linear"
" orders of such set. Given a linear order :math:`R` on set :math:`B`, we "
"are speaking about **executing the set of blocks B along linear order "
"R**, with the obvious semantics of taking all the blocks, arranging them "
"in a sequence following the order :math:`R`, and then executing the "
"resulting sequence of transactions."
msgstr ""

#: ../../theory/naive-blockchain.rst:86
msgid "Blockchain participants"
msgstr ""

#: ../../theory/naive-blockchain.rst:88
msgid ""
"We envision the infrastructure of blockchain participants as a collection"
" of actors (processes) communicating over a network, and where each "
"process plays one of the following roles:"
msgstr ""

#: ../../theory/naive-blockchain.rst:90
msgid ""
"**validators (aka “ring 0”)** - form a P2P network that attempts to reach"
" consensus on the ever-growing history of executed transactions; they do "
"this by creating and validating blocks"
msgstr ""

#: ../../theory/naive-blockchain.rst:91
msgid ""
"**finalizers (aka “ring 1”)** - they observe validators and try to deduce"
" the subset of history that is considered as “confirmed” (the “confirmed”"
" predicate is parameterized so to reflect the expected trust level)"
msgstr ""

#: ../../theory/naive-blockchain.rst:92
msgid ""
"**clients (aka “ring 2” or “dapps”)** - use the blockchain computer - "
"they send programs to be executed and react to execution results; a "
"client connects to a validator (one or many) to send transactions while "
"it also connects to a finalizer (one or many) to observe execution "
"results"
msgstr ""

#: ../../theory/naive-blockchain.rst:95
msgid "Stake management"
msgstr ""

#: ../../theory/naive-blockchain.rst:102
msgid ""
"In proof-of-stake blockchains, **stake** is a representation of the "
"voting power a validator has. We leave the question of exact "
"representation of stakes open. We only summarize here the minimal "
"assumptions we need for the mechanics of the blockchain to work."
msgstr ""

#: ../../theory/naive-blockchain.rst:105
msgid "Encoding of stakes"
msgstr ""

#: ../../theory/naive-blockchain.rst:107
msgid ""
"The main assumption is that a global state encodes (among other things) "
"the “weights map” - a mapping of validators to their voting power. So, "
"mathematically we expect the existence of a function that assigns to "
"every global state a function mapping validators to their weights:"
msgstr ""

#: ../../theory/naive-blockchain.rst:109
msgid ""
"weights\\_map: GS \\rightarrow Int^{ValidatorId} \\\\\n"
"weights\\_map(gs): ValidatorId \\rightarrow Int"
msgstr ""

#: ../../theory/naive-blockchain.rst:115
msgid ""
"Intuitively, the stake of a validator will be (usually) defined by the "
"amount of internal blockchain “money” allocated to the corresponding "
"account."
msgstr ""

#: ../../theory/naive-blockchain.rst:118
msgid "Bonding and unbonding"
msgstr ""

#: ../../theory/naive-blockchain.rst:120
msgid ""
"Blockchain users can increase/decrease the stake of a given validator. "
"This is to happen via executing (special) transactions."
msgstr ""

#: ../../theory/naive-blockchain.rst:122
msgid "Minimal stake **MIN_STAKE** is a parameter of the blockchain."
msgstr ""

#: ../../theory/naive-blockchain.rst:125
msgid "Unbonding stages"
msgstr ""

#: ../../theory/naive-blockchain.rst:127
msgid ""
"Unbonding is always a total unbonding -- a validator transitioning to "
"stake=0. There is no partial unbonding."
msgstr ""

#: ../../theory/naive-blockchain.rst:129
msgid ""
"Unbonding must be go in stages, leading to the following states of a "
"validator:"
msgstr ""

#: ../../theory/naive-blockchain.rst:131
msgid "STAKED"
msgstr ""

#: ../../theory/naive-blockchain.rst:132
msgid "VOTING_ONLY"
msgstr ""

#: ../../theory/naive-blockchain.rst:133
msgid "UNBONDING_ESCROW"
msgstr ""

#: ../../theory/naive-blockchain.rst:134
msgid "ZEROED"
msgstr ""

#: ../../theory/naive-blockchain.rst:136
msgid "While in STAKED, a validator can produce only blocks."
msgstr ""

#: ../../theory/naive-blockchain.rst:138
msgid "While in VOTING_ONLY, a validator can produce only ballots."
msgstr ""

#: ../../theory/naive-blockchain.rst:140
msgid ""
"While in UNBONDING_ESCROW and ZEROED, a validator is not supposed to "
"produce messages."
msgstr ""

#: ../../theory/naive-blockchain.rst:142
msgid ""
"The how of transitioning between states is beyond the scope of this "
"specification (it can be based on wall clock, p-time, j-daglevel, block "
"generation and other approaches)."
msgstr ""

#: ../../theory/naive-blockchain.rst:145
msgid "Slashing"
msgstr ""

#: ../../theory/naive-blockchain.rst:146
msgid ""
"Slashing is forced unbonding where the money used for the stake is "
"burned. The  intention is to penalizing equivocators."
msgstr ""

#: ../../theory/naive-blockchain.rst:150
msgid "Blockdag"
msgstr ""

#: ../../theory/naive-blockchain.rst:154
msgid "Visual introduction"
msgstr ""

#: ../../theory/naive-blockchain.rst:156
msgid ""
"The consensus protocol is based on a data structure we call a "
"**blockdag**, represented as a graph it looks like the following:"
msgstr ""

#: ../../theory/naive-blockchain.rst:162
msgid "The meaning of symbols:"
msgstr ""

#: ../../theory/naive-blockchain.rst:168
msgid "The 3 types of vertices in the graph are as follows:"
msgstr ""

#: ../../theory/naive-blockchain.rst:170
msgid ""
"**normal blocks** - contain transactions to be executed against the "
"blockchain computer"
msgstr ""

#: ../../theory/naive-blockchain.rst:171
msgid ""
"**ballots** - do not contain transactions, but participate in the "
"consensus"
msgstr ""

#: ../../theory/naive-blockchain.rst:172
msgid "**genesis** - a special block that stands as a root node of the structure"
msgstr ""

#: ../../theory/naive-blockchain.rst:174
msgid "Additionally we say:"
msgstr ""

#: ../../theory/naive-blockchain.rst:176
msgid "**block** - when we mean “normal block or genesis”"
msgstr ""

#: ../../theory/naive-blockchain.rst:177
msgid "**message** - when we mean “normal block or ballot”"
msgstr ""

#: ../../theory/naive-blockchain.rst:178
msgid "**vertex** - when we mean “normal block or ballot or genesis”"
msgstr ""

#: ../../theory/naive-blockchain.rst:180
msgid ""
"We visually mark the creator of a message by placing it in a relevant "
"swimlane. Genesis is outside swimlanes because genesis is given at "
"blockchain initialization (= it does not have a creator)."
msgstr ""

#: ../../theory/naive-blockchain.rst:182
msgid ""
"Every normal block points to its **main parent** block (we visualize this"
" with red arrows). Hence, blocks form a tree we call the **main tree**."
msgstr ""

#: ../../theory/naive-blockchain.rst:184
msgid ""
"Additionally, any normal block may point to an arbitrary number of blocks"
" as **secondary parents**. We visualize them with blue arrows. Blocks + "
"red arrows + blue arrows together form a directed acyclic graph we call "
"**the p-dag**."
msgstr ""

#: ../../theory/naive-blockchain.rst:186
msgid ""
"Any ballot points to exactly one block. We call this block “the target "
"block of a ballot”."
msgstr ""

#: ../../theory/naive-blockchain.rst:188
msgid ""
"Additionally, any message may point to an arbitrary number of vertices as"
" **additional justifications**. We visualize them with **dashed arrows**."
msgstr ""

#: ../../theory/naive-blockchain.rst:190
msgid ""
"All arrows together with all vertices form a directed acyclic graph we "
"call the **j-dag**."
msgstr ""

#: ../../theory/naive-blockchain.rst:193
msgid "DAG vs POSET language"
msgstr ""

#: ../../theory/naive-blockchain.rst:195
msgid "DAG is a common abbreviation for “directed acyclic graph”."
msgstr ""

#: ../../theory/naive-blockchain.rst:197
msgid "POSET is a common abbreviation for “partially ordered set”."
msgstr ""

#: ../../theory/naive-blockchain.rst:200
msgid ""
"When a DAG has at most one edge between any pair of vertices, we say this"
" DAG is “simple”."
msgstr ""

#: ../../theory/naive-blockchain.rst:202
msgid ""
"Any POSET can be seen as a simple DAG when you define an edge **a "
"\\rightarrow b** to be present whenever **a < b**."
msgstr ""

#: ../../theory/naive-blockchain.rst:204
msgid ""
"Any simple DAG leads to a POSET by taking its transitive closure and "
"saying that **a < b** iff there is an edge **a \\rightarrow b**. By "
"symmetry, taking **a < b** iff there is an edge **b \\rightarrow a**  is "
"also a POSET (just based on inverted order). Going in the other direction"
" - from POSET to a DAG - is analogous."
msgstr ""

#: ../../theory/naive-blockchain.rst:206
msgid ""
"In practice, POSET is “like a simple DAG” where we do not distinguish "
"between DAGs with the same transitive closure. In particular, for "
"visualization purposes it is convenient to draw a POSET as a transitive "
"reduction of a corresponding DAG."
msgstr ""

#: ../../theory/naive-blockchain.rst:208
msgid ""
"When talking about **j-dag** and **p-dag**, we blur the difference "
"between DAG language and POSET language, because essentially one language"
" is convertible to another."
msgstr ""

#: ../../theory/naive-blockchain.rst:211
msgid "Understanding the layers of the blockdag"
msgstr ""

#: ../../theory/naive-blockchain.rst:212
msgid ""
"Here we explain only the intuition behind the blockdag. These ideas are "
"formalized later in this document."
msgstr ""

#: ../../theory/naive-blockchain.rst:214
msgid ""
"**J-dag** is all about attesting what I have seen so far. When I am a "
"validator creating a new message (= block or ballot), I have to attest "
"what is my current protocol state -- i.e., what my current blockdag looks"
" like. I do this by including on the justifications list (which is part "
"of the new message) pointers to all **j-dag** tips present in my "
"blockdag. Please note that we continue to use the terminology established"
" for j-dag from previous chapters (*See* the topic on J-dag)."
msgstr ""

#: ../../theory/naive-blockchain.rst:217
msgid ""
"**Main-tree** encodes the multi-variant progress of a transaction's "
"history. When a validator creating a block B picks block A as the main "
"parent of B, it means “I want transactions included in B to extend the "
"history of the blockchain that ended at block A with all transactions in "
"A already executed”. This tree is analogous to a similar tree of blocks "
"that forms in a previous generation of blockchains, like Bitcoin or "
"Ethereum."
msgstr ""

#: ../../theory/naive-blockchain.rst:219
msgid ""
"**P-dag** and the concept of secondary parents, corresponds to “merging "
"of histories” -- a subtle optimization on the way we process "
"transactions. In blockchains such as Ethereum, effectively only a single "
"path of the main-tree ends up as “transactions that have been actually "
"executed” while all the rest of the main-tree ends up being wasted, or - "
"as we say - “orphaned”. In fact, the amount of wasted work can be reduced"
" by “merging”. While creating a new block, a validator performs careful "
"analysis of all branches of the main-tree and attempts to merge as many "
"of them possible without introducing a concurrency conflict."
msgstr ""

#: ../../theory/naive-blockchain.rst:222
msgid "Core mechanics of the blockchain"
msgstr ""

#: ../../theory/naive-blockchain.rst:223
msgid "The blockdag emerges as a combination of these central ideas:"
msgstr ""

#: ../../theory/naive-blockchain.rst:225
msgid ""
"Independently proposing updates of the shared database inevitably leads "
"to a tree of transactions (blocks) because the proposing validator must "
"choose which version of history it is about to extend. This is how the "
"**main-tree** pops up."
msgstr ""

#: ../../theory/naive-blockchain.rst:226
msgid ""
"All that remains is to add the mechanics for validators to collectively "
"agree on which branch of the main-tree is the “official” one."
msgstr ""

#: ../../theory/naive-blockchain.rst:227
msgid ""
"We solve this problem by recursively applying the Abstract Casper "
"Consensus (a.k.a. ACC)."
msgstr ""

#: ../../theory/naive-blockchain.rst:228
msgid ""
"The Secondary parents idea is a further refinement of the solution by "
"merging as many non-agreed paths of a main-tree as possible without "
"introducing inconsistencies."
msgstr ""

#: ../../theory/naive-blockchain.rst:230
msgid ""
"The single most crucial trick here is the recursive application of the "
"Abstract Casper Consensus -- to first try to understand this trick before"
" diving into detailed specs of how validators and finalizers operate."
msgstr ""

#: ../../theory/naive-blockchain.rst:232
msgid ""
"Let **b** be any block. So, **b** is a vertex in the main-tree. We will "
"consider a projection of validators P2P protocol to a particular Abstract"
" Casper Consensus model instance we will be calling **b-game**."
msgstr ""

#: ../../theory/naive-blockchain.rst:235
msgid "Abstract Casper Consensus concept"
msgstr ""

#: ../../theory/naive-blockchain.rst:235
msgid "How this concept maps to b-game"
msgstr ""

#: ../../theory/naive-blockchain.rst:238
msgid "validators"
msgstr ""

#: ../../theory/naive-blockchain.rst:238
msgid "validators with non-zero weight in post-state of **b**"
msgstr ""

#: ../../theory/naive-blockchain.rst:241
msgid "validator weights"
msgstr ""

#: ../../theory/naive-blockchain.rst:241
msgid "**weights-map(globals-states-db(b.po st-state-hash))**"
msgstr ""

#: ../../theory/naive-blockchain.rst:244
msgid "message"
msgstr ""

#: ../../theory/naive-blockchain.rst:244
msgid "message (= block or ballot)"
msgstr ""

#: ../../theory/naive-blockchain.rst:246
msgid "j-dag"
msgstr ""

#: ../../theory/naive-blockchain.rst:248
msgid "consensus value"
msgstr ""

#: ../../theory/naive-blockchain.rst:248
msgid "direct child of **b** in the **main-tree**"
msgstr ""

#: ../../theory/naive-blockchain.rst:251
msgid "message **m** is voting for consensus value **c**"
msgstr ""

#: ../../theory/naive-blockchain.rst:251
msgid ""
"for a block **m**: **m** is a descendant of **c** along the **main-"
"tree**, for a ballot **m**: **m.target-block** is a descendant of **c** "
"along the **main-tree** when above conditions are not met, we consider "
"**m** as voting for nothing (empty vote)"
msgstr ""

#: ../../theory/naive-blockchain.rst:261
msgid "The contents of the table above may be explained as follows:"
msgstr ""

#: ../../theory/naive-blockchain.rst:263
msgid ""
"Hypothetically assuming that validators already achieved consensus on the"
" block **b** as being the part of an “official” chain of blocks, they "
"will have to decide which direct child of **b** (in main-tree) will be "
"the next “official” chain."
msgstr ""

#: ../../theory/naive-blockchain.rst:264
msgid ""
"So the focus now is on the block **b** and on its direct main-tree "
"children."
msgstr ""

#: ../../theory/naive-blockchain.rst:265
msgid ""
"We setup the Abstract Casper Consensus instance “relative to block **b**”"
" where consensus values are direct children of **b**."
msgstr ""

#: ../../theory/naive-blockchain.rst:266
msgid ""
"Any block **x** can be seen as a vote for some child of **b** only if "
"**x** is a descendant of **b** in the main-tree. So if **x** is not a "
"descendant of **b**, we consider **x** as carrying an empty vote."
msgstr ""

#: ../../theory/naive-blockchain.rst:268
msgid ""
"**Note:** when defining the players of **b-game**, we exclude all "
"equivocators, as seen in the current protocol state. This means that "
"b-game is not “absolute”, it is rather depending on the current "
"perspective on the blockchain that given validator has. Also, the "
"collection of equivocators grows over time, which means that over time we"
" may need to recalculate b-game, excluding more validators. This aspect "
"plays a crucial role in how **finalizers** work - (*see below* the topic "
"**Operation of a finalizer**)."
msgstr ""

#: ../../theory/naive-blockchain.rst:270
msgid ""
"Not all **b-games** tend to be equally important. What happens is "
"presented with the following pattern:"
msgstr ""

#: ../../theory/naive-blockchain.rst:272
msgid "The **Genesis** block is given. So, **Genesis-game** is the first game."
msgstr ""

#: ../../theory/naive-blockchain.rst:273
msgid ""
"As the blockdag grows, the **Genesis-game** is progressing towards "
"finality."
msgstr ""

#: ../../theory/naive-blockchain.rst:274
msgid ""
"Finality of the **Genesis-game** means picking some direct child of "
"**Genesis**. Let us name this child **LFB1**"
msgstr ""

#: ../../theory/naive-blockchain.rst:275
msgid ""
"Then, the **LFB1-game** becomes the “important” game that everybody looks"
" at."
msgstr ""

#: ../../theory/naive-blockchain.rst:276
msgid "As the blockdag grows, the **LFB1-game** is progressing towards finality."
msgstr ""

#: ../../theory/naive-blockchain.rst:277
msgid ""
"Finality of the **LFB1-game** means picking some direct child of "
"**LFB1**. Let us name this child **LFB2**"
msgstr ""

#: ../../theory/naive-blockchain.rst:278
msgid "This pattern goes on forever."
msgstr ""

#: ../../theory/naive-blockchain.rst:280
msgid ""
"“LFB” stands for “last finalized block”. For symmetry, we set **LFB0** = "
"**Genesis**."
msgstr ""

#: ../../theory/naive-blockchain.rst:283
msgid "Why do we need ballots ?"
msgstr ""

#: ../../theory/naive-blockchain.rst:285
msgid ""
"The security of proof-of-stake blockchain is based on the stake in two "
"ways:"
msgstr ""

#: ../../theory/naive-blockchain.rst:287
msgid ""
"Large investment (=money) is needed to revert/overtake the history of "
"transactions using honest means."
msgstr ""

#: ../../theory/naive-blockchain.rst:288
msgid "Malicious behavior (= hacking) implies that the stake will get slashed."
msgstr ""

#: ../../theory/naive-blockchain.rst:290
msgid ""
"Therefore, we would like only bonded validators to be able to participate"
" in blockchain evolution. The problem here is that - when a validator "
"unbonds, some of the **b-games** he was a player of might not be "
"completed (= finalized) yet. We would like to allow the validator to "
"still participate in these games while not allowing him to join new "
"games. This is where ballots come into play. Ballots make it possible for"
" a validator that is no longer bonded to continue the consensus game."
msgstr ""

#: ../../theory/naive-blockchain.rst:293
msgid "Merging of histories"
msgstr ""

#: ../../theory/naive-blockchain.rst:296
msgid "Topological sortings of p-past-cone"
msgstr ""

#: ../../theory/naive-blockchain.rst:298
msgid "This is a previous example of a blockdag, reduced to **p-dag** only:"
msgstr ""

#: ../../theory/naive-blockchain.rst:304
msgid ""
"We define **p-past-cone(b)** as the set of all blocks :math:`x` such that"
" :math:`x \\leqslant b` (in the POSET corresponding to p-dag, :math:`x "
"\\leqslant y \\iff y \\rightarrow x`)."
msgstr ""

#: ../../theory/naive-blockchain.rst:306
msgid ""
"**Example:** Let’s look at the block :math:`3`. Its p-past-cone is "
":math:`\\{Genesis, 1, 2, 3\\}`. Let’s look at the block :math:`9`. Its p"
"-past-cone is :math:`\\{Genesis, 1,2,3,4,5,9\\}`."
msgstr ""

#: ../../theory/naive-blockchain.rst:308
msgid ""
"Of course, any **p-past-cone(b)** inherits the order from the whole "
"**p-dag**, so it can be seen as a POSET as well."
msgstr ""

#: ../../theory/naive-blockchain.rst:310
msgid ""
"For :math:`\\langle A,R\\rangle` any POSET, topological sorting of "
":math:`\\langle A,R\\rangle` is any linear order :math:`\\langle "
"A,T\\rangle` such that :math:`identity: \\langle A,R\\rangle \\rightarrow"
" \\langle A,T\\rangle` is monotonic. In other words, topological sorting "
"is converting a POSET into a total order in a way that preserves the "
"original order. For a given POSET, this can usually be done in many ways."
msgstr ""

#: ../../theory/naive-blockchain.rst:314
msgid ""
"\\ **Example:**\\  Let’s take the :math:`p\\_past\\_cone(3)` from our "
"example. As a POSET it looks like this:"
msgstr ""

#: ../../theory/naive-blockchain.rst:320
msgid "It can be topo-sorted in two ways only:"
msgstr ""

#: ../../theory/naive-blockchain.rst:326
msgid ""
"Example: Let’s take the p-past-cone(9) from our example. As a POSET it "
"looks like this:"
msgstr ""

#: ../../theory/naive-blockchain.rst:332
msgid "It can be topo-sorted in many ways. One such topo-sort is shown below:"
msgstr ""

#: ../../theory/naive-blockchain.rst:339
msgid "The context of merging problem"
msgstr ""

#: ../../theory/naive-blockchain.rst:341
msgid ""
"Let’s assume that current p-dag as seen by a validator **v** looks like "
"this:"
msgstr ""

#: ../../theory/naive-blockchain.rst:347
msgid ""
"To add a new block :math:`x`, validator :math:`V` needs to decide which "
"blocks to take as parents of :math:`x`. In other words, decide which "
"variants of a transactions history block :math:`x` will continue. Merging"
" is all about defining what it means that **x** continues more than one "
"version of the history:"
msgstr ""

#: ../../theory/naive-blockchain.rst:353
msgid ""
"We have blocks 8, 9 and 10 as current tips of p-dag, so they are "
"candidates for becoming parents of the new block. But usually, we won’t "
"be able to take all such tips as parents because the versions of the "
"transactions history they represent are in conflict."
msgstr ""

#: ../../theory/naive-blockchain.rst:357
msgid "Formal definition of merging"
msgstr ""

#: ../../theory/naive-blockchain.rst:359
msgid ""
"We say that a set of blocks :math:`B = \\{b_1, b_2, ..., b_n\\}` is "
"**mergeable** (= **not in conflict**) when the following holds:"
msgstr ""

#: ../../theory/naive-blockchain.rst:361
msgid ""
"take the sum :math:`S` of :math:`p\\_past\\_cone(b_i)` for "
":math:`i=1,..., n` - this is a sub-POSET of p-dag"
msgstr ""

#: ../../theory/naive-blockchain.rst:363
msgid "given any topo-sort :math:`T` of :math:`S`"
msgstr ""

#: ../../theory/naive-blockchain.rst:365
msgid "the execution of transactions in :math:`B` along :math:`T` give:"
msgstr ""

#: ../../theory/naive-blockchain.rst:367
msgid "the same final global state (regardless of the selection of **T)**"
msgstr ""

#: ../../theory/naive-blockchain.rst:369
msgid ""
"the same subset of transactions that failed (regardless of the selection "
"of **T**)"
msgstr ""

#: ../../theory/naive-blockchain.rst:372
msgid "Operation of a validator"
msgstr ""

#: ../../theory/naive-blockchain.rst:374
msgid ""
"The spec is written from the perspective of a validator. We say it as "
"**local validator** in order to reference the validator which is running "
"the algorithm. Let **vid** be the id of the local validator."
msgstr ""

#: ../../theory/naive-blockchain.rst:377
msgid "Validators P2P protocol - messages"
msgstr ""

#: ../../theory/naive-blockchain.rst:379
msgid "Validators exchange messages which can be of 2 types:"
msgstr ""

#: ../../theory/naive-blockchain.rst:381
msgid "**blocks**"
msgstr ""

#: ../../theory/naive-blockchain.rst:382
msgid "**ballots**"
msgstr ""

#: ../../theory/naive-blockchain.rst:384
msgid "A **block** contains the following data:"
msgstr ""

#: ../../theory/naive-blockchain.rst:386 ../../theory/naive-blockchain.rst:399
msgid "**block id**"
msgstr ""

#: ../../theory/naive-blockchain.rst:387
msgid "**creator id** (= id of validator that created this block)"
msgstr ""

#: ../../theory/naive-blockchain.rst:388
msgid "**main parent** (id of another block)"
msgstr ""

#: ../../theory/naive-blockchain.rst:389
msgid "**secondary parents** (collection of block ids, may be empty)"
msgstr ""

#: ../../theory/naive-blockchain.rst:390
msgid ""
"**justifications** (collection of message ids that the creator confirms "
"as seen at the moment of creation of this block; excluding main parent "
"and secondary parents; may be empty)"
msgstr ""

#: ../../theory/naive-blockchain.rst:391
msgid "**transactions list** (nonempty)"
msgstr ""

#: ../../theory/naive-blockchain.rst:392
msgid ""
"**pre-state-hash** - hash of global state that represents state after "
"executing all parents of this block"
msgstr ""

#: ../../theory/naive-blockchain.rst:393
msgid ""
"**post-state hash** - hash of global state achieved after executing "
"transactions in this block (and all previous blocks, as implied by p-dag)"
msgstr ""

#: ../../theory/naive-blockchain.rst:395
msgid ""
"For a block :math:`b` we define the collection "
":math:`b.all\\_justifications` as main parent + secondary parents + "
"justifications. This collection is always non-empty because **main "
"parent** is a mandatory field."
msgstr ""

#: ../../theory/naive-blockchain.rst:397
msgid "A **ballot** contains the following data:"
msgstr ""

#: ../../theory/naive-blockchain.rst:400
msgid "**creator id** (= id of validator that created this ballot)"
msgstr ""

#: ../../theory/naive-blockchain.rst:401
msgid "**target block** (id of a block)"
msgstr ""

#: ../../theory/naive-blockchain.rst:402
msgid ""
"**justifications** (collection of message ids that the creator confirms "
"as seen at the moment of creation of this ballot, excluding the target "
"block; may be empty)"
msgstr ""

#: ../../theory/naive-blockchain.rst:404
msgid ""
"For a ballot **b** we define the collection "
":math:`b.all\\_justifications` as target block + additional "
"justifications. This collection is always non-empty because target block "
"is a mandatory field."
msgstr ""

#: ../../theory/naive-blockchain.rst:406
msgid ""
"From the definitions above it follows that for every message :math:`m` "
"there is a **j-dag** path from :math:`m` to :math:`Genesis`."
msgstr ""

#: ../../theory/naive-blockchain.rst:409
msgid "Validators P2P protocol - behavior"
msgstr ""

#: ../../theory/naive-blockchain.rst:411
msgid ""
"We use the same assumptions on a message-passing network as were stated "
"in the Abstract Casper Consensus model. So, validators only exchange "
"information by broadcasting messages where the broadcasting "
"implementation provides an exactly-once delivery guarantee, but the "
"delays and shuffling of messages are arbitrary."
msgstr ""

#: ../../theory/naive-blockchain.rst:413
msgid "During its lifetime, a validator maintains the following data structures:"
msgstr ""

#: ../../theory/naive-blockchain.rst:415
msgid ""
"**deploys-buffer** - a buffer of transactions sent by clients, to be "
"executed on the blockchain computer"
msgstr ""

#: ../../theory/naive-blockchain.rst:416
msgid ""
"**blockdag** - keeping all blocks and ballots either produced by or "
"received from other validators"
msgstr ""

#: ../../theory/naive-blockchain.rst:417
msgid ""
"**messages-buffer** - a buffer of messages received, but not yet "
"incorporated into the **blockdag**"
msgstr ""

#: ../../theory/naive-blockchain.rst:418
msgid ""
"**latest-honest-messages** - a mapping from validator id to message id, "
"pointing every validator known in the **blockdag**, excluding "
"**equivocators**, to the corresponding swimlane tip"
msgstr ""

#: ../../theory/naive-blockchain.rst:419
msgid ""
"**equivocators** - a collection of validators for which current blockdag "
"contains an equivocation"
msgstr ""

#: ../../theory/naive-blockchain.rst:420
msgid ""
"**reference-finalizer** - an instance of finalizer used internally (*see*"
" **Operation of a finalizer** later in this spec for more information "
"about what finalizers are)"
msgstr ""

#: ../../theory/naive-blockchain.rst:421
msgid "**global-states-db** - mapping of global state hash to global state"
msgstr ""

#: ../../theory/naive-blockchain.rst:423
msgid ""
"A message :math:`m` can be added to the :math:`blockdag` only if all "
"justifications of :math:`m` are already present in the blockdag. So if a "
"validator receives a message before receiving some of its justifications,"
" the received message must wait in the :math:`messages\\_buffer`."
msgstr ""

#: ../../theory/naive-blockchain.rst:425
msgid "A validator is concurrently executing two infinite loops of processing:"
msgstr ""

#: ../../theory/naive-blockchain.rst:427
msgid "**Listening loop:**"
msgstr ""

#: ../../theory/naive-blockchain.rst:429
msgid ""
"Listen to messages incoming from other validators. Whenever a message "
":math:`m` (block or ballot) arrives, follow this handling scenario:"
msgstr ""

#: ../../theory/naive-blockchain.rst:431
msgid ""
"Validate the formal structure of :math:`m`. In case of any error - drop "
":math:`m` (invalid message) and exit."
msgstr ""

#: ../../theory/naive-blockchain.rst:433
msgid ""
"Check if all justifications of :math:`m` are already included in "
":math:`blockdag`."
msgstr ""

#: ../../theory/naive-blockchain.rst:435
msgid "if yes: continue"
msgstr ""

#: ../../theory/naive-blockchain.rst:437
msgid "otherwise: append :math:`m` to the :math:`messages\\_buffer`, then exit"
msgstr ""

#: ../../theory/naive-blockchain.rst:439
msgid ""
"Perform processing specific to type of :math:`m` (block or ballot) - see "
"below."
msgstr ""

#: ../../theory/naive-blockchain.rst:441
msgid "If :math:`equivocators` does not contain :math:`m.creator`:"
msgstr ""

#: ../../theory/naive-blockchain.rst:443
msgid ""
"Check if :math:`m` introduces new equivocation - this is the case when "
":math:`latest\\_honest\\_messages(m.creator)` is not member of "
":math:`j\\_past\\_cone(m)`"
msgstr ""

#: ../../theory/naive-blockchain.rst:445
msgid "If yes then add :math:`m.creator` to :math:`equivocators`"
msgstr ""

#: ../../theory/naive-blockchain.rst:447
msgid ""
"If :math:`equivocators` does not contain :math:`m.creator`, update "
":math:`latest\\_honest\\_messages` map by setting "
":math:`latest\\_honest\\_messages(m.creator) = m`"
msgstr ""

#: ../../theory/naive-blockchain.rst:449
msgid ""
"Check if there is any message :math:`x` in :math:`messages\\_buffer` that"
" can now leave the buffer and be included in the :math:`blockdag` because"
" of :math:`x.all\\_justifications` are now present in the "
":math:`blockdag`. For first such :math:`x` found, apply steps (3) - (4) -"
" (5) ."
msgstr ""

#: ../../theory/naive-blockchain.rst:451
msgid ""
"(“Buffer pruning cascade”) Repeat step (6) as many times as there are "
"blocks that can be released from the buffer."
msgstr ""

#: ../../theory/naive-blockchain.rst:453
msgid "Processing specific to type of :math:`m` goes as follows:"
msgstr ""

#: ../../theory/naive-blockchain.rst:455
msgid "If :math:`m` is a block:"
msgstr ""

#: ../../theory/naive-blockchain.rst:457
msgid ""
"Validate whether :math:`m` parents (main parent and secondary parents) "
"were selected correctly:"
msgstr ""

#: ../../theory/naive-blockchain.rst:459 ../../theory/naive-blockchain.rst:478
msgid ""
"run the fork-choice for the protocol state derived from justifications of"
" :math:`m`"
msgstr ""

#: ../../theory/naive-blockchain.rst:461
msgid "compare calculated parents with actual parent of :math:`m`:"
msgstr ""

#: ../../theory/naive-blockchain.rst:463 ../../theory/naive-blockchain.rst:481
msgid "if they are the same: append :math:`m` to :math:`blockdag`."
msgstr ""

#: ../../theory/naive-blockchain.rst:464 ../../theory/naive-blockchain.rst:482
msgid "otherwise - drop the block (invalid block) and exit"
msgstr ""

#: ../../theory/naive-blockchain.rst:466
msgid ""
"Check if parents of :math:`m` are not conflicting. If they are "
"conflicting, then drop the block (invalid block) and exit."
msgstr ""

#: ../../theory/naive-blockchain.rst:468
msgid ""
"Calculate pre-state for :math:`m` by executing the transactions in the "
"merged history that is determined by all parents of :math:`m`. Check if "
"calculated hash of pre-state is equal to pre-state-hash stored in "
":math:`m`. If not, then drop :math:`m` (invalid block) and exit."
msgstr ""

#: ../../theory/naive-blockchain.rst:470
msgid ""
"Calculate post-state for :math:`m` by sequentially applying all "
"transactions in :math:`m` on top of global state calculated in step (3). "
"Check if calculated hash of post-state is equal to post-state-hash stored"
" in :math:`m`. If not, then drop :math:`m` (invalid block) and exit."
msgstr ""

#: ../../theory/naive-blockchain.rst:472
msgid "Store post-state calculated in step (4) in :math:`global\\_states\\_db`."
msgstr ""

#: ../../theory/naive-blockchain.rst:474
msgid "If :math:`m` is a ballot:"
msgstr ""

#: ../../theory/naive-blockchain.rst:476
msgid "Validate whether :math:`m.target\\_block` was selected correctly:"
msgstr ""

#: ../../theory/naive-blockchain.rst:479
msgid ""
"compare calculated main parent candidate with actual "
":math:`m.target\\_block`:"
msgstr ""

#: ../../theory/naive-blockchain.rst:484
msgid "**Publishing loop:**"
msgstr ""

#: ../../theory/naive-blockchain.rst:486
msgid ""
"Sleep unless the next time for proposing a block arrives (typically this "
"may be a periodic activity based on wall clock)."
msgstr ""

#: ../../theory/naive-blockchain.rst:488
msgid ""
"Run fork-choice against the current blockdag (see next section). The "
"result is:"
msgstr ""

#: ../../theory/naive-blockchain.rst:490
msgid "Main parent - :math:`mp`."
msgstr ""

#: ../../theory/naive-blockchain.rst:491
msgid "Collection of secondary parents - :math:`sp` - sorted by preference."
msgstr ""

#: ../../theory/naive-blockchain.rst:493
msgid ""
"Pick the maximal non-conflicting subset :math:`mncsp \\subset sp`, "
"respecting the selection of :math:`mp` and the ordering of :math:`sp`."
msgstr ""

#: ../../theory/naive-blockchain.rst:495
msgid ""
"Calculate merged global state :math:`merged\\_gs` derived from "
":math:`\\{mp\\} \\cup mncsp`."
msgstr ""

#: ../../theory/naive-blockchain.rst:497
msgid ""
"Check the weight of local validator in merged global state: "
":math:`weights\\_map(merged\\_gs)(vid)`"
msgstr ""

#: ../../theory/naive-blockchain.rst:499
msgid ""
"If weight is non-zero and :math:`deploys-buffer` is nonempty, we will be "
"creating and publishing a new block."
msgstr ""

#: ../../theory/naive-blockchain.rst:501
msgid "otherwise - check the status of local validator:"
msgstr ""

#: ../../theory/naive-blockchain.rst:503
msgid "VOTING_ONLY => create and publish a new ballot"
msgstr ""

#: ../../theory/naive-blockchain.rst:504
msgid "otherwise => exit"
msgstr ""

#: ../../theory/naive-blockchain.rst:506
msgid "Case 1: new block"
msgstr ""

#: ../../theory/naive-blockchain.rst:508
msgid ""
"Take desired subset of transactions :math:`trans` from :math:`deploys-"
"buffer` (this part of behavior is subject to a separate spec; on this "
"level of abstraction we accept any strategy of picking transactions from "
"the buffer)."
msgstr ""

#: ../../theory/naive-blockchain.rst:509
msgid ""
"Apply :math:`trans` sequentially on top of :math:`merged\\_gs`. Let "
":math:`post\\_gs` be the resulting global state."
msgstr ""

#: ../../theory/naive-blockchain.rst:510
msgid "Create new block:"
msgstr ""

#: ../../theory/naive-blockchain.rst:512 ../../theory/naive-blockchain.rst:528
msgid "block id = hash of the binary representation of this block"
msgstr ""

#: ../../theory/naive-blockchain.rst:513 ../../theory/naive-blockchain.rst:529
msgid "creator id = :math:`vid`"
msgstr ""

#: ../../theory/naive-blockchain.rst:514
msgid "main parent = :math:`mp`"
msgstr ""

#: ../../theory/naive-blockchain.rst:515
msgid "secondary parents = :math:`mncsp`"
msgstr ""

#: ../../theory/naive-blockchain.rst:516
msgid ""
"justifications = :math:`latest\\_honest\\_messages` after removing main "
"parent, secondary parents, and redundant messages (see explanation below)"
msgstr ""

#: ../../theory/naive-blockchain.rst:517
msgid "transactions list = :math:`trans`"
msgstr ""

#: ../../theory/naive-blockchain.rst:518
msgid "pre-state-hash = :math:`hash(merged\\_gs)`"
msgstr ""

#: ../../theory/naive-blockchain.rst:519
msgid "post-state hash = :math:`hash(post\\_gs)`"
msgstr ""

#: ../../theory/naive-blockchain.rst:521
msgid "Store :math:`post\\_gs` in :math:`global\\_states\\_db`"
msgstr ""

#: ../../theory/naive-blockchain.rst:522
msgid "Broadcast new block across validators P2P network."
msgstr ""

#: ../../theory/naive-blockchain.rst:524
msgid "Case 2: new ballot"
msgstr ""

#: ../../theory/naive-blockchain.rst:526
msgid "Create new ballot:"
msgstr ""

#: ../../theory/naive-blockchain.rst:530
msgid "target block = :math:`mp`"
msgstr ""

#: ../../theory/naive-blockchain.rst:531
msgid ""
"justifications = :math:`latest\\_honest\\_messages` after removing: "
"target block and redundant messages (see explanation below)"
msgstr ""

#: ../../theory/naive-blockchain.rst:533
msgid "Broadcast new ballot across validators P2P network."
msgstr ""

#: ../../theory/naive-blockchain.rst:535
msgid ""
"Note: we generally want to keep the collection :math:`m.justifications` "
"as short as possible. For this, we never include there main parent, "
"secondary parents, and target block. Also, we want the collection of "
"justifications included in the message to be transitively reduced (= "
"included justifications form an antichain)."
msgstr ""

#: ../../theory/naive-blockchain.rst:539
msgid "Relative votes"
msgstr ""

#: ../../theory/naive-blockchain.rst:541
msgid ""
"We will need the concept of “last message created by validator **v** that"
" was a non-empty vote in **b-game**”. Given any block :math:`b` and any "
"validator :math:`V` let us take look at the swimlane of :math:`V`. If "
":math:`v` is honest, then this swimlane is a chain. Any message :math:`m`"
" counts as a non-empty vote in **b-game** only if:"
msgstr ""

#: ../../theory/naive-blockchain.rst:543
msgid ""
":math:`m` is a block and the ancestor of :math:`m` (in main-tree) is "
":math:`b`"
msgstr ""

#: ../../theory/naive-blockchain.rst:544
msgid ""
":math:`m` is a ballot and the ancestor of :math:`m.target\\_block` (in "
"main-tree) is :math:`b`"
msgstr ""

#: ../../theory/naive-blockchain.rst:546
msgid ""
"We start from the latest (= top-most on the diagram) message in the "
":math:`swimlane(v)` and we traverse the swimlane down, stopping as soon "
"as we find a message that counts as a non-empty vote in **b-game**."
msgstr ""

#: ../../theory/naive-blockchain.rst:548
msgid "\\ **Example:**\\"
msgstr ""

#: ../../theory/naive-blockchain.rst:550
msgid ""
"Below is the original example of the blockdag, but with all messages that"
" are non-empty votes in 3-game highlighted with green:"
msgstr ""

#: ../../theory/naive-blockchain.rst:556 ../../theory/naive-blockchain.rst:763
msgid "**Example:**"
msgstr ""

#: ../../theory/naive-blockchain.rst:558
msgid "Let us again look at the example of a blockdag:"
msgstr ""

#: ../../theory/naive-blockchain.rst:564
msgid ""
"Let’s apply this definition using validator 3 as the example and find the"
" last votes of validator 3 in various games."
msgstr ""

#: ../../theory/naive-blockchain.rst:567
msgid "Block b"
msgstr ""

#: ../../theory/naive-blockchain.rst:567
msgid "Last non-empty vote of validator 3 in b-game"
msgstr ""

#: ../../theory/naive-blockchain.rst:569
msgid "Genesis"
msgstr ""

#: ../../theory/naive-blockchain.rst:569 ../../theory/naive-blockchain.rst:571
#: ../../theory/naive-blockchain.rst:574
msgid "14"
msgstr ""

#: ../../theory/naive-blockchain.rst:570
msgid "1"
msgstr ""

#: ../../theory/naive-blockchain.rst:570 ../../theory/naive-blockchain.rst:572
msgid "9"
msgstr ""

#: ../../theory/naive-blockchain.rst:571
msgid "2"
msgstr ""

#: ../../theory/naive-blockchain.rst:572
msgid "3"
msgstr ""

#: ../../theory/naive-blockchain.rst:573
msgid "4"
msgstr ""

#: ../../theory/naive-blockchain.rst:573 ../../theory/naive-blockchain.rst:575
msgid "(none)"
msgstr ""

#: ../../theory/naive-blockchain.rst:574
msgid "5"
msgstr ""

#: ../../theory/naive-blockchain.rst:575
msgid "6"
msgstr ""

#: ../../theory/naive-blockchain.rst:579
msgid "Fork choice"
msgstr ""

#: ../../theory/naive-blockchain.rst:581
msgid ""
"The goal of fork-choice is to take the decision on top of the version of "
"the shared database history we want to build in the next step. This "
"decision can be seen as an iterative application of the reference "
"estimator from the “Abstract Casper Consensus”. As a result we want to "
"get a list of blocks (ordered by preference) which will serve as parent "
"candidates for the new block."
msgstr ""

#: ../../theory/naive-blockchain.rst:583
msgid "The algorithm goes as follows:"
msgstr ""

#: ../../theory/naive-blockchain.rst:585
msgid ""
"Decide which protocol state :math:`ps` to use: 1. When using fork choice "
"for creation of new block this is the point where the validator can "
"decide on the subset of his local knowledge to reveal to outside world. "
"Ideally, the validator reveals all local knowledge, so it takes as "
"protocol state the whole local blockdag."
msgstr ""

#: ../../theory/naive-blockchain.rst:588
msgid ""
"When using fork choice for validation of received message :math:`m`, the "
"protocol state to take is :math:`j\\_past\\_cone(m)`."
msgstr ""

#: ../../theory/naive-blockchain.rst:590
msgid ""
"Take :math:`HV` - all honest validators (all creators of messages in "
":math:`ps` minus those seen equivocating with messages in :math:`ps`)."
msgstr ""

#: ../../theory/naive-blockchain.rst:591
msgid ""
"Find latest message :math:`lm(v)` created by each validator :math:`v \\in"
" HV`, ignoring validators that produced no message."
msgstr ""

#: ../../theory/naive-blockchain.rst:592
msgid "For all validators that have :math:`lm(v)` defined take:"
msgstr ""

#: ../../theory/naive-blockchain.rst:594
msgid ""
"tipBlock(v)=\\begin{cases} lm(v), & lm(v) \\space is \\space a \\space "
"block \\\\lm(v).target\\_block, & otherwise \\end{cases}"
msgstr ""

#: ../../theory/naive-blockchain.rst:599
msgid ""
"Take :math:`lca\\_block` = latest common ancestor along main-tree of all "
":math:`tipBlock(v)`"
msgstr ""

#: ../../theory/naive-blockchain.rst:601
msgid ""
"Initialize resulting collection of blocks as one-element list "
":math:`Result = [lca\\_block]`"
msgstr ""

#: ../../theory/naive-blockchain.rst:603
msgid ""
"For each block :math:`b` in :math:`Result` replace :math:`b` with its "
"direct children in main-tree: :math:`c_1, c_2, ..., c_n`, where the list "
"of children is ordered following this recipe:"
msgstr ""

#: ../../theory/naive-blockchain.rst:605
msgid ""
"For each honest validator :math:`v` find :math:`lmb(v)` - the last "
"message by :math:`v` voting in **b-game.**"
msgstr ""

#: ../../theory/naive-blockchain.rst:607
msgid ""
"Find a child :math:`c_i` that :math:`lmb(v)` is voting for - by "
"traversing down the main-tree."
msgstr ""

#: ../../theory/naive-blockchain.rst:609
msgid "Using :math:`validator\\_weights(b)` count the votes."
msgstr ""

#: ../../theory/naive-blockchain.rst:611
msgid ""
"Order the sequence :math:`c_i` by calculated votes, using :math:`ci.id` "
"(= block hash) as tie-breaker."
msgstr ""

#: ../../theory/naive-blockchain.rst:613
msgid "Repeat step 7 as long as it is changing **Result**."
msgstr ""

#: ../../theory/naive-blockchain.rst:615
msgid ""
"The **Result** is the list of blocks we want. The first block on the list"
" is the main parent candidate, remaining blocks are secondary parents "
"candidates."
msgstr ""

#: ../../theory/naive-blockchain.rst:618
msgid "Operation of a finalizer"
msgstr ""

#: ../../theory/naive-blockchain.rst:621
msgid "The objective"
msgstr ""

#: ../../theory/naive-blockchain.rst:623
msgid ""
"Finalizer observes the growing blockchain. The objective is to recognize "
"the subset of transactions history that:"
msgstr ""

#: ../../theory/naive-blockchain.rst:625
msgid "is already agreed (as a result of on-going consensus)"
msgstr ""

#: ../../theory/naive-blockchain.rst:626
msgid ""
"cannot be reverted (unless the equivocators collection exceeds - by total"
" weight - predefined threshold)"
msgstr ""

#: ../../theory/naive-blockchain.rst:629
msgid "Parameters"
msgstr ""

#: ../../theory/naive-blockchain.rst:631
msgid ""
"In general - different finalizers will be based on different finality "
"criteria. For the current design we assume that the criterion described "
"in the previous chapter is in use."
msgstr ""

#: ../../theory/naive-blockchain.rst:633
msgid "Hence, the finalizer is parameterized by:"
msgstr ""

#: ../../theory/naive-blockchain.rst:635
msgid "the type of finality detector to be used"
msgstr ""

#: ../../theory/naive-blockchain.rst:637
msgid "**K** - acknowledgement level"
msgstr ""

#: ../../theory/naive-blockchain.rst:639
msgid "**WP** (weight percentage) - expressed as a number between 0 and 1"
msgstr ""

#: ../../theory/naive-blockchain.rst:642
msgid "State"
msgstr ""

#: ../../theory/naive-blockchain.rst:644
msgid ""
"The assumption is that a finalizer can traverse the blockdag, reading "
"contents of blocks. Also, for any block b it should be able to read post-"
"state of b, and in particular get the weights-map from this post-state."
msgstr ""

#: ../../theory/naive-blockchain.rst:646
msgid ""
"The internal state of the “reference” implementation of a finalizer would"
" be:"
msgstr ""

#: ../../theory/naive-blockchain.rst:648
msgid "**equivocators: Set[ValidatorId]**"
msgstr ""

#: ../../theory/naive-blockchain.rst:650
msgid "**current-game-id: Int**"
msgstr ""

#: ../../theory/naive-blockchain.rst:652
msgid ""
"current finality detector instance - the one observing **LFB(current-"
"game-id)-game**"
msgstr ""

#: ../../theory/naive-blockchain.rst:654
msgid "**LFB: Seq[Block]** for **i=0 … current-game-id**"
msgstr ""

#: ../../theory/naive-blockchain.rst:656
msgid "**initial-players: Seq[Set[ValidatorId]]**"
msgstr ""

#: ../../theory/naive-blockchain.rst:658
msgid "**excluded-players: Seq[Set[ValidatorId]]**"
msgstr ""

#: ../../theory/naive-blockchain.rst:660
msgid "**FTT: Seq[Int]**"
msgstr ""

#: ../../theory/naive-blockchain.rst:662
msgid ""
"Initial state (on the beginning of the blockchain, the only block is "
"Genesis):"
msgstr ""

#: ../../theory/naive-blockchain.rst:664
msgid "**equivocators** = empty set"
msgstr ""

#: ../../theory/naive-blockchain.rst:665
msgid "**current-game-id** = 0"
msgstr ""

#: ../../theory/naive-blockchain.rst:666
msgid ""
"current finality detector instance = new instance (according to "
"configured type of finality detector to be used)"
msgstr ""

#: ../../theory/naive-blockchain.rst:667
msgid "**LFB** = empty sequence"
msgstr ""

#: ../../theory/naive-blockchain.rst:668
msgid ""
"**initial-players** = one element sequence, with the single element being"
" the set of ids of validators bonded at Genesis"
msgstr ""

#: ../../theory/naive-blockchain.rst:670
msgid ""
"**excluded-players** = one element sequence, with the single element "
"being the empty set"
msgstr ""

#: ../../theory/naive-blockchain.rst:672
msgid "**FTT(0) = ceiling(WP \\* total-weight(post-state of Genesis))**"
msgstr ""

#: ../../theory/naive-blockchain.rst:675
msgid "Behaviour - the general plan"
msgstr ""

#: ../../theory/naive-blockchain.rst:677
msgid ""
"The operation of a finalizer can be decomposed as the following, "
"partially independent activities:"
msgstr ""

#: ../../theory/naive-blockchain.rst:679
msgid ""
"Maintaining equivocators collection corresponding to current protocol "
"state."
msgstr ""

#: ../../theory/naive-blockchain.rst:680
msgid "Building the **LFB** chain"
msgstr ""

#: ../../theory/naive-blockchain.rst:681
msgid ""
"Propagating **LFB** chain finality via secondary parents (indirect "
"finalization)."
msgstr ""

#: ../../theory/naive-blockchain.rst:682
msgid ""
"Monitoring old games in **LFB** chain for the possibility of equivocation"
" catastrophe."
msgstr ""

#: ../../theory/naive-blockchain.rst:683
msgid "Reacting to equivocation catastrophe (by recalculating the **LFB** chain)."
msgstr ""

#: ../../theory/naive-blockchain.rst:684
msgid ""
"Publishing the stream of finalized blocks (over some streaming API) - "
"this includes possibly also maintaining the collection of subscribers."
msgstr ""

#: ../../theory/naive-blockchain.rst:687
msgid "LFB chain"
msgstr ""

#: ../../theory/naive-blockchain.rst:689
msgid ""
"**LFB(i)** is supposed to be the “i-th last finalized block”. **LFB** "
"chain is achieved in the following way:"
msgstr ""

#: ../../theory/naive-blockchain.rst:691
msgid "Take **LFB(0) = Genesis**"
msgstr ""

#: ../../theory/naive-blockchain.rst:693
msgid ""
"Let’s assume that LFB(m) is the last-so-far element of the chain. So in "
"other words, it is the last finalized block."
msgstr ""

#: ../../theory/naive-blockchain.rst:695
msgid ""
"For deciding which main-tree child of LFB(m) should be taken as LFB(m+1) "
"we need to start a new empty instance of finality detector."
msgstr ""

#: ../../theory/naive-blockchain.rst:697
msgid ""
"**initial-players(m)** = validators staked at post-state of **m**, "
"excluding current contents of **equivocators**"
msgstr ""

#: ../../theory/naive-blockchain.rst:699
msgid "**excluded-players(m)** = empty set"
msgstr ""

#: ../../theory/naive-blockchain.rst:701
msgid "Finality detector observes the LFB(m)-game, with:"
msgstr ""

#: ../../theory/naive-blockchain.rst:703
msgid ""
"game-level acknowledgement level **K** same as defined by parameters of "
"this finalizer"
msgstr ""

#: ../../theory/naive-blockchain.rst:705
msgid ""
"**FTT(m) = ceiling(WP \\* total-weight(post-state of m))**, where "
"\\**ceiling(_)*\\* is integer rounding towards positive infinity."
msgstr ""

#: ../../theory/naive-blockchain.rst:707
msgid ""
"Once **LFB(m)**-game reaches finality, the next element of **LFB** chain "
"is established."
msgstr ""

#: ../../theory/naive-blockchain.rst:710
msgid "Indirect finalization"
msgstr ""

#: ../../theory/naive-blockchain.rst:712
msgid ""
"Once **LFB(m)** is established, we consider the whole **p-past-"
"cone(LFB(m))** as finalized."
msgstr ""

#: ../../theory/naive-blockchain.rst:715
msgid "Equivocation catastrophe"
msgstr ""

#: ../../theory/naive-blockchain.rst:717
msgid ""
"For any **LFB(m)**, the **LFB(m)-game** may “crash” by total weight of "
"equivocators exceeding **FTT(m)**. Such situation we call **the "
"equivocation catastrophe**."
msgstr ""

#: ../../theory/naive-blockchain.rst:719
msgid ""
"Discovery of equivocation catastrophe works as follows. -- Whenever a new"
" message **m** is added to a local blockdag, the following handling is "
"done by the finalizer:"
msgstr ""

#: ../../theory/naive-blockchain.rst:721
msgid ""
"If **m.creator** is already included in **equivocators** collection - do "
"nothing."
msgstr ""

#: ../../theory/naive-blockchain.rst:723
msgid ""
"Otherwise - check if m is not introducing a new equivocation. If yes - "
"add **m.creator** to equivocators and:"
msgstr ""

#: ../../theory/naive-blockchain.rst:725
msgid "for every i such that m \\in initial-players(i):"
msgstr ""

#: ../../theory/naive-blockchain.rst:727
msgid "add m to **excluded-players(i)**"
msgstr ""

#: ../../theory/naive-blockchain.rst:729
msgid ""
"using weights map from **LFB(i)** post-state, check if total weight of "
"**excluded-players(i)** exceeds **FTT(i)**"
msgstr ""

#: ../../theory/naive-blockchain.rst:731
msgid ""
"if for some **LFB(i)** exceeding **FTT(i)** case happened - take the "
"smallest such **i** - we will call the block **LFB(i)** **the "
"catastrophic point**"
msgstr ""

#: ../../theory/naive-blockchain.rst:733
msgid ""
"Once an equivocation catastrophe is discovered, the following handling "
"must be applied:"
msgstr ""

#: ../../theory/naive-blockchain.rst:735
msgid ""
"Starting from the catastrophic point, re-calculate the **LFB chain** "
"(initializing initial players accordingly to current contents of "
"**equivocators**)."
msgstr ""

#: ../../theory/naive-blockchain.rst:736
msgid ""
"2. Find the first **i** such that the new LFB-chain differs from old LFB "
"chain at index **i**. Usually such **i** will be bigger than the "
"catastrophic point. 2. Publish a rollback event at the level of external "
"API. 4. Publish re-calculated LFB stream, starting from first difference."
msgstr ""

#: ../../theory/naive-blockchain.rst:741
msgid "External API of a finalizer"
msgstr ""

#: ../../theory/naive-blockchain.rst:743
msgid ""
"The API should be stream-based. The decision on the actual streaming "
"technology to use is beyond the scope of this specification."
msgstr ""

#: ../../theory/naive-blockchain.rst:745
msgid "We only assume that:"
msgstr ""

#: ../../theory/naive-blockchain.rst:747
msgid "external software components may subscribe to the API (to be notified"
msgstr ""

#: ../../theory/naive-blockchain.rst:750
msgid "subscribed observers may unsubscribe"
msgstr ""

#: ../../theory/naive-blockchain.rst:749
msgid "what a subscribed observer receives is a sequence of events"
msgstr ""

#: ../../theory/naive-blockchain.rst:752
msgid "**Events:**"
msgstr ""

#: ../../theory/naive-blockchain.rst:755
msgid "Event type"
msgstr ""

#: ../../theory/naive-blockchain.rst:755
msgid "Contents"
msgstr ""

#: ../../theory/naive-blockchain.rst:755
msgid "Semantics"
msgstr ""

#: ../../theory/naive-blockchain.rst:757
msgid "NEXT_LFB"
msgstr ""

#: ../../theory/naive-blockchain.rst:757
msgid "event idLFB(i).idisequence of indirectly finalized blocks"
msgstr ""

#: ../../theory/naive-blockchain.rst:757
msgid "published as soon as **LFB(i)** is finalized"
msgstr ""

#: ../../theory/naive-blockchain.rst:759
msgid "CATASTROPHY"
msgstr ""

#: ../../theory/naive-blockchain.rst:759
msgid "event idsequence id of catastrophy point"
msgstr ""

#: ../../theory/naive-blockchain.rst:759
msgid "signal that equivocation catastrophe happened"
msgstr ""

#: ../../theory/naive-blockchain.rst:766
msgid "Event"
msgstr ""

#: ../../theory/naive-blockchain.rst:766
msgid "Current snapshot of LFB chain"
msgstr ""

#: ../../theory/naive-blockchain.rst:768
msgid "NEXT_LFB(1, 231, 0, <>)"
msgstr ""

#: ../../theory/naive-blockchain.rst:769
msgid "NEXT_LFB(2, 420, 1, <>)"
msgstr ""

#: ../../theory/naive-blockchain.rst:769
msgid "(231, 420)"
msgstr ""

#: ../../theory/naive-blockchain.rst:770
msgid "NEXT_LFB(3, 801, 2, <524,525>)"
msgstr ""

#: ../../theory/naive-blockchain.rst:770
msgid "(231, 420, 801)"
msgstr ""

#: ../../theory/naive-blockchain.rst:771
msgid "CATASTROPHY(4, 2)"
msgstr ""

#: ../../theory/naive-blockchain.rst:772
msgid "NEXT_LFB(5, 421, 1, <105, 116, 228>)"
msgstr ""

#: ../../theory/naive-blockchain.rst:772
msgid "(231, 421)"
msgstr ""

#: ../../theory/naive-blockchain.rst:773
msgid "NEXT_LFB(6, 480, 2, <>)"
msgstr ""

#: ../../theory/naive-blockchain.rst:773
msgid "(231, 421, 480)"
msgstr ""

