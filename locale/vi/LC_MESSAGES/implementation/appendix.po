# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, CasperLabs LLC
# This file is distributed under the same license as the CasperLabs Tech
# Spec package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
# 
# Translators:
# Quang Huy Tran <tqhuy2018@gmail.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CasperLabs Tech Spec\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-26 20:13+0000\n"
"PO-Revision-Date: 2021-06-26 21:48+0000\n"
"Last-Translator: Quang Huy Tran <tqhuy2018@gmail.com>, 2021\n"
"Language-Team: Vietnamese (https://www.transifex.com/caspernetwork/teams/122124/vi/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Language: vi\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../implementation/appendix.rst:4
msgid "Appendix"
msgstr "Phụ lục"

#: ../../implementation/appendix.rst:9
msgid "A - Casper Rust Library"
msgstr "A - Thư viện Casper Rust"

#: ../../implementation/appendix.rst:11
msgid ""
"Casper provides low-level bindings for host-side (“external”) functions for "
"developers creating smart contracts in other programming languages. "
"Developers can import these functions into a wasm module used as a contract "
"on the Casper Network. Thus, the contract will have access to features "
"specific to the Casper platform which are not supported by general wasm "
"instructions (e.g., accessing the global state, creating new ``URef``\\ s). "
"These are defined and automatically imported if the `Casper Rust library "
"<https://crates.io/crates/casper-contract>`__ is used to develop the "
"contract. For an up-to-date description of exported functions, please visit "
"the `casper-contract <https://docs.rs/casper-"
"contract/latest/casper_contract/ext_ffi/index.html>`__ crate documentation."
msgstr ""
"Casper cung cấp ít các ràng buộc với các chức năng phía máy chủ (“bên "
"ngoài”) cho các nhà phát triển tạo hợp đồng thông minh trong các ngôn ngữ "
"lập trình khác nhau. Các nhà phát triển có thể nhập các chức năng này vào "
"một mô-đun wasm được sử dụng như một hợp đồng trên Mạng Casper. Do đó, hợp "
"đồng sẽ có quyền truy cập vào các tính năng dành riêng cho nền tảng Casper, "
"trong khi các hướng dẫn chung của wasm không hỗ trợ  (ví dụ: truy cập trạng "
"thái toàn cục, tạo mới ```URef``\\). Chúng được xác định và tự động kết nhập"
" nếu thư viện `Casper Rust <https://crates.io/crates/casper-contract>`__ "
"được sử dụng để phát triển hợp đồng. Để có mô tả cập nhật về các hàm đã có, "
"vui lòng truy cập tài liệu `casper-contract <https://docs.rs/casper-"
"contract/latest/casper_contract/ext_ffi/index.html>`__."

#: ../../implementation/appendix.rst:16
msgid "B - Serialization Format"
msgstr "B - Định dạng tuần tự"

#: ../../implementation/appendix.rst:18
msgid ""
"The Casper serialization format is used to transfer data between wasm and "
"the Casper host runtime. It is also used to persist global-state data in the"
" Merkle trie. The definition of this format is described in the :ref:`global"
" state <global-state-head>` section."
msgstr ""
"Định dạng tuần tự của Casper được sử dụng để truyền dữ liệu giữa wasm và "
"thời điểm chạy máy chủ Casper. Nó cũng được sử dụng để duy trì dữ liệu trạng"
" thái toàn cục trong Merkle trie. Định nghĩa của định dạng này được mô tả "
"trong phần :ref: `trạng thái toán cục <global-state-head>`."

#: ../../implementation/appendix.rst:20
msgid ""
"A Rust reference implementation for those implementing this specification in"
" another programming language can be found here:"
msgstr ""
"Bạn có thể tìm thấy triển khai tham chiếu Rust cho những người triển khai "
"đặc tả này bằng ngôn ngữ lập trình khác tại đây:"

#: ../../implementation/appendix.rst:22
msgid ""
"`bytesrepr <https://docs.rs/casper-"
"types/latest/casper_types/bytesrepr/index.html>`_"
msgstr ""
"`bytesrepr <https://docs.rs/casper-"
"types/latest/casper_types/bytesrepr/index.html>`_"

#: ../../implementation/appendix.rst:23
msgid ""
"`cl_value.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/cl_value.rs.html>`_"
msgstr ""
"`cl_value.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/cl_value.rs.html>`_"

#: ../../implementation/appendix.rst:24
msgid ""
"`account <https://docs.rs/casper-"
"types/latest/casper_types/account/index.html>`_"
msgstr ""
"`account <https://docs.rs/casper-"
"types/latest/casper_types/account/index.html>`_"

#: ../../implementation/appendix.rst:25
msgid ""
"`contract <https://docs.rs/casper-"
"types/latest/casper_types/contracts/struct.Contract.html>`_"
msgstr ""
"`contract <https://docs.rs/casper-"
"types/latest/casper_types/contracts/struct.Contract.html>`_"

#: ../../implementation/appendix.rst:26
msgid ""
"`uint.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/uint.rs.html>`_"
msgstr ""
"`uint.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/uint.rs.html>`_"

#: ../../implementation/appendix.rst:28
msgid ""
"Additionally, examples of all data types and their serializations are found "
"in the `GitHub code base <https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L26>`_."
" These examples include a set of useful `serialization tests "
"<https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L1189>`_."
msgstr ""
"Ngoài ra, các ví dụ về tất cả các kiểu dữ liệu và tuần tự hóa của chúng được"
" tìm thấy trong `GitHub code base <https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L26>`_."
" Những ví dụ này bao gồm một tập hợp các `bài kiểm thử tuần tự hóa "
"<https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L1189>`_."

#: ../../implementation/appendix.rst:35
msgid "C - Parallel Execution"
msgstr "C - Thực thi song song"

#: ../../implementation/appendix.rst:38
msgid "Introduction"
msgstr "Giới thiệu"

#: ../../implementation/appendix.rst:40
msgid ""
"The state of the Casper Network is represented by the :ref:`global state "
"<global-state-head>`. The evolution of this state is captured by the "
"blockchain itself, and eventually agreed upon by all nodes in the network "
"via the consensus mechanism. In this section we are concerned with only a "
"single step of that evolution. We think of such a step as performing some "
"\"computation\" that changes the global state. A :ref:`deploy <execution-"
"semantics-deploys>` is a user request for computation, and contains two "
"atomic units of computation: the payment code and the session code (the "
"details of which are discussed elsewhere). For the purpose of this section, "
"we think of each of these units as a (mathematical) function which takes the"
" current global state as input, perhaps along with some other arguments, and"
" produces a new global state as output. However, since the overall global "
"state is ambient from the perspective of the session/payment code itself, "
"the global state is not an explicit parameter in any user's source code, nor"
" is there any explicit return value."
msgstr ""
"Trạng thái của Mạng Casper được biểu thị bằng: ref: `trạng thái toàn cục "
"<global-state-head>`. Sự phát triển của trạng thái này được chính chuỗi khối"
" nắm bắt và cuối cùng được tất cả các nút trong mạng đồng thuận thông qua cơ"
" chế đồng thuận. Trong phần này, chúng tôi chỉ quan tâm đến một bước duy "
"nhất của quá trình phát triển đó. Chúng tôi coi  một bước như thực hiện một "
"số \"tính toán\" làm thay đổi trạng thái toàn cục. :ref: `Triển khai "
"<execution-semantics-deploys>` là một yêu cầu tính toán của người dùng và "
"chứa hai đơn vị tính toán nguyên tử: mã thanh toán và mã phiên (chi tiết về "
"chúng sẽ được thảo luận ở phần khác). Với mục đích của phần này, chúng tôi "
"coi mỗi đơn vị này là một hàm (toán học) lấy trạng thái toàn cục hiện tại "
"làm đầu vào, có thể cùng với một số đối số khác, và tạo ra một trạng thái "
"toàn cục mới làm đầu ra. Tuy nhiên, vì trạng thái toàn cục tổng thể là môi "
"trường xung quanh theo quan điểm của chính mã phiên / thanh toán, trạng thái"
" toàn cục không phải là một tham số rõ ràng trong bất kỳ mã nguồn nào của "
"người dùng và cũng không có bất kỳ giá trị trả lại rõ ràng nào."

#: ../../implementation/appendix.rst:55
msgid ""
"In this section we refine this idea of computation modeled as functions, and"
" describe how it is used to enable parallel execution."
msgstr ""
"Trong phần này, chúng tôi tinh chỉnh ý tưởng tính toán được mô hình hóa dưới"
" dạng các hàm và mô tả cách nó được sử dụng để cho phép thực thi song song."

#: ../../implementation/appendix.rst:61
msgid "Computation as functions on the global state"
msgstr "Tính toán dưới dạng các hàm trong trạng thái toàn cục"

#: ../../implementation/appendix.rst:63
msgid ""
"As discussed in the introduction, we think of computation on the Casper "
"platform as being functions from the global state, :math:`G`, to itself. "
"Naturally, we can compose two such functions, to obtain another function. "
"This corresponds to sequential execution. For example, you can think of the "
"sequence ``payment_code -> session_code`` as being the composition of two "
"individual functions, capturing the effects of the payment and session "
"codes, respectively. If there are smart contracts which are called during "
"those execution phases, you could even break these down further into a "
"sequence of those calls: ``deployed_payment_wasm -> contract_a -> contract_b"
" -> stored_session_code -> contract_c -> ...``. For notational purposes, we "
"will call the set of functions :math:`\\left\\{ f \\ \\vert \\ f: G "
"\\rightarrow G \\right\\} = End(G)`, meaning \"endomorphisms of :math:`G`.\""
msgstr ""
"Như đã thảo luận trong phần giới thiệu, chúng tôi coi tính toán trên nền "
"tảng Casper như là các hàm từ trạng thái toàn cục,: math:`G`. Đương nhiên, "
"chúng ta có thể soạn hai hàm như vậy, để có được một hàm khác. Điều này "
"tương ứng với thực hiện tuần tự. Ví dụ: bạn có thể coi chuỗi ``Payment_code "
"-> session_code`` là thành phần của hai hàm riêng lẻ, ghi lại ảnh hưởng của "
"mã thanh toán và mã phiên tương ứng. Nếu có các hợp đồng thông minh được gọi"
" trong các giai đoạn thực thi đó, bạn thậm chí có thể chia nhỏ các hợp đồng "
"này thành chuỗi các lệnh gọi đó:``deployed_payment_wasm -> contract_a -> "
"contract_b -> stored_session_code -> contract_c -> ...`'. Đối với mục đích "
"ký hiệu, chúng tôi sẽ gọi tập hợp các hàm :math:`\\left\\{ f \\ \\vert \\ f:"
" G \\rightarrow G \\right\\} = End(G)`, có nghĩa là \"endomorphisms của "
":math:`G`.\""

#: ../../implementation/appendix.rst:74
msgid ""
"While this simple model captures sequential execution, it does not model "
"parallel execution. Parallel execution is important because it can enable "
"the execution engine to run more than one deploy at the same time, possibly "
"improving block processing times. Note: each deploy itself is still single-"
"threaded; we will not support parallel execution within a single contract or"
" deploy. This optimization is purely for the performance of the node "
"implementation, not contract developers."
msgstr ""
"Mặc dù mô hình đơn giản này nắm bắt được thực thi tuần tự, nhưng nó không mô"
" hình hóa thực thi song song. Thực thi song song rất quan trọng vì nó có thể"
" cho phép công cụ thực thi chạy nhiều triển khai cùng một lúc, có thể cải "
"thiện thời gian xử lý khối. Lưu ý: bản thân mỗi triển khai vẫn là một luồng;"
" chúng tôi sẽ không hỗ trợ thực hiện song song trong một hợp đồng hoặc triển"
" khai. Việc tối ưu hóa này hoàn toàn là cho hiệu suất của việc triển khai "
"nút, không phải cho nhà phát triển hợp đồng."

#: ../../implementation/appendix.rst:83
msgid "Computation as functions from :math:`G` to :math:`End(G)`"
msgstr "Tính toán dưới dạng các hàm từ :math:`G` đến :math:`End(G)`"

#: ../../implementation/appendix.rst:85
msgid ""
"The problem with functions on the global state itself is they mutate the "
"state, potentially causing problems if we wanted to apply two such functions"
" at the same time. Therefore, we will instead think of computations as "
"outputting a description of the changes to the global state that they would "
"make if given the chance. Or phrased another way, the execution of a deploy "
"will return a function that could be applied to the global state to obtain "
"the post-state we would have obtained from running the computation while "
"mutating the global state. The reason this helps is because we can apply "
"multiple such functions to the same global state at the same time; they are "
"pure functions that do not modify the global state. Thus we can execute "
"multiple deploys in parallel and later combine their outputs (more on this "
"later)."
msgstr ""
"Vấn đề với các hàm trên trạng thái toàn cục là chúng thay đổi trạng thái, có"
" khả năng gây ra vấn đề nếu chúng ta muốn áp dụng hai hàm như vậy cùng một "
"lúc. Do đó, chúng ta coi các tính toán như là việc xuất ra một mô tả về "
"những thay đổi đối với trạng thái toàn cục mà chúng sẽ thực hiện nếu có cơ "
"hội. Hoặc theo cách khác, việc thực thi triển khai sẽ trả về một hàm có thể "
"được áp dụng cho trạng thái toàn cục để có được trạng thái hậu toàn cục mà "
"chúng ta sẽ có được từ việc chạy tính toán trong khi thay đổi trạng thái "
"toàn cục. Lý do điều này hữu ích là vì chúng ta có thể áp dụng nhiều hàm như"
" vậy cho cùng một trạng thái toàn cục cùng một lúc; chúng là những hàm thuần"
" túy không sửa đổi trạng thái toàn cục. Do đó, chúng ta có thể thực hiện "
"nhiều triển khai song song và sau đó kết hợp các đầu ra của chúng (sẽ nói "
"thêm về điều này sau)."

#: ../../implementation/appendix.rst:103
msgid ""
"The way this is modeled in the Casper execution engine is via the "
"|TrackingCopy|_. Executing deploys (and the contracts they call) read/write "
"from the |TrackingCopy|_ instead of the global state directly. The "
"|TrackingCopy|_ *tracks* the operations and returns the |Transforms|_ which "
"act on each key in the global state effected by the execution. Using the "
"nomenclature from the theory, this collection of keys and transforms "
"describes a function :math:`f: G \\rightarrow G` which is an endomorphism on"
" :math:`G`, i.e. an element of :math:`End(G)`."
msgstr ""
"Các điều này được mô hình hóa trong công cụ thực thi Casper thông qua "
"|TrackingCopy|_. Thực thi triển khai (và các hợp đồng mà chúng gọi) đọc/ghi "
"từ |TrackingCopy|_ thay vì trạng thái toàn cục một cách trực tiếp. "
"|TrackingCopy|_ *theo dõi* các hoạt động và trả về |Transforms|_ hoạt động "
"trên mỗi khóa trong trạng thái toàn cục bị ảnh hưởng bởi việc thực thi đó. "
"Tập hợp các khóa và các biến đổi này mô tả hàm: math: :math:`f: G "
"\\rightarrow G` là một endomorphism trên: math:`G`, tức là một phần tử của: "
"math:`End (G)`. "

#: ../../implementation/appendix.rst:113
msgid ""
"An important note about the returned |Transforms|_ is there is exactly one "
"``Transform`` per key that was used during the execution. Initially, this "
"may be unintuitive because a contract can use the same key multiple times, "
"however, because each deploy executes sequentially, we can use the "
"composition property discussed in the previous section to combine multiple "
"sequential operations into a single operation. Consider the following "
"example."
msgstr ""
"Một lưu ý quan trọng về |Transforms| _ được trả về là có chính xác một "
"``Transform`` cho mỗi khóa được sử dụng trong quá trình thực thi. Ban đầu, "
"điều này có thể không trực quan vì một hợp đồng có thể sử dụng cùng một khóa"
" nhiều lần, tuy nhiên, vì mỗi triển khai thực thi tuần tự, chúng ta có thể "
"sử dụng thuộc tính tổng hợp được thảo luận trong phần trước để kết hợp nhiều"
" hoạt động tuần tự thành một hoạt động duy nhất. Hãy xem xét ví dụ sau."

#: ../../implementation/appendix.rst:130
msgid ""
"The above function reads a local variable, performs a computation which "
"depends on the current value of that variable, then writes an updated value."
" Suppose we execute this function on a global state where the value of the "
"local key is ``7``. Then the sequence of transforms on the global state "
"would be ``Read -> Write(22)`` since ``n`` would be odd and thus ``f_n`` "
"would be computed using the ``else`` case. From the perspective of state "
"changes, we only need to keep the ``Write(22)`` transform because final "
"state is the same as if we had also included the ``Read`` transform. In "
"fact, by the same reasoning, we know that we only need to keep the last "
"``Write``, whatever it happens to be, since it will be the final value on "
"the key after the computation finishes. Notice that the resulting global "
"state function does not exactly reproduce the original contract execution "
"steps; it is a *reduced trace* where only the final effect on the global "
"state is recorded [#]_. In particular, this means applying the results of "
"these executions is very fast relative to the original execution (this will "
"be importnat for how we use these traces in the next section). Also notice "
"that the transforms which are produced depend on the initial state. This "
"might be obvious since we are modeling compuation as functions :math:`f: G "
"\\rightarrow End(G)`, so this statement is simply that the function really "
"depends on its input. However, this is again an imporant concept to keep in "
"mind when working with this model of computation. Going back to our example,"
" if the value of the local key was ``16`` then the transform produced would "
"be ``Write(8)``, entirely different from the case where the initial value "
"was ``7``."
msgstr ""
"Hàm trên đọc một biến cục bộ, thực hiện một phép tính phụ thuộc vào giá trị "
"hiện tại của biến đó, sau đó ghi một giá trị cập nhật. Giả sử chúng ta thực "
"thi hàm này trên trạng thái toàn cục nơi giá trị của khóa cục bộ là ``7``. "
"Sau đó, chuỗi các biến đổi trên trạng thái toàn cục sẽ là  ``Read -> "
"Write(22)`` vì ``n`` sẽ là số lẻ và do đó `` `f_n`` sẽ được tính bằng cách "
"sử dụng trường hợp khá là``else``. Từ quan điểm của các thay đổi trạng thái,"
" chúng ta chỉ cần giữ biến đổi  ``Write(22)`` vì trạng thái cuối cùng giữ "
"nguyên khi chúng ta đã bao gồm biến đổi ``Read``. Trên thực tế, bằng cách "
"lập luận tương tự, chúng ta biết rằng chúng ta chỉ cần giữ chữ ````Write`` "
"cuối cùng, bất kể điều gì xảy ra, vì nó sẽ là giá trị cuối cùng trên khóa "
"sau khi tính toán kết thúc. Lưu ý rằng hàm trạng thái toàn cục kết quả không"
" tái tạo chính xác các bước thực hiện hợp đồng ban đầu; mà chỉ là các dấu "
"vết có tác động cuối cùng lên trạng thái toàn cục được ghi lại [#] _. Đặc "
"biệt, điều này có nghĩa là việc áp dụng các kết quả của các lần thực thi này"
" rất nhanh so với lần thực thi ban đầu (đây sẽ là bài viết về cách chúng ta "
"sử dụng các dấu vết này trong phần tiếp theo). Cũng lưu ý rằng các phép biến"
" đổi được tạo ra phụ thuộc vào trạng thái ban đầu. Điều này có thể rõ ràng "
"vì chúng ta đang lập mô hình tính toán dưới dạng các hàm :math:`f: G "
"\\rightarrow End(G)`, vì vậy câu lệnh này chỉ đơn giản là hàm thực sự phụ "
"thuộc vào đầu vào của nó. Tuy nhiên, đây lại là một khái niệm không cần "
"thiết phải ghi nhớ khi làm việc với mô hình tính toán này. Quay lại với ví "
"dụ của chúng ta, nếu giá trị của khóa cục bộ là ``16`` thì biến đổi được tạo"
" ra sẽ là `` `Write(8)``, hoàn toàn khác với trường hợp giá trị ban đầu là "
"``7``."

#: ../../implementation/appendix.rst:155
msgid ""
"There is a special case of constructing reduced traces which is worth "
"calling out explicitly. Suppose the initial value of a key in the global "
"state is ``X``, and after performing the execution, the transform for that "
"key is ``Write(X)``. Then it is valid to replace that transform with "
"``Read``. This is because the computation acts like the identity function "
"(i.e. the function which makes no changes) at this key, and therefore is "
"equal to ``Read``. Notably we cannot simply remove the transfrom from the "
"map because the key was still used in some way during the computation. We "
"must have a record of what keys were used to correctly detect when deploys "
"commute (see the following sections for more details). Replacing a ``Write``"
" with a ``Read`` still has great benefits for parallel exectuion because "
"reads do commute with one another, while writes do not. This optimization in"
" the reduced traces is `applied in our reference implementation "
"<https://github.com/CasperLabs/casper-"
"node/blob/master/execution_engine/src/core/engine_state/execution_result.rs#L439>`__."
msgstr ""
"Có một trường hợp đặc biệt của việc xây dựng các dấu vết giảm dần đáng thảo "
"luận một cách rõ ràng. Giả sử giá trị ban đầu của một khóa ở trạng thái toàn"
" cục là ``X`` và sau khi thực hiện việc thực thi, phép biến đổi cho khóa đó "
"là ``Write(X)``. Sau đó, nó hợp lệ để thay thế biến đổi đó bằng ``Read``. "
"Đó là do o tính toán hoạt động giống như hàm nhận dạng (tức là hàm không tạo"
" ra thay đổi) tại khóa này, và do đó nó bằng với `Read``. Đáng chú ý là "
"chúng ta không thể đơn giản xóa chuyển đổi khỏi bản đồ vì khóa vẫn được sử "
"dụng theo một cách nào đó trong quá trình tính toán. Chúng tôi phải có hồ sơ"
" về những khoá nào đã được sử dụng để phát hiện chính xác khi triển khai lộ "
"trình hoán đổi. (xem các phần sau để biết thêm chi tiết). Thay thế ``Write``"
" bằng ``Read`` vẫn mang lại lợi ích lớn cho hoạt động song song vì các lần "
"đọc đi lại với nhau, trong khi các lần ghi thì không. Tối ưu hóa theo dấu "
"vết giảm dần này được `áp dụng trong triển khai tham chiếu "
"<https://github.com/CasperLabs/casper-"
"node/blob/master/execution_engine/src/core/engine_state/execution_result.rs#L439>`__."

#: ../../implementation/appendix.rst:172
msgid "Constructing the post-state from parallel execution"
msgstr "Xây dựng trạng thái hậu toàn cục từ thực thi song song"

#: ../../implementation/appendix.rst:174
msgid ""
"Following from the previous section, we know that deploys execute to produce"
" a ``Map<Key, Transform>`` which gives a summary (i.e. \"reduced trace\") of"
" the effects the deploy would have had on each key in the global state (keys"
" not present in the map are not effected). In the reference implementation "
"we call this the ``exec`` phase. Since creating these maps does not mutate "
"the global state, we can run as many of these as we want in parallel. "
"However, after they have been run we need to actually produce a post-state, "
"the new global state after applying the effects of the deploys (this will "
"then be used as the pre-states for deploys in the following batch of "
"executions). In the reference implementation, we call applying the "
"collection of transforms to obtain a post-state the ``commit`` phase."
msgstr ""
"Tiếp theo từ phần trước, chúng ta biết rằng triển khai thực thi để tạo ra "
"một ``Map<Key, Transform>`` cung cấp một bản tóm tắt (tức là \"dấu vết giảm "
"dần\") về các tác động mà triển khai sẽ có trên mỗi khóa trong trạng thái "
"toàn cục (các khoá không có trong bản đồ sẽ không có hiệu lực). Trong phần "
"triển khai tham chiếu, chúng ta gọi đây là giai đoạn thực thi (``exec`` "
"phase). Vì việc tạo các bản đồ này không làm thay đổi trạng thái toàn cục, "
"chúng ta có thể chạy song song bao nhiêu bản đồ này tùy thích. Tuy nhiên, "
"sau khi chúng được chạy, chúng ta cần thực sự tạo ra một trạng thái hậu toàn"
" cục, trạng thái toàn cục mới sau khi áp dụng các hiệu ứng của các đợt triển"
" khai (sau đó điều này sẽ được sử dụng làm trạng thái trước cho các đợt "
"triển khai sau). Trong triển khai tham chiếu, chúng tôi gọi việc áp dụng tập"
" hợp các biến đổi để có được trạng thái hậu là giai đoạn cam kết "
"(```commit`` phase)."

#: ../../implementation/appendix.rst:186
msgid ""
"Before we can construct the post-state, we must know that one is well-"
"defined. When working with parallel execution with a shared resource, you "
"may encounter \"race conditions\". This is a situation where the outcome of "
"a parallel computation depends on the order or timing of events, in "
"particular when this timing is not explicitly controlled. Or phrased another"
" way, parallelism with a shared resource is a lie and one of the processes "
"will use the resource first, followed by the other one. A classic blockchain"
" example of a race condition is a double spend (which under an accounts "
"model, as opposed to UTXO, is the same as an overdraft on the account); one "
"payer attempts to pay two payees at the same time without enough tokens to "
"actually pay both. One payee or the other is not getting their tokens, "
"depending on the order the transactions are processed."
msgstr ""
"Trước khi có thể xây dựng trạng thái hậu toàn cục, chúng ta cần biết rằng "
"một trạng thái đã được xác định rõ. Khi làm việc với thực thi song song với "
"một tài nguyên được chia sẻ, bạn có thể gặp phải \"các tình huống chạy "
"đua\". Đây là tình huống mà kết quả của một phép tính song song phụ thuộc "
"vào thứ tự hoặc thời gian của các sự kiện, đặc biệt khi thời gian này không "
"được kiểm soát rõ ràng. Hay diễn đạt một cách khác, song song với một tài "
"nguyên được chia sẻ là một trong các quy trình sẽ sử dụng tài nguyên trước, "
"sau đó là tiến trình kia. Một ví dụ chuỗi khối cổ điển về tình huống chạy "
"đua là chi tiêu gấp đôi (trong mô hình tài khoản, trái ngược với UTXO, giống"
" như thấu chi trên tài khoản); một người thanh toán cố gắng thanh toán cho "
"hai người được thanh toán cùng một lúc mà không có đủ token để thực sự thanh"
" toán cho cả hai. Một người nhận thanh toán hoặc người kia không nhận được "
"token của họ, tùy thuộc vào thứ tự các giao dịch được xử lý."

#: ../../implementation/appendix.rst:200
msgid ""
"In our simple model of computation where deploys are functions on the global"
" state, this would correspond to functions that do not *commute*, that is to"
" say, the order in which we apply the functions to the global state matters:"
" :math:`f \\circ g \\not= g \\circ f`. Therefore, in order to prevent race "
"conditions, we will only allow deploys to execute in parallel if they "
"commute. Taking our more sophisticated model of computation, we have two "
"deploys: :math:`f: G \\rightarrow End(G)` and :math:`g: G \\rightarrow "
"End(G)`, and we will only allow both be committed to the same pre-state "
":math:`G` if :math:`f(G) \\circ g(G) = g(G) \\circ f(G)`, i.e. the resulting"
" maps of transforms commute."
msgstr ""
"Trong mô hình tính toán đơn giản của chúng ta, nơi triển khai là các hàm "
"trên trạng thái toàn cục, điều này sẽ tương ứng với các hàm không *hoán "
"đổi*, nghĩa là thứ tự mà chúng ta áp dụng các hàm cho trạng thái toàn cục "
"là: :math:`f \\circ g \\not= g \\circ f`. Do đó, để ngăn chặn các tình huống"
" chạy đua, chúng ta sẽ chỉ cho phép triển khai thực hiện song song nếu họ "
"giao hoán. Lấy mô hình tính toán phức tạp hơn, chúng ta có hai triển khai: "
":math:`f: G \\rightarrow End(G)` và :math:`g: G \\rightarrow End(G)`, chúng "
"ta sẽ chỉ cho phép cả hai triển khai này cam kết với cùng một trạng thái "
"trước :math:`G` if :math:`f(G) \\circ g(G) = g(G) \\circ f(G)`, tức là bản "
"đồ kết quả của các phép biến đổi hoán đổi với nhau."

#: ../../implementation/appendix.rst:212
msgid ""
"We will discuss how to compute whether two maps of transforms commute in the"
" next section. For now, we assume that run some set of deploys :math:`d_1, "
"d_2, d_3, \\ldots` in parallel against a fixed pre-state :math:`G` to obtain"
" a set of transform maps :math:`T_1, T_2, T_3, \\ldots`, then select only "
"the transforms that commute :math:`T_i, T_j, T_k, \\ldots` to apply to "
":math:`G`, and thus obtain the post-state :math:`G^\\prime`. The remaining "
"deploys we can all run in parallel against :math:`G^\\prime`, again choosing"
" the commuting ones to commit, obtaining :math:`G^{\\prime\\prime}`, and so "
"on. This final post-state is the same as if we had run all the deploys "
":math:`d_1, d_2, d_3, \\ldots` in sequence against :math:`G`, but perhaps "
"faster (depending on how many could commute [#]_) because we were able to "
"run in parallel batches."
msgstr ""
"Chúng ta sẽ thảo luận về cách tính toán liệu hai bản đồ của phép biến đổi "
"giao hoán được hay không trong phần tiếp theo. Hiện tại, chúng ta giả định "
"rằng chạy một số nhóm triển khai :math:`d_1, d_2, d_3,\\ldots` song song với"
" một trạng thái tiền cục định trước :math:`G` để có được một tập các bản đồ "
"biến đổi :math:`T_1, T_2, T_3, \\ldots`, sau đó chỉ chọn các phép biến đổi "
"đi kèm:math:`T_i, T_j, T_k, \\ldots` để áp dụng cho :math:`G`, và do đó có "
"được trạng thái sau :math:`G^\\prime`. Các triển khai còn lại, tất cả chúng "
"ta có thể chạy song song với: math :math:`G^\\prime`, sau đó tiếp tục chọn "
"các biến đổi có giao hoán để cam kết và thu được :math:`G^{\\prime\\prime}`,"
" v.v. Trạng thái cuối cùng này giống như thể chúng ta đã chạy tất cả các "
"triển khai :math:`d_1, d_2, d_3, \\ldots` theo trình tự :math:`G`, nhưng "
"nhanh hơn (tùy thuộc vào số lượng có thể hoán đổi [ #] _) vì khi hoán đổi, "
"chúng ta có thể chạy song song với nhau."

#: ../../implementation/appendix.rst:226
msgid ""
"Recall that committing transforms is a very fast operation relative to "
"execution, so it causes little overhead. The main overhead would come from "
"executing the same deploy against multiple different starting states because"
" it failed to commute multiple times. This can be mitigated by favoring "
"including more expensive deploys in each committed batch."
msgstr ""
"Cần nhớ rằng việc cam kết thực hiện các phép chuyển đổi là một hoạt động rất"
" nhanh so với việc thực thi, vì vậy nó gây ra rất ít chi phí. Chi phí chính "
"sẽ đến từ việc thực hiện cùng một triển khai với nhiều trạng thái bắt đầu "
"khác nhau vì nó không hoán đổi nhiều lần. Điều này có thể được giảm thiểu "
"bằng cách ưu tiên đưa vào các đợt triển khai tốn kém hơn trong mỗi đợt triển"
" khai được cam kết."

#: ../../implementation/appendix.rst:234
msgid "Detecting when maps of transforms commute"
msgstr "Phát hiện khi bản đồ của các biến đổi thực hiện hoán đổi"

#: ../../implementation/appendix.rst:236
msgid ""
"Two transform maps ``m_1: Map<Key, Transform>`` and ``m_2: "
"Map<Key,Transform>`` commute if for all keys ``k`` which are present in both"
" maps, the transforms ``t_1 = m_1[k]`` and ``t_2 = m_2[k]`` commute. "
"Notably, if there are no such keys then the maps trivially commute. Two "
"transforms ``t_1:Transform`` and ``t_2: Transform`` commute if:"
msgstr ""
"Hai bản đồ biến đổi ``m_1: Map<Key, Transform>`` và ``m_2: "
"Map<Key,Transform>`` hoán đổi nếu tất cả các khoá ``k`` có trong cả hai bản "
"đồ và các biến đổi ```t_1 = m_1[k]`` và ``t_2 = m_2[k]`` hoán đổi. Đáng chú "
"ý, nếu không có các khoá như vậy thì bản đồ sẽ hoán đổi rất dễ dàng. Hai "
"phép biến đổi ``t_1:Transform`` và ``t_2: Transform`` hoán đổi nếu: "

#: ../../implementation/appendix.rst:242
msgid "``t_1 == t_2 == Read``"
msgstr "``t_1 == t_2 == Read``"

#: ../../implementation/appendix.rst:243
msgid ""
"``t_1`` and ``t_2`` are both of the same ``Add*`` transform variant (note "
"they do not need to contain the same values within that variant)"
msgstr ""
"`` t_1`` và ``t_2`` đều thuộc cùng một sự kiện biến đổi ``Add*`` (lưu ý rằng"
" chúng không cần phải chứa các giá trị giống nhau trong sự kiện biến đổi đó)"

#: ../../implementation/appendix.rst:247
msgid ""
"where ``Add*`` is a placeholder representing any of the typed native add "
"operations (``AddInt32``, ``AddInt64``, ``AddInt128``, ``AddInt256``, "
"``AddInt512``, ``AddKeys``).  And they do not commute otherwise. A short "
"montra for this is: reads commute, adds commute, writes conflict. Note that "
"writes *always* conflict, even if they are writing the same value. Consider "
"the following example:"
msgstr ""
"trong đó ``Add*`` là trình giữ chỗ đại diện cho bất kỳ thao tác thêm gốc nào"
" đã nhập (``AddInt32``, ``AddInt64``, ``AddInt128``, ``AddInt256``, "
"``AddInt512``, ``AddKeys``). Và chúng không hoán đổi. Ghi chú để nhớ là: đọc"
" hoán đổi (reads commute), thêm hoán đổi (adds commute), ghi xung đột "
"(writes conflict). Lưu ý rằng Write *luôn luôn* xung đột, ngay cả khi chúng "
"đang ghi cùng một giá trị. Hãy xem xét ví dụ sau:"

#: ../../implementation/appendix.rst:270
msgid ""
"If the pre-state :math:`G` has ``local(\"x\") == 7`` then ``f(G)`` results "
"in the transform ``Write(10)``, and so does ``g(G)``. However, if we compose"
" ``g(f(G))`` then we obtain ``Write(100)``, and if we compose ``f(g(G))`` "
"then the result is ``Write(0)`` and hence the functions do not commute."
msgstr ""
"Nếu trạng thái tiền toàn cục:math:`G` có ``local(\"x\") == 7`` thì ``f(G)`` "
"dẫn đến biến đổi ``Write(10)``, và tương tự ``g(G)``. Tuy nhiên, nếu chúng "
"ta soạn ``g(f(G))`` thì chúng ta nhận được ``Write(100)``, và nếu chúng ta "
"soạn ``f(g(G))``thì kết quả là ``Write(0)``  và do đó các hàm không hoán "
"đổi."

#: ../../implementation/appendix.rst:277
msgid "Handling Errors"
msgstr "Xử lý lỗi"

#: ../../implementation/appendix.rst:279
msgid ""
"The reason we can say \"adds commute\" in our rules is because "
"mathematically addition is commutative. However, this relies on the infinite"
" nature of the number line and real computers are finite. For example, if we"
" considered the addition of three 8-bit numbers: 250, 3, and 5, any two of "
"them can be added and they commute, but attempting to add all three results "
"in an overflow error. Thus the final result depends on the order of "
"addition:"
msgstr ""
"Lý do chúng ta có thể nói \"thêm hoán đổi\" trong các quy tắc của mình là vì"
" phép cộng về mặt toán học có tính chất giao hoán. Tuy nhiên, điều này dựa "
"vào tính chất vô hạn của dãy số và tính hữu hạn của máy tính. Ví dụ: nếu "
"chúng tôi xem xét việc cộng ba số 8-bit: 250, 3 và 5, có thể cộng bất kỳ hai"
" số nào trong số chúng và hoán đổi chúng, nhưng cố gắng cộng cả ba sẽ dẫn "
"đến lỗi tràn. Do đó, kết quả cuối cùng phụ thuộc vào thứ tự của phép cộng:"

#: ../../implementation/appendix.rst:286
msgid "250 + 3 + 5 = 253 (last addition does not happen due to the error)"
msgstr "250 + 3 + 5 = 253 (phép cộng cuối cùng không xảy ra do lỗi) "

#: ../../implementation/appendix.rst:287
msgid "250 + 5 + 3 = 255"
msgstr "250 + 5 + 3 = 255"

#: ../../implementation/appendix.rst:288
msgid "3 + 5 + 250 = 8"
msgstr "3 + 5 + 250 = 8"

#: ../../implementation/appendix.rst:290
msgid ""
"Presently we circumvent this error by actually using modular arithmetic "
"(wrapped addition as it is often called in computer science). Addition in "
"modular arithmetic is still a commutative operation, so our theory holds "
"together. In our example above 250 + 5 + 3 is always equal to 3, no matter "
"what. However in the context of financial applications wrapping back to zero"
" is an unexpected behavior. For this reason we use 512-bit numbers in our "
"mint contract to represent balances, and the total number of token units "
"(motes) available is less than ``U512::MAX``, so overflow is impossible."
msgstr ""
"Hiện tại, chúng tôi đã sửa lỗi này bằng cách sử dụng mô-đun số học (phép "
"cộng quấn quanh wrapped addition như nó thường được gọi trong khoa học máy "
"tính). Phép cộng trong mô-đun số học vẫn là một phép toán giao hoán, vì vậy "
"lý thuyết của chúng tôi phù hợp với nhau. Trong ví dụ trên 250 + 5 + 3 luôn "
"bằng 3, không có vấn đề gì. Tuy nhiên, trong bối cảnh các ứng dụng tài chính"
" trở về 0 là một hành vi không mong muốn. Vì lý do này, chúng ta sử dụng số "
"512-bit trong hợp mint để đại diện cho số dư và tổng số đơn vị token (motes)"
" có sẵn ít hơn ``U512::MAX``, vì vậy không thể xảy ra lỗi tràn."

#: ../../implementation/appendix.rst:299
msgid ""
"That said, this is not the only error which may arise due to the finite "
"nature of computers. For example, the ``AddKeys`` transform is about adding "
"elements to a map, which is a commutative operation as well (so long as none"
" of the keys already existed in the map, then it is more akin to a write "
"operation). Yet, this operation can also fail due to the physical machine "
"being out of memory, thus once again meaning the order of additions could "
"effect the final state of the map."
msgstr ""
"Đây không phải là lỗi duy nhất có thể phát sinh do tính chất hữu hạn của máy"
" tính. Ví dụ, biến đổi ``AddKeys`` là về việc thêm các phần tử vào bản đồ, "
"đây cũng là một thao tác hoán đổi (miễn là không có khóa nào đã tồn tại "
"trong bản đồ, thì nó giống với thao tác ghi hơn). Tuy nhiên, hoạt động này "
"cũng có thể thất bại do máy vật lý hết bộ nhớ, do đó thứ tự thêm có thể ảnh "
"hưởng đến trạng thái cuối cùng của bản đồ."

#: ../../implementation/appendix.rst:307
msgid ""
"In a more powerful theory of parallel execution we could consider operations"
" which fail. In this case we could say that transforms ``t_1`` and ``t_2`` "
"commute if they are of the same addition type and the outcome of applying "
"both to the input global state, :math:`G` is not an error. This is a more "
"complex rule because it requires doing some amount of computation during "
"commutativity checking, whereas the previous theory was simple comparison. "
"Yet, this theory might be worth pursuing because it solves the two problems "
"we have listed here (overflow and out-of-memory), along with other problems "
"that we presently cannot handle at all. For example, ``Minus`` could be "
"introduced as a transform, and underflows could be handled using this "
"refined commutativity rule. This has practical application in our system "
"because it would mean transfers from the same source could commute if enough"
" funds are available, whereas presently they will always be conservatively "
"labeled as not commuting."
msgstr ""
"Trong một lý thuyết mạnh mẽ hơn về thực thi song song, chúng ta có thể xem "
"xét các hoạt động không thành công. Trong trường hợp này, chúng ta có thể "
"nói rằng các biến đổi ``t_1`` và ``t_2`` nếu chúng có cùng kiểu cộng và kết "
"quả của việc áp dụng cả hai cho trạng thái toàn cục đầu vào thì :math:`G` "
"không phải là một lỗi . Đây là một quy tắc phức tạp hơn vì nó yêu cầu thực "
"hiện một số tính toán trong quá trình kiểm tra tính hoán đổi, trong khi lý "
"thuyết trước đây chỉ cần so sánh đơn giản. Tuy nhiên, lý thuyết này có thể "
"đáng theo đuổi vì nó giải quyết được hai vấn đề mà chúng ta đã liệt kê ở đây"
" (tràn và hết bộ nhớ), cùng với các vấn đề khác mà hiện tại chúng ta không "
"thể xử lý được. Ví dụ: Trừ ``Minus`` có thể được giới thiệu dưới dạng một "
"phép biến đổi và các tiến trình theo nó có thể được xử lý bằng cách sử dụng "
"quy tắc hoán đổi tinh chỉnh này. Điều này có ứng dụng thực tế trong hệ thống"
" của chúng ta vì nó có nghĩa là các khoản chuyển tiền từ cùng một nguồn có "
"thể hoán đổi nếu có đủ tiền, trong khi hiện tại chúng sẽ luôn được gắn nhãn "
"là không hoán đổi."
