# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, CasperLabs LLC
# This file is distributed under the same license as the CasperLabs Tech
# Spec package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
# 
# Translators:
# muss abahmane <elmabahma@gmail.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CasperLabs Tech Spec\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-26 20:13+0000\n"
"PO-Revision-Date: 2021-06-26 21:48+0000\n"
"Last-Translator: muss abahmane <elmabahma@gmail.com>, 2021\n"
"Language-Team: French (https://www.transifex.com/caspernetwork/teams/122124/fr/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Language: fr\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../theory/highway.rst:2
msgid "Highway"
msgstr "Highway"

#: ../../theory/highway.rst:5
msgid "Motivation"
msgstr "Motivation"

#: ../../theory/highway.rst:7
msgid ""
"For a practically useful decentralized consensus protocol, proofs of two "
"theorems must be provided:"
msgstr ""
"Pour qu'un protocole de consensus décentralisé soit utile en pratique, les "
"preuves de deux théorèmes doivent être fournies :"

#: ../../theory/highway.rst:10
msgid ""
"**safety:** a theorem saying that nodes cannot come up with conflicting "
"decisions"
msgstr ""
"**sécurité:** (safety) un théorème disant que les nœuds ne peuvent pas "
"prendre de décisions contradictoires."

#: ../../theory/highway.rst:11
msgid "**liveness:** a theorem saying that nodes will keep making decisions"
msgstr ""
"**liveness:** un théorème disant que les noeuds vont continuer à prendre des"
" décisions"

#: ../../theory/highway.rst:12
msgid "forever (so, that the blockchain will grow forever)"
msgstr "pour toujours (afin que la blockchain s'étende pour toujours)"

#: ../../theory/highway.rst:14
msgid ""
"The First theorem is just another name for the machinery of finality "
"detectors. And it is the easy one. The Second theorem tends to be "
"substantially harder to prove and these difficulties are showing up in "
"pretty much any blockchain design studied."
msgstr ""
"Le premier théorème est juste un autre nom pour la machinerie des détecteurs"
" de finalité. Et c'est le plus facile. Le deuxième théorème tend à être "
"sensiblement plus difficile à prouver et ces difficultés apparaissent dans "
"presque toutes les conceptions de blockchain étudiées."

#: ../../theory/highway.rst:19
msgid ""
"Despite the fact that the “naive” design of a blockchain described in the "
"previous chapter can actually be implemented and its observed behavior is "
"promising, so far we were not successful trying to prove the liveness "
"theorem for it."
msgstr ""
"Bien que la conception \"naïve\" d'une blockchain décrite dans le chapitre "
"précédent puisse être mise en œuvre et que son comportement observé soit "
"prometteur, nous n'avons, jusqu'à présent, pas réussi à prouver le théorème "
"de vivacité (liveness) pour elle."

#: ../../theory/highway.rst:23
msgid ""
"As part of this effort, we were actively looking for some hardening of "
"assumptions that would lead to a provably live protocol while maintaining "
"our key goals intact; i.e. to have a permissionless, fully decentralized, "
"Casper-based blockchain that is compatible with broadcast-based message "
"passing and a partially synchronous network."
msgstr ""
"Dans le cadre de cet effort, nous recherchions activement un durcissement "
"des hypothèses qui permettrait d'obtenir un protocole prouvé vivant tout en "
"maintenant nos objectifs clés intacts, c'est-à-dire une blockchain sans "
"permission, entièrement décentralisée, basée sur Casper et compatible avec "
"le passage de messages par diffusion et un réseau partiellement synchrone."

#: ../../theory/highway.rst:29
msgid ""
"**Highway** is one of such attempts we found particularly promising. This is"
" a variant of Casper where the liveness theorem is achieved via constraining"
" message production with a pseudorandomly generated sequence of leaders "
"that, in effect leads to a predictable structure of the emerging blockdag."
msgstr ""
"**Highway** est l'une de ces tentatives que nous avons trouvée "
"particulièrement prometteuse. Il s'agit d'une variante de Casper où le "
"théorème de vivacité (liveness) est réalisé en contraignant la production de"
" messages avec une séquence de leaders générée de manière pseudo-aléatoire "
"qui, en fait, conduit à une structure prévisible du blockdag émergent."

#: ../../theory/highway.rst:35
msgid "Innovations in a nutshell"
msgstr "Les innovations en bref"

#: ../../theory/highway.rst:37
msgid ""
"We generally see Highway as an evolution from Naive Casper Blockchain (later"
" abbreviated as NCB),  where key modifications are:"
msgstr ""
"Nous considérons généralement Highway comme une évolution de Naive Casper "
"Blockchain (plus tard abrégé en NCB), où les modifications clés sont :"

#: ../../theory/highway.rst:40
msgid "Organize blocks creation around a pseudorandomly generated sequence of"
msgstr ""
"Organiser la création de blocs autour d'une séquence générée de manière "
"pseudo-aléatoire de"

#: ../../theory/highway.rst:41
msgid ""
"leaders. Only a leader can produce a block. -  Use variable length of rounds"
" based on the :math:`2^n` round length idea so that the blockchain network "
"can self-adjust to achieve optimal performance. -  Replace continuous "
"bonding/unbonding with an era-based solution. This is necessary to keep the "
"solution secure (so that attackers cannot tamper with the leader sequence "
"generator)."
msgstr ""
"leaders. Seul un leader peut produire un bloc. - Utiliser une longueur "
"variable des tours (round) basée sur :math:`2^n` afin que le réseau "
"blockchain puisse s'auto-ajuster pour atteindre une performance optimale. - "
"Remplacer le bonding/unbonding continu par une solution basée sur l'ère. "
"Cela est nécessaire pour que la solution reste sécurisée (afin que les "
"attaquants ne puissent pas altérer le générateur de séquence leader)."

#: ../../theory/highway.rst:49
msgid "New requirements"
msgstr "Nouvelles exigences"

#: ../../theory/highway.rst:51
msgid ""
"Interestingly, in comparison to NCB, we need only one new assumption, "
"although a tough one - we need that validators have well synchronized real "
"time clocks."
msgstr ""
"Il est intéressant de noter que, par rapport à la BCN, nous n'avons besoin "
"que d'une seule nouvelle hypothèse, bien qu'elle soit difficile : il faut "
"que les validateurs aient des horloges bien synchronisées en temps réel ."

#: ../../theory/highway.rst:54
msgid ""
"How to achieve such real-time clocks and how to secure the network against "
"intended or unintended clock drift is, in general, beyond the scope of this "
"specification. However, we give some hints on certain simple precautions to "
"be taken."
msgstr ""
"La manière d'obtenir de telles horloges en temps réel et de sécuriser le "
"réseau contre la dérive intentionnelle ou non de l'horloge dépasse, en "
"général, le cadre de cette spécification. Toutefois, nous donnons quelques "
"indications sur certaines précautions simples à prendre."

#: ../../theory/highway.rst:59
msgid "Why “Highway”"
msgstr "Pourquoi \"Highway\" ?"

#: ../../theory/highway.rst:61
msgid ""
"To intuitively capture the key idea of the :math:`2^n` round length trick, "
"we once imagined a highway, well - a mathematical highway with infinitely "
"many lanes. Lanes are numbered with integers (all integers, also negative)."
msgstr ""
"Pour saisir intuitivement l'idée clé de l'astuce :math:`2^n` de la longueur "
"d'un rond, nous avons un jour imaginé une autoroute, enfin - une autoroute "
"mathématique avec une infinité de voies. Les voies sont numérotées avec des "
"nombres entiers (tous les nombres entiers, même négatifs)."

#: ../../theory/highway.rst:65
msgid ""
"This highway is different because movement on it takes place in the form of "
"hops, while the speed of all cars is constant. In any given lane :math:`n`, "
"a car has to make :math:`2^n` hops to cover a unit distance."
msgstr ""
"Cette autoroute est différente car les déplacements s'y font sous forme de "
"sauts, alors que la vitesse de toutes les voitures est constante. Sur une "
"voie :math:`n` donnée, une voiture doit faire :math:`2^n` sauts pour couvrir"
" une distance unitaire."

#: ../../theory/highway.rst:69
msgid ""
"Therefore, if you switch to the lane on your left-hand side, you increase "
"the frequency of your hopping by a factor of 2. If you switch to your right-"
"hand side, you decrease the frequency by a factor of 2."
msgstr ""
"Par conséquent, si vous passez sur la voie de gauche, vous augmentez la "
"fréquence de vos sauts par un facteur de 2. Si vous passez sur votre droite,"
" vous diminuez la fréquence par un facteur de 2."

#: ../../theory/highway.rst:73
msgid ""
"You meet cars from the lane on your left-hand side on every jump you make. "
"For cars on your right-hand side, you meet only every second hop."
msgstr ""
"Vous rencontrez les voitures de la voie située à votre gauche à chaque saut "
"que vous effectuez. Pour les voitures de votre côté droit, vous ne "
"rencontrez qu'un saut sur deux."

#: ../../theory/highway.rst:77
msgid "Messages structure"
msgstr "Structure des messages"

#: ../../theory/highway.rst:80
msgid ""
"While we generally keep messages structure established in NCB, we require "
"the"
msgstr ""
"Bien que nous conservions généralement la structure des messages établie "
"dans la PNE, nous exigeons les"

#: ../../theory/highway.rst:80
msgid "following additional fields:"
msgstr "champs supplémentaires suivants :"

#: ../../theory/highway.rst:82
msgid "for every message:"
msgstr "pour chaque message :"

#: ../../theory/highway.rst:84
msgid "**round-id: Int** - keeps the round id that this message belongs to"
msgstr ""
"**round-id: Int** - conserve l'id du tour (ronde) à auquel ce message "
"appartient"

#: ../../theory/highway.rst:85
msgid ""
"**real-time-stamp: Int** - keeps the actual time of creating this message"
msgstr ""
"**real-time-stamp: Int** - conserve la date réelle de création de ce message"

#: ../../theory/highway.rst:86
msgid ""
"taken from the real-time clock of the sender (must be creation as opposed to"
" sending because all fields are sealed with a digital signature)"
msgstr ""
"prise dans l'horloge en temps réel de l'expéditeur (il doit s'agir d'une "
"création par opposition à l'envoi car tous les champs sont scellés par une "
"signature numérique)"

#: ../../theory/highway.rst:89
msgid "for blocks only:"
msgstr "pour les blocs uniquement :"

#: ../../theory/highway.rst:91
msgid ""
"**magic-bit: Bit** - this is one bit field needed for leaders pseudorandom"
msgstr ""
"**magic-bit: Bit** - Il s'agit d'un champ de bits nécessaire pour les "
"leaders pseudo-aléatoires."

#: ../../theory/highway.rst:92
msgid "generator seed"
msgstr "graine de générateur (generator seed)"

#: ../../theory/highway.rst:94
msgid "for ballots only:"
msgstr "pour les scrutins (ballots) uniquement :"

#: ../../theory/highway.rst:96
msgid "**message-type: Enum** - one of: LAMBDA_RESPONSE, OMEGA"
msgstr "**message-type: Enum** - une valeur parmi : LAMBDA_RESPONSE, OMEGA"

#: ../../theory/highway.rst:98
msgid ""
"Note: The semantics of these fields is explained later in this document."
msgstr ""
"Note : La sémantique de ces champs est expliquée plus loin dans ce document."

#: ../../theory/highway.rst:101
msgid "Liveness strategy"
msgstr "Stratégie de vivacité (liveness)"

#: ../../theory/highway.rst:104
msgid "Ticks"
msgstr "Tics"

#: ../../theory/highway.rst:106
msgid ""
"Validators see time in a discrete way, namely - as the number of ticks since"
" some hardcoded point of real time. For simplicity, we assume that ticks are"
" just milliseconds since “epoch” -- the Unix time representation standard."
msgstr ""
"Les validateurs voient le temps d'une manière discrète, c'est-à-dire comme "
"le nombre de tics depuis un certain point codé en dur du temps réel. Pour "
"simplifier, nous supposons que les ticks ne sont que des millisecondes "
"depuis \"epoch\" -- la norme Unix de représentation du temps."

#: ../../theory/highway.rst:111
msgid "Leaders"
msgstr "Leaders"

#: ../../theory/highway.rst:114
msgid ""
"There is a **leader** assigned to every tick. A leader is always one from "
"the"
msgstr ""
"Il y a un **leader** assigné à chaque tic. Un leader est toujours un des"

#: ../../theory/highway.rst:114
msgid "currently staked validators."
msgstr "des validateurs actuels."

#: ../../theory/highway.rst:116
msgid ""
"The precise algorithm of calculating who is the leader of given tick is "
"pretty convoluted and needs a machinery that we will establish step-by-step."
" For now, it is enough to say that a validator has a recipe to calculate the"
" leader of every tick."
msgstr ""
"L'algorithme précis permettant de calculer qui est le leader d'un tic est "
"assez alambiqué et nécessite une machinerie que nous allons établir étape "
"par étape. Pour l'instant, il suffit de dire qu'un validateur a une recette "
"pour calculer le leader de chaque tic."

#: ../../theory/highway.rst:122
msgid "Rounds"
msgstr "Tour (ronde)"

#: ../../theory/highway.rst:125
msgid ""
"In a leader based system, rounds are inevitable, because a leader cannot "
"lead"
msgstr ""
"Dans un système basé sur un leader, les tours (rondes) sont inévitables, car"
" un leader ne peut pas diriger"

#: ../../theory/highway.rst:125
msgid "forever. Hence, it is supposed to lead during a single round."
msgstr ""
"pour toujours. Par conséquent, il est censé mener pendant un seul tour."

#: ../../theory/highway.rst:127
msgid ""
"Picking a fixed round length obviously leads to scaling issues. On the other"
" hand, adjusting round length on-the-fly is tricky."
msgstr ""
"Le choix d'une longueur de tour fixe entraîne évidemment des problèmes de "
"mise à l'échelle. D'autre part, l'ajustement de la longueur du tour à la "
"volée est délicat."

#: ../../theory/highway.rst:130
msgid ""
"In Highway, we approach the problem of automatic adjustment of round length "
"in a unique and unusual way. Every validator selects a private value "
":math:`n \\in Int`, which we call **round exponent**. Over time, a validator"
" will be automatically adjusting this value to optimize its performance and "
"the performance of the blockchain."
msgstr ""
"Dans Highway, nous abordons le problème de l'ajustement automatique de la "
"longueur des tours d'une manière unique et inhabituelle. Chaque validateur "
"sélectionne une valeur privée :math:`n \\in Int`, que nous appelons **round "
"exponent**. Au fil du temps, un validateur ajustera automatiquement cette "
"valeur pour optimiser ses performances et celles de la blockchain."

#: ../../theory/highway.rst:137
msgid ""
"Given a round exponent :math:`n`, the length of a round that a validator "
"uses"
msgstr ""
"Étant donné un *round exponent* :math:`n`, la longueur d'un tour qu'un "
"validateur utilise"

#: ../../theory/highway.rst:137
msgid "for its operation is :math:`2^n` ticks."
msgstr "pour son fonctionnement est de :math:`2^n` tics."

#: ../../theory/highway.rst:139
msgid ""
"So, effectively, rounds live in sort of parallel worlds (“lanes of the "
"highway”), where all validators with same round exponent :math:`n` have the "
"same schedule of rounds. On the other hand, if we compare two validators, "
"**Alice** and **Bob**, **Alice** using round exponent :math:`n`, **Bob** "
"using round exponent :math:`m`, and assuming :math:`n < m`, then:"
msgstr ""
"Ainsi, en réalité, les tours vivent dans une sorte de mondes parallèles "
"(\"voies de l'autoroute\"), où tous les validateurs ayant le même *round "
"exponent* :math:`n` ont le même calendrier de tours. D'un autre côté, si "
"nous comparons deux validateurs, **Alice** et **Bob**, **Alice** utilisant "
"le 'round exponent' :math:`n`, **Bob** utilisant le 'round exponent' "
":math:`m`, et en supposant que :math:`n < m`, alors :"

#: ../../theory/highway.rst:145
msgid "**Alice** is :math:`2^{m-n}` faster than **Bob**"
msgstr "**Alice** est :math:`2^{m-n}` plus rapide que **Bob**"

#: ../../theory/highway.rst:146
msgid "**Alice** participates in all rounds that **Bob** knows about"
msgstr "**Alice** participe à tous les tours que **Bob** connaît."

#: ../../theory/highway.rst:147
msgid ""
"**Bob** participates only in some rounds that **Alice** knows about - once"
msgstr ""
"**Bob** ne participe qu'à certains tours dont **Alice** est au courant - une"
" fois."

#: ../../theory/highway.rst:148
msgid "every :math:`2^{m-n}` **Alice**\\ ’s rounds"
msgstr "chaque :math:`2^{m-n}` tours d' **Alice**"

#: ../../theory/highway.rst:150
msgid ""
"A round is identified by the tick at which it starts. Of course validators "
"with different round exponents will differ in perspective on the length of "
"this round."
msgstr ""
"Un tour est identifié par le tic auquel il commence. Bien entendu, les "
"validateurs ayant des 'round exponents' différents auront des points de vue "
"différents sur la durée de ce tour."

#: ../../theory/highway.rst:154
msgid ""
"**Example:** Alice has round exponent 5. Bob has round exponent 7. So, in "
"Alice’s world, rounds have length 32 ticks, while in Bob’s world rounds have"
" length 128 ticks. Timepoint 2019-09-13T13:13:13.088Z corresponds with tick "
"1568380393088 and is the beginning of a round for both Alice and Bob. But, "
"in Alice’s world, this round will only last for 32 milliseconds, while for "
"Bob this round will last for 128 milliseconds."
msgstr ""
"**Exemple:** Alice a un 'round exponent' de 5. Bob a un 'round exponent' de "
"7. Ainsi, dans le monde d'Alice, les tours ont une longueur de 32 ticks, "
"tandis que dans le monde de Bob, les tours ont une longueur de 128 ticks. Le"
" point temporel 2019-09-13T13:13:13.088Z correspond au tic-tac 1568380393088"
" et constitue le début d'un tour pour Alice et Bob. Mais, dans le monde "
"d'Alice, ce tour ne durera que 32 millisecondes, alors que pour Bob, il "
"durera 128 millisecondes."

#: ../../theory/highway.rst:162
msgid "Validator operation"
msgstr "Opération du validateur"

#: ../../theory/highway.rst:164
msgid ""
"Contrary to NCB, the way ballots are used in Highway is more sophisticated."
msgstr ""
"Contrairement à NCB, la manière dont les scrutins (ballots) sont utilisés "
"dans l'autoroute est plus sophistiquée."

#: ../../theory/highway.rst:166
msgid ""
"In NCB a validator only produces ballots to continue participation in "
"**b-game** after doing unbonding. In Highway, only the round leader is "
"allowed to produce blocks. So if I am not the leader of current round, I am "
"going to produce only ballots."
msgstr ""
"Dans NCB, un validateur ne produit des blocs que pour continuer à participer"
" au **b-game** après avoir effectué le 'unbonding'. Dans Highway, seul le "
"leader du tour est autorisé à produire des blocs. Donc, si je ne suis pas le"
" leader du tour actuel, je vais produire uniquement des scrutins."

#: ../../theory/highway.rst:171
msgid ""
"In details, local state and operation of a validator is similar to NCB. The "
"only difference is that we impose very precise rules on when and how to "
"create new messages."
msgstr ""
"Dans le détail, l'état local et le fonctionnement d'un validateur sont "
"similaires à ceux de la BCN. La seule différence est que nous imposons des "
"règles très précises sur quand et comment créer de nouveaux messages."

#: ../../theory/highway.rst:176
msgid "Rule 1: ignore rounds you cannot see"
msgstr "Règle 1 : ignorez les tours que vous ne pouvez pas voir"

#: ../../theory/highway.rst:178
msgid ""
"I operate as if the world is simple and everybody uses the same round "
"exponent as I am using. Which means that I completely ignore the existence "
"of rounds starting at ticks not divisible by :math:`2^n`, where :math:`n` is"
" my round exponent."
msgstr ""
"Je fonctionne comme si le monde était simple et que tout le monde utilisait "
"le même 'round exponent' que moi. Ce qui signifie que j'ignore complètement "
"l'existence de tours commençant à des tics non divisibles par :math:`2^n`, "
"où :math:`n` est mon 'round exponent'. "

#: ../../theory/highway.rst:184
msgid "Rule 2: follow the leader sequence"
msgstr "Règle 2 : suivre la séquence du leader"

#: ../../theory/highway.rst:187
msgid ""
"For every round I use the leader's pseudorandom sequence to figure out the "
"id"
msgstr ""
"Pour chaque tour, j'utilise la séquence pseudo aléatoire du leader pour "
"déterminer l'id."

#: ../../theory/highway.rst:187
msgid "of a validator which is the leader of this round."
msgstr "d'un validateur qui est le leader de ce tour."

#: ../../theory/highway.rst:190
msgid "Rule 3: lambda message"
msgstr "Règle 3 : message lambda"

#: ../../theory/highway.rst:192
msgid ""
"If I am the leader of current round, I produce new block :math:`b`, using "
"all"
msgstr ""
"Si je suis le leader de la tour en cours, je produis un nouveau bloc "
":math:`b`, en utilisant tous"

#: ../../theory/highway.rst:193
msgid ""
"tips of my local j-dag as justifications of :math:`b`. Then I broadcast"
msgstr ""
"des pointes de mon j-dag local comme justifications de :math:`b`. Ensuite, "
"je diffuse"

#: ../../theory/highway.rst:194
msgid ":math:`b` to all validators."
msgstr ":math:`b` à tous les validateurs."

#: ../../theory/highway.rst:198
msgid ""
"We call this message **the lambda message**. There is only one lambda "
"message"
msgstr ""
"Nous appelons ce message **le message lambda** (the lambda message). Il "
"n'existe qu'un seul message lambda"

#: ../../theory/highway.rst:197
msgid ""
"in every round. Every block :math:`b` is a lambda message of some round, "
"namely round :math:`b.round\\_id`."
msgstr ""
"dans chaque tour. Chaque bloc :math:`b` est un message lambda d'un certain "
"tour, à savoir le tour :math:`b.round\\_id`."

#: ../../theory/highway.rst:201
msgid "Rule 4: lambda response message"
msgstr "Règle 4 : message de réponse lambda"

#: ../../theory/highway.rst:203
msgid ""
"If I am not the leader of the current round, I set up a handler for "
"receiving the lambda message from this round’s leader. This handler waits "
"for the lambda message but only up to the end of the current round. If the "
"lambda message arrives before the end of the current round, I create a "
"ballot taking as its justifications only the lambda message and my last "
"message (if I have one)."
msgstr ""
"Si je ne suis pas le leader de la tour actuelle, je mets en place un "
"gestionnaire pour recevoir le message lambda du leader de ce tour. Ce "
"gestionnaire attend le message lambda mais seulement jusqu'à la fin du tour "
"actuel. Si le message lambda arrive avant la fin du tour en cours, je crée "
"un bulletin de vote (ballot) en prenant comme justifications uniquement le "
"message lambda et mon dernier message (si j'en ai un)."

#: ../../theory/highway.rst:210
msgid "Rule 5: omega message"
msgstr "Règle 5 : message oméga"

#: ../../theory/highway.rst:212
msgid ""
"Let :math:`j` be the id of current round. At tick :math:`j + omega\\_delay "
"\\cdot 2^n` I create a ballot :math:`b` using all tips of my local j-dag as "
"justifications of :math:`b`."
msgstr ""
"Soit :math:`j` l'id du tour actuel. Au tic :math:`j + omega\\_delay \\cdot "
"2^n` je crée un bulletin de vote :math:`b` en utilisant toutes les pointes "
"de mon j-dag local comme justifications de :math:`b`."

#: ../../theory/highway.rst:216
msgid ""
":math:`omega\\_delay \\in(0,1)` is a blockchain parameter - to be picked by "
"simulation and then hardcoded."
msgstr ""
":math:`omega\\_delay \\in(0,1)` est un paramètre de la blockchain - à "
"choisir par simulation et ensuite codé en dur."

#: ../../theory/highway.rst:220
msgid "Adjusting round exponent"
msgstr "Ajustement du 'round exponent'"

#: ../../theory/highway.rst:222
msgid ""
"We need to make it clear what the semantics is of adjusting the round "
"exponent. First, we want to say that the mechanics of messages creation "
"requires that a validator knows what exponent he was using at any tick. This"
" can be formalized by saying that for any validator :math:`v` there is a "
"function :math:`n_v: Int \\to Int`, assigning an exponent to be used by "
":math:`v` in any given tick."
msgstr ""
"Nous devons préciser la sémantique de l'ajustement du 'round exponent' Tout "
"d'abord, nous voulons dire que la mécanique de création des messages exige "
"qu'un validateur sache quel exponent il utilisait à tout moment (tic). Cela "
"peut être formalisé en disant que pour tout validateur :math:`v`, il existe "
"une fonction :math:`n_v : Int \\to Int`, assignant un exponent à utiliser "
"par :math:`v` à chaque tic."

#: ../../theory/highway.rst:229
msgid ""
"When a validator wants to adjust its round exponent, this must be done at a "
"tick that happens to be the boundary of both the old-length round and the "
"new-length round. Mathematically this transforms into saying that :math:`n_v"
" (i) = n_v(i-1)` unless :math:`i` is a multiple of both :math:`2^{n_v(i)}` "
"and :math:`2^{n_v(i-1)}`."
msgstr ""
"Lorsqu'un validateur souhaite ajuster son 'round exponent', cela doit être "
"fait à un tic qui se trouve être la limite de l'ancien tour et du nouveau "
"tour. Mathématiquement, cela revient à dire que :math:`n_v (i) = n_v(i-1)` "
"sauf si :math:`i` est un multiple de :math:`2^{n_v(i)}` et "
":math:`2^{n_v(i-1)}`"

#: ../../theory/highway.rst:238
msgid ""
"Auto-adjusting of round lengths is based on an internal finalizer which "
"every"
msgstr ""
"L'ajustement automatique de la longueur des tours est basé sur un "
"finalisateur interne qui chaque "

#: ../../theory/highway.rst:236
msgid ""
"validator must maintain. This finalizer would run with the fault tolerance "
"threshold :math:`ftt` set as blockchain-wide constant (:math:`ftt=1\\%` "
"sounds like a good candidate value here) and "
":math:`acknowledgement\\_level=1`."
msgstr ""
"validateur doit maintenir. Ce finalisateur fonctionnerait avec le seuil de "
"tolérance aux pannes :math:`ftt` défini comme une constante à l'échelle de "
"la blockchain (:math:`ftt=1\\%` semble être une bonne valeur candidate ici) "
"et :math:`acknownowledgement\\_level=1`."

#: ../../theory/highway.rst:240
msgid ""
"Now, we finally can define the strategy of auto-adjusting round exponents."
msgstr ""
"Maintenant, nous pouvons enfin définir la stratégie d'auto-ajustement des ' "
"round exponents'."

#: ../../theory/highway.rst:242
msgid ""
"We assume there are two blockchain-wide integer constants, both expressing "
"the number of rounds:"
msgstr ""
"Nous supposons qu'il existe deux constantes entières à l'échelle de la "
"blockchain, exprimant toutes deux le nombre de tours :"

#: ../../theory/highway.rst:245
msgid "**round-acceleration-period** - every that-many-rounds a validator"
msgstr ""
"**round-acceleration-period** - nombre de tours au bout desquels un "
"validateur"

#: ../../theory/highway.rst:246
msgid ""
"decreases its round exponent by :math:`1` (unconditionally) -  **round-"
"slowdown-period** - if a validator observes that many consecutive rounds "
"with the lambda message from the round leader not getting finalized, it "
"increases its round exponent by 1"
msgstr ""
"diminue son 'round exponent' par :math:`1` (sans condition) - **round-"
"slowdown-period** - si un validateur observe un grand nombre de tours "
"consécutifs où le message lambda du leader du tour n'est pas finalisé, il "
"augmente son 'round exponent' de 1"

#: ../../theory/highway.rst:252
msgid "Eras"
msgstr "Eres"

#: ../../theory/highway.rst:255
msgid "The need for eras"
msgstr "Le besoin d'Eres"

#: ../../theory/highway.rst:257
msgid ""
"The idea of of eras is to keep the validator weights map constant for a "
"longer period of time (e.g., a week). Otherwise, it is rather difficult to "
"establish a pseudorandom leaders sequence all validators agree on. Eras also"
" plays a crucial role in making the leader selection resistant to attack."
msgstr ""
"L'idée des ères est de garder la map des poids des validateurs constante "
"pendant une longue période de temps (par exemple une semaine). Sinon, il est"
" assez difficile d'établir une séquence de leaders pseudo-aléatoire sur "
"laquelle tous les validateurs sont d'accord. Les eras jouent également un "
"rôle crucial en rendant la sélection des leaders résistante aux attaques."

#: ../../theory/highway.rst:263
msgid "Boundary of an era"
msgstr "Frontière d'une Ere"

#: ../../theory/highway.rst:265
msgid ""
"**Era length** is just a parameter of the blockchain - expressed as a number"
" of ticks. We expect a reasonable era length might be 604800000, which is "
"one week."
msgstr ""
"**La durée d'une ère** est simplement un paramètre de la blockchain, exprimé"
" en nombre de tics. Nous pensons qu'une longueur d'ère raisonnable pourrait "
"être de 604800000, ce qui correspond à une semaine."

#: ../../theory/highway.rst:268
msgid ""
"A message :math:`m` belongs to an era deduced by knowing the era length and "
"looking at :math:`m.round\\_id`."
msgstr ""
"Un message :math:`m` appartient à une ère déduite en connaissant la longueur"
" de l'ère et en regardant :math:`m.round\\_id`."

#: ../../theory/highway.rst:272
msgid "Critical blocks"
msgstr "Blocs critiques"

#: ../../theory/highway.rst:274
msgid ""
"Round ids are really Unix timestamps, so main-tree can be now imagined with "
"time-axis overlayed."
msgstr ""
"Les ids des tours sont en fait des timestamps Unix, donc l'arbre principal "
"peut maintenant être imaginé avec l'axe du temps superposé."

#: ../../theory/highway.rst:277
msgid ""
"In every era, there are two ticks (with a distance fixed relative to the "
"beginning of an era):"
msgstr ""
"Dans chaque ère, il y a deux tics (avec une distance fixe par rapport au "
"début d'une ère) :"

#: ../../theory/highway.rst:280
msgid "**booking-point**"
msgstr "**booking-point**"

#: ../../theory/highway.rst:281
msgid "**key-point**"
msgstr "**key-point**"

#: ../../theory/highway.rst:283
msgid ""
"These points are blockchain parameters and **key-point** must be strictly "
"bigger than **booking-point**."
msgstr ""
"Ces points sont des paramètres de la blockchain et **key-point** doit être "
"strictement plus grand que **booking-point**."

#: ../../theory/highway.rst:286
msgid ""
"Let :math:`era\\_start: Int \\to Int` be a function that assigns to every "
"tick the beginning of an era this tick belongs to. This function can easily "
"be calculated as:"
msgstr ""
"Soit :math:`era\\_start : Int \\to Int` est une fonction qui attribue à "
"chaque tic le début d'une ère à laquelle ce tic appartient. Cette fonction "
"peut facilement être calculée comme suit :"

#: ../../theory/highway.rst:290
msgid "era\\_start(t) = (t / era\\_length) * era\\_length"
msgstr "era\\_start(t) = (t / era\\_length) * era\\_length"

#: ../../theory/highway.rst:295
msgid "… where the division is integer division."
msgstr "... où la division est une division entière."

#: ../../theory/highway.rst:297
msgid ""
"**Booking block** is any block :math:`b` such that both following conditions"
" hold:"
msgstr ""
"**Booking block** est tout bloc :math:`b` tel que les deux conditions "
"suivantes soient remplies :"

#: ../../theory/highway.rst:299
msgid ":math:`b.round\\_id \\geqslant era\\_start(b.round\\_id) + booking\\_point`"
msgstr ":math:`b.round\\_id \\geqslant era\\_start(b.round\\_id) + booking\\_point`"

#: ../../theory/highway.rst:300
msgid ":math:`b.main\\_parent.round\\_id < era\\_start(b.round\\_id) + booking\\_point`"
msgstr ""
":math:`b.main\\_parent.round\\_id < era\\_start(b.round\\_id) + "
"booking\\_point`"

#: ../../theory/highway.rst:302
msgid ""
"It can be explained as the idea that on any path of the main-tree, booking "
"block is the first block to cross the time defined by **booking-point**, "
"where we consider “time of a block” to be the tick of the beginning of its "
"era."
msgstr ""
"Cela peut s'expliquer par l'idée que sur n'importe quel chemin de l'arbre "
"principal, le bloc de réservation est le premier bloc à franchir le temps "
"défini par **booking-point**, où nous considérons que le \"temps d'un bloc\""
" est le tic du début de son ère."

#: ../../theory/highway.rst:306
msgid "By analogy, we are defining a **key block** concept."
msgstr ""
"Par analogie, nous définissons un concept de **bloc clé** (key block)."

#: ../../theory/highway.rst:309
msgid "Leaders sequence"
msgstr "Séquence des leaders"

#: ../../theory/highway.rst:311
msgid ""
"To have the sequence of leaders that all validators calculate in the same "
"way, we only need:"
msgstr ""
"Pour avoir la séquence de leaders que tous les validateurs calculent de la "
"même manière, il suffit :"

#: ../../theory/highway.rst:314
msgid ""
"1. Canonical sorting of validators so that a weights map can be converted to"
" an array of validators in the canonical way. 2. Agreement on pseudorandom "
"number generator to be used by all validators. 3. Pseudorandom generator "
"seed."
msgstr ""
"1. Tri canonique des validateurs afin qu'une map de poids puisse être "
"convertie en un tableau de validateurs de manière canonique. 2. Accord sur "
"le générateur de nombres pseudo-aléatoires à utiliser par tous les "
"validateurs. 3. Graine (seed) du générateur pseudo-aléatoire."

#: ../../theory/highway.rst:319
msgid ""
"For (1) sorting by validator ids can be used. (2) can be hardcoded. So it is"
" all about the way we pick the seed."
msgstr ""
"Pour (1), le tri par les ids des validateurd peut être utilisé. (2) peut "
"être codé en dur. Tout dépend donc de la façon dont on choisit la graine "
"(seed)."

#: ../../theory/highway.rst:323
msgid "The mechanics of an era"
msgstr "Les mécaniques d'une ère"

#: ../../theory/highway.rst:326
msgid "The vision"
msgstr "La vision"

#: ../../theory/highway.rst:328
msgid "Eras constitute the platform on which two mechanisms work:"
msgstr ""
"Les ères constituent la plate-forme sur laquelle fonctionnent deux "
"mécanismes :"

#: ../../theory/highway.rst:330
msgid "validators rotation (= bonding/unbonding)"
msgstr "validators rotation (= bonding/unbonding)"

#: ../../theory/highway.rst:331
msgid "leaders sequence"
msgstr "Séquence des leaders"

#: ../../theory/highway.rst:333
msgid "Within a single era:"
msgstr "Dans une même ère :"

#: ../../theory/highway.rst:335
msgid "the weights map is fixed"
msgstr "la map des poids est fixe"

#: ../../theory/highway.rst:336
msgid ""
"the leaders selection functions (assigning a leader to every tick) is fixed"
msgstr ""
"les fonctions de sélection des leaders (assignation d'un leader à chaque "
"tic) sont fixes"

#: ../../theory/highway.rst:338
msgid ""
"An era starts at fixed point of real time (fixed tick). We generally expect "
"that:"
msgstr ""
"Une ère commence à un point fixe du temps réel (tic fixe). Nous nous y "
"attendons généralement :"

#: ../../theory/highway.rst:340
msgid ""
"1. The weights map to be used in this era is defined by a booking block from"
" :math:`era\\_delay` rounds ago. 2. The random seed to be used in this era "
"is defined by a key block from :math:`era\\_delay` rounds ago."
msgstr ""
"1. La map de poids à utiliser dans cette ère est définie par un bloc de "
"réservation datant de :math:`era\\_delay` tours. 2. La graine (seed) "
"aléatoire à utiliser à cette ère est définie par un bloc de clés datant de "
":math:`era\\_delay` tours."

#: ../../theory/highway.rst:345
msgid ""
"Both :math:`era\\_delay` is a blockchain parameter. We expect that "
"reasonable value for :math:`era\\_delay` is 2."
msgstr ""
":math:`era\\_delay` est un paramètre de la blockchain. Nous pensons que la "
"valeur raisonnable pour :math:`era_delay` est 2."

#: ../../theory/highway.rst:349
msgid "Setting the weights map"
msgstr "Définition de la map des poids"

#: ../../theory/highway.rst:351
msgid ""
"Just take weights map as defined in the post-state of the corresponding "
"booking block."
msgstr ""
"Il suffit de prendre la map des poids telle que définie dans le post-state "
"du bloc de réservation correspondant."

#: ../../theory/highway.rst:354
msgid "Setting the random seed for leaders sequence generator"
msgstr ""
"Définition de la graine (seed) aléatoire pour le générateur de la séquence "
"leaders"

#: ../../theory/highway.rst:356
msgid ""
"Take the hash of corresponding key-block, then add all magic bits from main-"
"tree path-of-blocks between the booking block and the key block (both from "
"the same era)."
msgstr ""
"Prenez le hash du bloc-clé (key-block) correspondant, puis ajoutez tous les "
"'bits magiques' du chemin des blocs de l'arbre principal entre le bloc de "
"réservation et le bloc-clé (tous deux de la même ère)."

#: ../../theory/highway.rst:361
msgid "Disparation of eras"
msgstr "Séparation des ères"

#: ../../theory/highway.rst:363
msgid ""
"In an era we typically will observe many booking blocks and key blocks, just"
" because the main-tree is typically not a chain. The expectation here is "
"that the combination of :math:`era\\_delay` and :math:`key\\_point` together"
" make enough time between the key block and the beginning of the era it "
"defines, that the LFB chain of a reasonably strong finalizer will do the "
"selection of only one “official” key block."
msgstr ""
"Dans une ère, nous observerons typiquement de nombreux blocs de réservation "
"et blocs clés, simplement parce que l'arbre principal n'est typiquement pas "
"une chaîne. On s'attend ici à ce que la combinaison de :math:`era\\_delay` "
"et :math:`key\\_point` donne suffisamment de temps entre le bloc-clé et le "
"début de l'ère qu'il définit, pour que la chaîne LFB d'un finalisateur "
"raisonnablement fort ne fasse la sélection que d'un seul bloc-clé "
"\"officiel\"."

#: ../../theory/highway.rst:370
msgid "Let us do a simple calculations:"
msgstr "Faisons un calcul simple :"

#: ../../theory/highway.rst:372
msgid ""
"Assuming the era length is set to one week - starting Monday and ending "
"Sunday - and the key point is set to Thursday noon. Also, assume that "
"“era\\_delay” is 2. This means that key blocks created just after Thursday "
"noon will control the era that will start 10.5 days later. This is plenty of"
" time and by that time it is “almost sure” that the progressing LFB chain "
"will"
msgstr ""
"Supposons que la durée de l'ère soit fixée à une semaine - commençant le "
"lundi et se terminant le dimanche - et que le point clé soit fixé au jeudi "
"midi. Supposons également que \"era\\_delay\" soit égal à 2, ce qui signifie"
" que les blocs clés créés juste après le jeudi midi contrôleront l'ère qui "
"commencera 10,5 jours plus tard. C'est beaucoup de temps et, à ce moment-là,"
" il est \"presque sûr\" que la chaîne LFB en progression"

#: ../../theory/highway.rst:377
msgid "pick the “right” key block to be used."
msgstr "choisira le \"bon\" bloc-clé à utiliser."

#: ../../theory/highway.rst:379
msgid ""
"In the extreme case, however, the finality of the key block might not be "
"there at the moment of starting the era to be controlled by this block. This"
msgstr ""
"Dans le cas extrême, cependant, la finalité du bloc-clé pourrait ne pas être"
" présente au moment du démarrage de l'ère à contrôler par ce bloc. C'est"

#: ../../theory/highway.rst:381
msgid ""
"is an interesting situation that actually can be handled, although this is "
"to happen in a “shocking” way. The way to go is to run in parallel all "
"possible eras - accordingly to all key blocks that are “on the table”. Of "
"course, these parallel eras must be run as if they are completely "
"independent blockchains (= separate P2p networks). Eventually, the "
"progressing LFB chain will materialize only one reality, and so all the "
"other virtual eras must disappear, so validators will just forget they ever "
"existed. This is exactly like in quantum mechanics, where at some point only"
" one version of reality is materializing."
msgstr ""
"est une situation intéressante qui peut être traitée, même si cela doit se "
"faire de manière \"choquante\". La solution consiste à exécuter en parallèle"
" toutes les périodes possibles, en fonction de tous les blocs clés qui sont "
"\"sur la table\". Bien sûr, ces périodes parallèles doivent être exécutées "
"comme s'il s'agissait de blockchains complètement indépendantes (= réseaux "
"P2P séparés). Finalement, la chaîne LFB en progression ne matérialisera "
"qu'une seule réalité, et donc toutes les autres ères virtuelles doivent "
"disparaître, de sorte que les validateurs oublieront simplement qu'elles ont"
" existé. C'est exactement comme en mécanique quantique, où à un moment "
"donné, une seule version de la réalité se matérialise."
