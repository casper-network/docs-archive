# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, CasperLabs LLC
# This file is distributed under the same license as the CasperLabs Tech
# Spec package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
# 
# Translators:
# muss abahmane <elmabahma@gmail.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CasperLabs Tech Spec\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-26 20:13+0000\n"
"PO-Revision-Date: 2021-06-26 21:48+0000\n"
"Last-Translator: muss abahmane <elmabahma@gmail.com>, 2021\n"
"Language-Team: French (https://www.transifex.com/caspernetwork/teams/122124/fr/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Language: fr\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../implementation/appendix.rst:4
msgid "Appendix"
msgstr "Annexe"

#: ../../implementation/appendix.rst:9
msgid "A - Casper Rust Library"
msgstr "A - Librairie Casper Rust"

#: ../../implementation/appendix.rst:11
msgid ""
"Casper provides low-level bindings for host-side (“external”) functions for "
"developers creating smart contracts in other programming languages. "
"Developers can import these functions into a wasm module used as a contract "
"on the Casper Network. Thus, the contract will have access to features "
"specific to the Casper platform which are not supported by general wasm "
"instructions (e.g., accessing the global state, creating new ``URef``\\ s). "
"These are defined and automatically imported if the `Casper Rust library "
"<https://crates.io/crates/casper-contract>`__ is used to develop the "
"contract. For an up-to-date description of exported functions, please visit "
"the `casper-contract <https://docs.rs/casper-"
"contract/latest/casper_contract/ext_ffi/index.html>`__ crate documentation."
msgstr ""
"Casper fournit des 'bindings' de bas niveau pour les fonctions 'host-side' "
"(\"externes\") destinées aux développeurs qui créent des contrats "
"intelligents dans d'autres langages de programmation. Les développeurs "
"peuvent importer ces fonctions dans un module wasm utilisé comme contrat sur"
" le réseau Casper. Ainsi, le contrat aura accès à des fonctionnalités "
"spécifiques à la plateforme Casper qui ne sont pas prises en charge par les "
"instructions générales de wasm (par exemple, l'accès à l'état global, la "
"création de nouveaux ``URef``\\ s). Celles-ci sont définies et "
"automatiquement importées si la librairie `Casper Rust' "
"<https://crates.io/crates/casper-contract>`__ est utilisée pour développer "
"le contrat. Pour une description actualisée des fonctions exportées, "
"veuillez consulter la documentation de le packet (crate)  `casper-contract "
"<https://docs.rs/casper-"
"contract/latest/casper_contract/ext_ffi/index.html>`_."

#: ../../implementation/appendix.rst:16
msgid "B - Serialization Format"
msgstr "B - Format de sérialisation"

#: ../../implementation/appendix.rst:18
msgid ""
"The Casper serialization format is used to transfer data between wasm and "
"the Casper host runtime. It is also used to persist global-state data in the"
" Merkle trie. The definition of this format is described in the :ref:`global"
" state <global-state-head>` section."
msgstr ""
"Le format de sérialisation Casper est utilisé pour transférer les données "
"entre wasm et le runtime Casper. Il est également utilisé pour faire "
"persister les données de l'état global dans l'arbre de Merkle. La définition"
" de ce format est décrite dans la section :ref:`global state <global-state-"
"head>`."

#: ../../implementation/appendix.rst:20
msgid ""
"A Rust reference implementation for those implementing this specification in"
" another programming language can be found here:"
msgstr ""
"Une implémentation de référence Rust pour ceux qui mettent en œuvre cette "
"spécification dans un autre langage de programmation peut être trouvée ici :"

#: ../../implementation/appendix.rst:22
msgid ""
"`bytesrepr <https://docs.rs/casper-"
"types/latest/casper_types/bytesrepr/index.html>`_"
msgstr ""
"`bytesrepr <https://docs.rs/casper-"
"types/latest/casper_types/bytesrepr/index.html>`_"

#: ../../implementation/appendix.rst:23
msgid ""
"`cl_value.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/cl_value.rs.html>`_"
msgstr ""
"`cl_value.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/cl_value.rs.html>`_"

#: ../../implementation/appendix.rst:24
msgid ""
"`account <https://docs.rs/casper-"
"types/latest/casper_types/account/index.html>`_"
msgstr ""
"`account <https://docs.rs/casper-"
"types/latest/casper_types/account/index.html>`_"

#: ../../implementation/appendix.rst:25
msgid ""
"`contract <https://docs.rs/casper-"
"types/latest/casper_types/contracts/struct.Contract.html>`_"
msgstr ""
"`contract <https://docs.rs/casper-"
"types/latest/casper_types/contracts/struct.Contract.html>`_"

#: ../../implementation/appendix.rst:26
msgid ""
"`uint.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/uint.rs.html>`_"
msgstr ""
"`uint.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/uint.rs.html>`_"

#: ../../implementation/appendix.rst:28
msgid ""
"Additionally, examples of all data types and their serializations are found "
"in the `GitHub code base <https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L26>`_."
" These examples include a set of useful `serialization tests "
"<https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L1189>`_."
msgstr ""
"De plus, des exemples de tous les types de données et de leurs "
"sérialisations se trouvent dans la base de code `GitHub "
"<https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L26>`_."
" Ces exemples comprennent un ensemble de `tests de sérialisation utiles "
"<https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L1189>`_."

#: ../../implementation/appendix.rst:35
msgid "C - Parallel Execution"
msgstr "C - Exécution parallèle"

#: ../../implementation/appendix.rst:38
msgid "Introduction"
msgstr "Introduction"

#: ../../implementation/appendix.rst:40
msgid ""
"The state of the Casper Network is represented by the :ref:`global state "
"<global-state-head>`. The evolution of this state is captured by the "
"blockchain itself, and eventually agreed upon by all nodes in the network "
"via the consensus mechanism. In this section we are concerned with only a "
"single step of that evolution. We think of such a step as performing some "
"\"computation\" that changes the global state. A :ref:`deploy <execution-"
"semantics-deploys>` is a user request for computation, and contains two "
"atomic units of computation: the payment code and the session code (the "
"details of which are discussed elsewhere). For the purpose of this section, "
"we think of each of these units as a (mathematical) function which takes the"
" current global state as input, perhaps along with some other arguments, and"
" produces a new global state as output. However, since the overall global "
"state is ambient from the perspective of the session/payment code itself, "
"the global state is not an explicit parameter in any user's source code, nor"
" is there any explicit return value."
msgstr ""
"L'état du réseau Casper est représenté par :ref:`état global <global-state-"
"head>`. L'évolution de cet état est capturée par la blockchain elle-même, et"
" finalement acceptée par tous les nœuds du réseau via le mécanisme de "
"consensus. Dans cette section, nous ne intéressons qu'à une seule étape de "
"cette évolution. Nous considérons qu'une telle étape consiste à effectuer un"
" \"calcul\" qui modifie l'état global.. A :ref:`deploy <execution-semantics-"
"deploys>` est une requête de calcul de l'utilisateur, et contient deux "
"unités atomiques de calcul : le code de paiement et le code de session (dont"
" les détails sont discutés ailleurs). Dans le cadre de cette section, nous "
"considérons chacune de ces unités comme une fonction (mathématique) qui "
"prend l'état global actuel en paramètre d'entrée, éventuellement avec "
"d'autres arguments, et produit un nouvel état global en sortie. Cependant, "
"puisque l'état global est dependant du code de session/paiement lui-même, "
"l'état global n'est pas un paramètre explicite dans le code source d'un "
"utilisateur, et il n'y a pas non plus de valeur de retour explicite."

#: ../../implementation/appendix.rst:55
msgid ""
"In this section we refine this idea of computation modeled as functions, and"
" describe how it is used to enable parallel execution."
msgstr ""
"Dans cette section, nous affinons cette idée de calcul modélisé sous forme "
"de fonctions, et décrivons comment elle est utilisée pour permettre "
"l'exécution parallèle."

#: ../../implementation/appendix.rst:61
msgid "Computation as functions on the global state"
msgstr "Calculs en tant que fonctions de l'état global"

#: ../../implementation/appendix.rst:63
msgid ""
"As discussed in the introduction, we think of computation on the Casper "
"platform as being functions from the global state, :math:`G`, to itself. "
"Naturally, we can compose two such functions, to obtain another function. "
"This corresponds to sequential execution. For example, you can think of the "
"sequence ``payment_code -> session_code`` as being the composition of two "
"individual functions, capturing the effects of the payment and session "
"codes, respectively. If there are smart contracts which are called during "
"those execution phases, you could even break these down further into a "
"sequence of those calls: ``deployed_payment_wasm -> contract_a -> contract_b"
" -> stored_session_code -> contract_c -> ...``. For notational purposes, we "
"will call the set of functions :math:`\\left\\{ f \\ \\vert \\ f: G "
"\\rightarrow G \\right\\} = End(G)`, meaning \"endomorphisms of :math:`G`.\""
msgstr ""
"Comme nous l'avons vu dans l'introduction, nous considérons que les calculs "
"effectués sur la plate-forme Casper sont des fonctions de l'état global, "
":math:`G`, vers lui-même. Naturellement, on peut composer deux telles "
"fonctions, pour obtenir une autre fonction. Cela correspond à l'exécution "
"séquentielle. Par exemple, on peut penser à la séquence ``payment_code -> "
"session_code`` comme étant la composition de deux fonctions individuelles, "
"capturant les effets des codes de paiement et de session, respectivement. "
"S'il y a des contrats intelligents qui sont appelés pendant ces phases "
"d'exécution, vous pouvez même les décomposer davantage en une séquence de "
"ces appels : ``deployed_payment_wasm -> contract_a -> contract_b -> "
"stored_session_code -> contract_c -> ...``. Pour des raisons de notation, "
"nous appellerons l'ensemble des fonctions :math:`\\left\\{ f \\ \\vert \\ f:"
" G \\rightarrow G \\right\\} = End(G)`, signifiant \"endomorphisms of "
":math:`G`.\""

#: ../../implementation/appendix.rst:74
msgid ""
"While this simple model captures sequential execution, it does not model "
"parallel execution. Parallel execution is important because it can enable "
"the execution engine to run more than one deploy at the same time, possibly "
"improving block processing times. Note: each deploy itself is still single-"
"threaded; we will not support parallel execution within a single contract or"
" deploy. This optimization is purely for the performance of the node "
"implementation, not contract developers."
msgstr ""
"Si ce modèle simple rend compte de l'exécution séquentielle, il ne modélise "
"pas l'exécution parallèle. L'exécution parallèle est importante car elle "
"peut permettre au moteur d'exécution d'exécuter plus d'un déploiement en "
"même temps, ce qui peut améliorer les temps de traitement des blocs. "
"Remarque : chaque déploiement lui-même est toujours 'single-threaded' ; nous"
" ne prendrons pas en charge l'exécution parallèle dans un seul contrat ou "
"déploiement. Cette optimisation est uniquement destinée aux performances de "
"l'implémentation du nœud, et non aux développeurs de contrats."

#: ../../implementation/appendix.rst:83
msgid "Computation as functions from :math:`G` to :math:`End(G)`"
msgstr "Calcul en tant que fonctions de :math:`G` à :math:`End(G)`"

#: ../../implementation/appendix.rst:85
msgid ""
"The problem with functions on the global state itself is they mutate the "
"state, potentially causing problems if we wanted to apply two such functions"
" at the same time. Therefore, we will instead think of computations as "
"outputting a description of the changes to the global state that they would "
"make if given the chance. Or phrased another way, the execution of a deploy "
"will return a function that could be applied to the global state to obtain "
"the post-state we would have obtained from running the computation while "
"mutating the global state. The reason this helps is because we can apply "
"multiple such functions to the same global state at the same time; they are "
"pure functions that do not modify the global state. Thus we can execute "
"multiple deploys in parallel and later combine their outputs (more on this "
"later)."
msgstr ""
"Le problème des fonctions sur l'état global lui-même est qu'elles modifient "
"cet état, ce qui pourrait causer des problèmes si nous voulions appliquer "
"deux fonctions de ce type en même temps. Par conséquent, nous considérerons "
"plutôt que les calculs produisent une description des changements qu'ils "
"apporteraient à l'état global s'ils en avaient la possibilité. En d'autres "
"termes, l'exécution d'un déploiement renverra une fonction qui pourrait être"
" appliquée à l'état global pour obtenir le post-état que nous aurions obtenu"
" en exécutant le calcul tout en mutant l'état global. La raison pour "
"laquelle cela est utile est que nous pouvons appliquer plusieurs de ces "
"fonctions au même état global en même temps ; ce sont des fonctions pures "
"qui ne modifient pas l'état global. Ainsi, nous pouvons exécuter plusieurs "
"déploiements en parallèle et combiner ultérieurement leurs résultats (nous y"
" reviendrons plus tard)."

#: ../../implementation/appendix.rst:103
msgid ""
"The way this is modeled in the Casper execution engine is via the "
"|TrackingCopy|_. Executing deploys (and the contracts they call) read/write "
"from the |TrackingCopy|_ instead of the global state directly. The "
"|TrackingCopy|_ *tracks* the operations and returns the |Transforms|_ which "
"act on each key in the global state effected by the execution. Using the "
"nomenclature from the theory, this collection of keys and transforms "
"describes a function :math:`f: G \\rightarrow G` which is an endomorphism on"
" :math:`G`, i.e. an element of :math:`End(G)`."
msgstr ""
"Dans le système d'exécution de Casper, cela est modélisé par "
"|TrackingCopy|_. L'exécution des déploiements (et des contrats qu'ils "
"appellent) se fait avec des lecture/écriture de |TrackingCopy|_ au lieu de "
"l'état global directement. La |TrackingCopy|_ *surveille* les opérations et "
"renvoie des  |Transforms|_ qui agissent sur chaque clé dans l'état global "
"effectué par l'exécution. En utilisant la nomenclature de la théorie, cette "
"collection de clés et de transformées décrit une fonction :math:`f: G "
"\\rightarrow G` qui est un endomorphisme sur :math:`G`, c'est-à-dire un "
"élément de :math:`End(G)`."

#: ../../implementation/appendix.rst:113
msgid ""
"An important note about the returned |Transforms|_ is there is exactly one "
"``Transform`` per key that was used during the execution. Initially, this "
"may be unintuitive because a contract can use the same key multiple times, "
"however, because each deploy executes sequentially, we can use the "
"composition property discussed in the previous section to combine multiple "
"sequential operations into a single operation. Consider the following "
"example."
msgstr ""
"Une remarque importante à propos des |Transforms|_ retournées est qu'il y a "
"exactement une ``Transform`` par clé utilisée pendant l'exécution. "
"Initialement, cela peut être peu intuitif car un contrat peut utiliser la "
"même clé plusieurs fois. Cependant, comme chaque déploiement s'exécute de "
"façon séquentielle, nous pouvons utiliser la propriété de composition "
"discutée dans la section précédente pour combiner plusieurs opérations "
"séquentielles en une seule opération. Considérons l'exemple suivant."

#: ../../implementation/appendix.rst:130
msgid ""
"The above function reads a local variable, performs a computation which "
"depends on the current value of that variable, then writes an updated value."
" Suppose we execute this function on a global state where the value of the "
"local key is ``7``. Then the sequence of transforms on the global state "
"would be ``Read -> Write(22)`` since ``n`` would be odd and thus ``f_n`` "
"would be computed using the ``else`` case. From the perspective of state "
"changes, we only need to keep the ``Write(22)`` transform because final "
"state is the same as if we had also included the ``Read`` transform. In "
"fact, by the same reasoning, we know that we only need to keep the last "
"``Write``, whatever it happens to be, since it will be the final value on "
"the key after the computation finishes. Notice that the resulting global "
"state function does not exactly reproduce the original contract execution "
"steps; it is a *reduced trace* where only the final effect on the global "
"state is recorded [#]_. In particular, this means applying the results of "
"these executions is very fast relative to the original execution (this will "
"be importnat for how we use these traces in the next section). Also notice "
"that the transforms which are produced depend on the initial state. This "
"might be obvious since we are modeling compuation as functions :math:`f: G "
"\\rightarrow End(G)`, so this statement is simply that the function really "
"depends on its input. However, this is again an imporant concept to keep in "
"mind when working with this model of computation. Going back to our example,"
" if the value of the local key was ``16`` then the transform produced would "
"be ``Write(8)``, entirely different from the case where the initial value "
"was ``7``."
msgstr ""
"La fonction ci-dessus lit une variable locale, effectue un calcul qui dépend"
" de la valeur actuelle de cette variable, puis écrit une valeur actualisée. "
"Supposons que nous exécutions cette fonction sur un état global où la valeur"
" de la clé locale est ``7``. La séquence de transformations sur l'état "
"global serait alors ``Read -> Write(22)`` puisque ``n`` serait impair et "
"donc ``f_n`` serait calculé en utilisant le cas ``else``. Du point de vue "
"des changements d'état, nous n'avons besoin de garder que la transformation "
"``Write(22)`` car l'état final est le même que si nous avions aussi inclus "
"la transformation ``Read``. En fait, par le même raisonnement, nous savons "
"que nous n'avons besoin de garder que la dernière transformation ``Write``, "
"quelle qu'elle soit, puisqu'elle sera la valeur finale de la clé après la "
"fin du calcul. Remarquez que la fonction d'état global qui en résulte ne "
"reproduit pas exactement les étapes d'exécution du contrat original ; c'est "
"une *trace réduite* où seul l'effet final sur l'état global est enregistré "
"[#]_. En particulier, cela signifie que l'application des résultats de ces "
"exécutions est très rapide par rapport à l'exécution originale (ceci sera "
"important pour l'utilisation de ces traces dans la section suivante). "
"Remarquez également que les transformations produites dépendent de l'état "
"initial. Cela peut sembler évident puisque nous modélisons la computation "
"comme des fonctions :math:`f : G \\rightarrow End(G)`, donc cette "
"affirmation est simplement que la fonction dépend réellement de son entrée. "
"Cependant, il s'agit là encore d'un concept important à garder à l'esprit "
"lorsque l'on travaille avec ce modèle de calcul. Pour en revenir à notre "
"exemple, si la valeur de la clé locale était ``16``, alors la transformation"
" produite serait ``Write(8)``, totalement différente du cas où la valeur "
"initiale était ``7``."

#: ../../implementation/appendix.rst:155
msgid ""
"There is a special case of constructing reduced traces which is worth "
"calling out explicitly. Suppose the initial value of a key in the global "
"state is ``X``, and after performing the execution, the transform for that "
"key is ``Write(X)``. Then it is valid to replace that transform with "
"``Read``. This is because the computation acts like the identity function "
"(i.e. the function which makes no changes) at this key, and therefore is "
"equal to ``Read``. Notably we cannot simply remove the transfrom from the "
"map because the key was still used in some way during the computation. We "
"must have a record of what keys were used to correctly detect when deploys "
"commute (see the following sections for more details). Replacing a ``Write``"
" with a ``Read`` still has great benefits for parallel exectuion because "
"reads do commute with one another, while writes do not. This optimization in"
" the reduced traces is `applied in our reference implementation "
"<https://github.com/CasperLabs/casper-"
"node/blob/master/execution_engine/src/core/engine_state/execution_result.rs#L439>`__."
msgstr ""
"Il existe un cas particulier de construction de traces réduites qui mérite "
"d'être signalé explicitement. Supposons que la valeur initiale d'une clé "
"dans l'état global soit ``X``, et qu'après avoir effectué l'exécution, la "
"transformation pour cette clé soit ``Write(X)``. Il est alors valide de "
"remplacer cette transformation par \"Read\". En effet, le calcul agit comme "
"la fonction d'identité (c'est-à-dire la fonction qui n'apporte aucun "
"changement) sur cette clé, et est donc égal à``Read``. Notamment, nous ne "
"pouvons pas simplement supprimer la transformation de la 'map' parce que la "
"clé a encore été utilisée d'une certaine manière pendant le calcul. Nous "
"devons avoir un historique des clés utilisées pour détecter correctement "
"quand les déploiements commuent (voir les sections suivantes pour plus de "
"détails).. Remplacer une ``Write`` par une ``Read`` a toujours de grands "
"avantages pour l'exécution parallèle parce que les lectures commutent entre "
"elles, alors que les écritures ne le font pas. Cette optimisation dans les "
"traces réduites est `appliquée dans notre implémentation de référence "
"<https://github.com/CasperLabs/casper-"
"node/blob/master/execution_engine/src/core/engine_state/execution_result.rs#L439>`__."

#: ../../implementation/appendix.rst:172
msgid "Constructing the post-state from parallel execution"
msgstr "Construire le post-état à partir de l'exécution parallèle"

#: ../../implementation/appendix.rst:174
msgid ""
"Following from the previous section, we know that deploys execute to produce"
" a ``Map<Key, Transform>`` which gives a summary (i.e. \"reduced trace\") of"
" the effects the deploy would have had on each key in the global state (keys"
" not present in the map are not effected). In the reference implementation "
"we call this the ``exec`` phase. Since creating these maps does not mutate "
"the global state, we can run as many of these as we want in parallel. "
"However, after they have been run we need to actually produce a post-state, "
"the new global state after applying the effects of the deploys (this will "
"then be used as the pre-states for deploys in the following batch of "
"executions). In the reference implementation, we call applying the "
"collection of transforms to obtain a post-state the ``commit`` phase."
msgstr ""
"Suite à la section précédente, nous savons que les déploiements s'exécutent "
"pour produire une map : ``Map<Key, Transform>`` qui donne un résumé (i.e. "
"une \"trace réduite\") des effets que le déploiement aurait eu sur chaque "
"clé dans l'état global (les clés non présentes dans la map ne sont pas "
"affectées). Dans l'implémentation de référence, nous appelons cela la phase "
"``exec``. Puisque la création de ces 'maps' ne modifie pas l'état global, "
"nous pouvons en exécuter autant que nous le souhaitons en parallèle. "
"Cependant, après leur exécution, nous devons produire un post-état, le "
"nouvel état global après avoir appliqué les effets des déploiements (il sera"
" ensuite utilisé comme pré-état pour les déploiements dans le lot suivant "
"d'exécutions). Dans l'implémentation de référence, nous appelons "
"l'application de la collection de transformations pour obtenir un post-état "
"la phase ``commit``."

#: ../../implementation/appendix.rst:186
msgid ""
"Before we can construct the post-state, we must know that one is well-"
"defined. When working with parallel execution with a shared resource, you "
"may encounter \"race conditions\". This is a situation where the outcome of "
"a parallel computation depends on the order or timing of events, in "
"particular when this timing is not explicitly controlled. Or phrased another"
" way, parallelism with a shared resource is a lie and one of the processes "
"will use the resource first, followed by the other one. A classic blockchain"
" example of a race condition is a double spend (which under an accounts "
"model, as opposed to UTXO, is the same as an overdraft on the account); one "
"payer attempts to pay two payees at the same time without enough tokens to "
"actually pay both. One payee or the other is not getting their tokens, "
"depending on the order the transactions are processed."
msgstr ""
"Avant de pouvoir construire le post-état, nous devons vérifier qu'il est "
"bien défini. Lorsque vous travaillez en exécution parallèle avec une "
"ressource partagée, vous pouvez rencontrer des \"race conditions\". Il "
"s'agit d'une situation où le résultat d'un calcul parallèle dépend de "
"l'ordre ou de la synchronisation des événements, en particulier lorsque "
"cette synchronisation n'est pas explicitement contrôlée. Formulé autrement, "
"le parallélisme avec une ressource partagée est un 'mensonge' et l'un des "
"processus utilisera la ressource en premier, suivi par l'autre. Un exemple "
"classique de \"race conditions\" sur la blockchain est la double dépense "
"(qui, dans le cadre d'un modèle de compte, par opposition à UTXO, équivaut à"
" un découvert sur le compte) ; un payeur tente de payer deux bénéficiaires "
"en même temps sans avoir assez de jetons pour payer les deux. L'un ou "
"l'autre des bénéficiaires ne reçoit pas ses jetons, selon l'ordre dans "
"lequel les transactions sont traitées."

#: ../../implementation/appendix.rst:200
msgid ""
"In our simple model of computation where deploys are functions on the global"
" state, this would correspond to functions that do not *commute*, that is to"
" say, the order in which we apply the functions to the global state matters:"
" :math:`f \\circ g \\not= g \\circ f`. Therefore, in order to prevent race "
"conditions, we will only allow deploys to execute in parallel if they "
"commute. Taking our more sophisticated model of computation, we have two "
"deploys: :math:`f: G \\rightarrow End(G)` and :math:`g: G \\rightarrow "
"End(G)`, and we will only allow both be committed to the same pre-state "
":math:`G` if :math:`f(G) \\circ g(G) = g(G) \\circ f(G)`, i.e. the resulting"
" maps of transforms commute."
msgstr ""
"Dans notre modèle simple de calcul où les déploiements sont des fonctions "
"sur l'état global, cela correspondrait à des fonctions qui ne *commutent* "
"pas, c'est-à-dire que l'ordre dans lequel nous appliquons les fonctions à "
"l'état global a de l'importance: :math:`f \\circ g \\not= g \\circ f`. Par "
"conséquent, afin d'éviter les situations de concurrence 'race conditions', "
"nous n'autoriserons les déploiements à s'exécuter en parallèle que s'ils "
"'commutent'. En prenant notre modèle de calcul plus sophistiqué, nous avons "
"deux déploiements: :math:`f: G \\rightarrow End(G)` and :math:`g: G "
"\\rightarrow End(G)`, et nous ne permettrons que les deux soient affectés au"
" même pré-état. :math:`G` if :math:`f(G) \\circ g(G) = g(G) \\circ f(G)`, "
"i.e. les 'maps' de 'transforms' résultantes commutent."

#: ../../implementation/appendix.rst:212
msgid ""
"We will discuss how to compute whether two maps of transforms commute in the"
" next section. For now, we assume that run some set of deploys :math:`d_1, "
"d_2, d_3, \\ldots` in parallel against a fixed pre-state :math:`G` to obtain"
" a set of transform maps :math:`T_1, T_2, T_3, \\ldots`, then select only "
"the transforms that commute :math:`T_i, T_j, T_k, \\ldots` to apply to "
":math:`G`, and thus obtain the post-state :math:`G^\\prime`. The remaining "
"deploys we can all run in parallel against :math:`G^\\prime`, again choosing"
" the commuting ones to commit, obtaining :math:`G^{\\prime\\prime}`, and so "
"on. This final post-state is the same as if we had run all the deploys "
":math:`d_1, d_2, d_3, \\ldots` in sequence against :math:`G`, but perhaps "
"faster (depending on how many could commute [#]_) because we were able to "
"run in parallel batches."
msgstr ""
"Nous verrons dans la section suivante comment calculer si deux maps de "
"transformées commutent. Pour l'instant, nous supposons que l'on exécute un "
"ensemble de déploiements :math:`d_1, d_2, d_3, \\ldots` en parallèle sur un "
"pré-état fixe :math:`G` pour obtenir un ensemble de maps de transformées "
":math : `T_1, T_2, T_3, \\ldots`, puis sélectionner uniquement les "
"transformées qui commutent :math:`T_i, T_j, T_k, \\ldots` pour les appliquer"
" à :math:`G`, et ainsi obtenir le post-état :math:`G^\\prime`. Les "
"déploiements restants peuvent tous être exécutés en parallèle avec "
":math:`G^\\prime`, en choisissant à nouveau ceux à commuter, pour obtenir "
":math:`G^{\\prime\\prime}`, et ainsi de suite. Cet état final est le même "
"que si nous avions exécuté tous les déploiements :math:`d_1, d_2, d_3, "
"\\ldots` en séquence avec :math:`G`, mais peut-être plus rapidement (selon "
"le nombre de ceux qui ont pu commuter [#]_) parce que nous avons pu les "
"exécuter en lots parallèles."

#: ../../implementation/appendix.rst:226
msgid ""
"Recall that committing transforms is a very fast operation relative to "
"execution, so it causes little overhead. The main overhead would come from "
"executing the same deploy against multiple different starting states because"
" it failed to commute multiple times. This can be mitigated by favoring "
"including more expensive deploys in each committed batch."
msgstr ""
"Rappelons que la commutation des transformées est une opération très rapide "
"par rapport à l'exécution, et qu'elle entraîne donc peu de surcharge. La "
"principale surcharge proviendrait de l'exécution du même déploiement contre "
"plusieurs états de départ différents parce qu'il a échoué à commuter "
"plusieurs fois. Ceci peut être atténué en favorisant l'inclusion des "
"déploiements les plus coûteux dans chaque lot commité."

#: ../../implementation/appendix.rst:234
msgid "Detecting when maps of transforms commute"
msgstr "Détecter quand les maps de transformées commutent"

#: ../../implementation/appendix.rst:236
msgid ""
"Two transform maps ``m_1: Map<Key, Transform>`` and ``m_2: "
"Map<Key,Transform>`` commute if for all keys ``k`` which are present in both"
" maps, the transforms ``t_1 = m_1[k]`` and ``t_2 = m_2[k]`` commute. "
"Notably, if there are no such keys then the maps trivially commute. Two "
"transforms ``t_1:Transform`` and ``t_2: Transform`` commute if:"
msgstr ""
"Deux maps de transformées ``m_1 : Map<Key, Transform>`` et ``m_2 : "
"Map<Key,Transform>`` commuent si pour toutes les clés ``k`` qui sont "
"présentes dans les deux maps, les transformées ``t_1 = m_1[k]`` et ``t_2 = "
"m_2[k]`` commutent. Notamment, s'il n'y a pas de telles clés, alors les maps"
" sont trivialement commutées. Deux transformées ``t_1:Transform`` et ``t_2 :"
" Transform`` commutent si :"

#: ../../implementation/appendix.rst:242
msgid "``t_1 == t_2 == Read``"
msgstr "``t_1 == t_2 == Read``"

#: ../../implementation/appendix.rst:243
msgid ""
"``t_1`` and ``t_2`` are both of the same ``Add*`` transform variant (note "
"they do not need to contain the same values within that variant)"
msgstr ""
"``t_1`` et ``t_2`` sont tous deux de la même variante de transformation "
"``Add*`` (notez qu'ils ne doivent pas nécessairement contenir les mêmes "
"valeurs au sein de cette variante)"

#: ../../implementation/appendix.rst:247
msgid ""
"where ``Add*`` is a placeholder representing any of the typed native add "
"operations (``AddInt32``, ``AddInt64``, ``AddInt128``, ``AddInt256``, "
"``AddInt512``, ``AddKeys``).  And they do not commute otherwise. A short "
"montra for this is: reads commute, adds commute, writes conflict. Note that "
"writes *always* conflict, even if they are writing the same value. Consider "
"the following example:"
msgstr ""
"où ``Add*`` est un placeholder générique représentant l'une des opérations "
"d'addition natives typées (``AddInt32``, ``AddInt64``, ``AddInt128``, "
"``AddInt256``, ``AddInt512``, ``AddKeys``). Et ils ne commutent pas "
"autrement. Un petit exemple de cela est : les lectures commutent, les ajouts"
" commutent, les écritures entrent en conflit. Notez que les écritures sont "
"*toujours* en conflit, même si elles écrivent la même valeur. Prenons "
"l'exemple suivant :"

#: ../../implementation/appendix.rst:270
msgid ""
"If the pre-state :math:`G` has ``local(\"x\") == 7`` then ``f(G)`` results "
"in the transform ``Write(10)``, and so does ``g(G)``. However, if we compose"
" ``g(f(G))`` then we obtain ``Write(100)``, and if we compose ``f(g(G))`` "
"then the result is ``Write(0)`` and hence the functions do not commute."
msgstr ""
"Si le pré-état :math:`G` a ``local(\"x\") == 7``, alors ``f(G)`` donne la "
"transformée ``Write(10)``, et ``g(G)`` aussi. Cependant, si on compose "
"``g(f(G))`` alors on obtient ``Write(100)``, et si on compose ``f(g(G))`` "
"alors le résultat est ``Write(0)`` et donc les fonctions ne commuent pas."

#: ../../implementation/appendix.rst:277
msgid "Handling Errors"
msgstr "Traitement des erreurs"

#: ../../implementation/appendix.rst:279
msgid ""
"The reason we can say \"adds commute\" in our rules is because "
"mathematically addition is commutative. However, this relies on the infinite"
" nature of the number line and real computers are finite. For example, if we"
" considered the addition of three 8-bit numbers: 250, 3, and 5, any two of "
"them can be added and they commute, but attempting to add all three results "
"in an overflow error. Thus the final result depends on the order of "
"addition:"
msgstr ""
"La raison pour laquelle nous pouvons dire \"les additions commutent\" dans "
"nos règles est que, mathématiquement, l'addition est commutative. Cependant,"
" cela repose sur la nature infinie des nombres et les ordinateurs réels sont"
" finis. Par exemple, si nous considérons l'addition de trois nombres de 8 "
"bits : 250, 3 et 5, deux d'entre eux peuvent être ajoutés et ils sont "
"commutatifs, mais si l'on tente d'ajouter les trois, on obtient une erreur "
"de débordement. Ainsi, le résultat final dépend de l'ordre d'addition :"

#: ../../implementation/appendix.rst:286
msgid "250 + 3 + 5 = 253 (last addition does not happen due to the error)"
msgstr ""
"250 + 3 + 5 = 253 (le dernier ajout ne se fait pas à cause de l'erreur)"

#: ../../implementation/appendix.rst:287
msgid "250 + 5 + 3 = 255"
msgstr "250 + 5 + 3 = 255"

#: ../../implementation/appendix.rst:288
msgid "3 + 5 + 250 = 8"
msgstr "3 + 5 + 250 = 8"

#: ../../implementation/appendix.rst:290
msgid ""
"Presently we circumvent this error by actually using modular arithmetic "
"(wrapped addition as it is often called in computer science). Addition in "
"modular arithmetic is still a commutative operation, so our theory holds "
"together. In our example above 250 + 5 + 3 is always equal to 3, no matter "
"what. However in the context of financial applications wrapping back to zero"
" is an unexpected behavior. For this reason we use 512-bit numbers in our "
"mint contract to represent balances, and the total number of token units "
"(motes) available is less than ``U512::MAX``, so overflow is impossible."
msgstr ""
"Actuellement, nous contournons cette erreur en utilisant l'arithmétique "
"modulaire ('wrapped addition' comme on l'appelle souvent en informatique). "
"L'addition dans l'arithmétique modulaire est toujours une opération "
"commutative, de sorte que notre théorie tient la route. Dans notre exemple "
"ci-dessus, 250 + 5 + 3 est toujours égal à 3, quoi qu'il arrive. Cependant, "
"dans le contexte des applications financières, le retour à zéro est un "
"comportement inattendu. Pour cette raison, nous utilisons des nombres de 512"
" bits dans notre contrat de 'mint' pour représenter les soldes, et le nombre"
" total d'unités de jetons (motes) disponibles est inférieur à ``U512::MAX``,"
" de sorte que le débordement est impossible."

#: ../../implementation/appendix.rst:299
msgid ""
"That said, this is not the only error which may arise due to the finite "
"nature of computers. For example, the ``AddKeys`` transform is about adding "
"elements to a map, which is a commutative operation as well (so long as none"
" of the keys already existed in the map, then it is more akin to a write "
"operation). Yet, this operation can also fail due to the physical machine "
"being out of memory, thus once again meaning the order of additions could "
"effect the final state of the map."
msgstr ""
"Cela dit, ce n'est pas la seule erreur qui peut survenir en raison de la "
"nature finie des ordinateurs. Par exemple, la transformation ``AddKeys`` "
"consiste à ajouter des éléments à une map, ce qui est aussi une opération "
"commutative (tant qu'aucune des clés n'existe déjà dans la map, alors cela "
"ressemble plus à une opération d'écriture). Cependant, cette opération peut "
"également échouer si la machine physique manque de mémoire, ce qui signifie "
"une fois de plus que l'ordre des ajouts peut affecter l'état final de la "
"map."

#: ../../implementation/appendix.rst:307
msgid ""
"In a more powerful theory of parallel execution we could consider operations"
" which fail. In this case we could say that transforms ``t_1`` and ``t_2`` "
"commute if they are of the same addition type and the outcome of applying "
"both to the input global state, :math:`G` is not an error. This is a more "
"complex rule because it requires doing some amount of computation during "
"commutativity checking, whereas the previous theory was simple comparison. "
"Yet, this theory might be worth pursuing because it solves the two problems "
"we have listed here (overflow and out-of-memory), along with other problems "
"that we presently cannot handle at all. For example, ``Minus`` could be "
"introduced as a transform, and underflows could be handled using this "
"refined commutativity rule. This has practical application in our system "
"because it would mean transfers from the same source could commute if enough"
" funds are available, whereas presently they will always be conservatively "
"labeled as not commuting."
msgstr ""
"Dans une théorie plus puissante de l'exécution parallèle, nous pourrions "
"considérer les opérations qui échouent. Dans ce cas, nous pourrions dire que"
" les transformées ``t_1`` et ``t_2`` commutent si elles sont du même type "
"d'addition et que le résultat de leur application à l'état global d'entrée, "
":math:`G`, n'est pas une erreur. Il s'agit d'une règle plus complexe car "
"elle nécessite d'effectuer un certain nombre de calculs pendant la "
"vérification de la commutativité, alors que la théorie précédente était une "
"simple comparaison. Pourtant, cette théorie pourrait valoir la peine d'être "
"poursuivie car elle résout les deux problèmes que nous avons énumérés ici "
"(overflow et out-of-memory), ainsi que d'autres problèmes que nous ne "
"pouvons actuellement pas du tout gérer. Par exemple, ``Minus`` pourrait être"
" introduit comme une transformation, et les 'underflows' pourraient être "
"gérés en utilisant cette règle de commutativité raffinée. Cela a une "
"application pratique dans notre système car cela signifierait que les "
"transferts de la même source pourraient commuter si suffisamment de fonds "
"sont disponibles, alors qu'actuellement ils seront toujours étiquetés de "
"manière conservatrice comme ne commutant pas."
