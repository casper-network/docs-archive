# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, CasperLabs LLC
# This file is distributed under the same license as the CasperLabs Tech
# Spec package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
# 
# Translators:
# ilker <bilkerarslan40@gmail.com>, 2021
# Muhammet Kara <muhammet.kara@metu.edu.tr>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CasperLabs Tech Spec\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-26 20:13+0000\n"
"PO-Revision-Date: 2021-06-26 21:48+0000\n"
"Last-Translator: Muhammet Kara <muhammet.kara@metu.edu.tr>, 2021\n"
"Language-Team: Turkish (https://www.transifex.com/caspernetwork/teams/122124/tr/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Language: tr\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../theory/naive-blockchain.rst:2
msgid "Naive Casper Blockchain"
msgstr "Naif Casper Blokzinciri"

#: ../../theory/naive-blockchain.rst:5 ../../theory/naive-blockchain.rst:100
msgid "Introduction"
msgstr "Giriş"

#: ../../theory/naive-blockchain.rst:7
msgid ""
"Blockchain is a P2P network where the collection of nodes (**validators**) "
"concurrently update a decentralized, shared database. They do this by "
"collectively building an ever-growing chain of **transactions**. For "
"performance reasons transactions are bundled in **blocks**."
msgstr ""
"Blokzincir, düğümlerin (**doğrulayıcılar**), aynı anda merkeziyetsiz, "
"paylaşılan bir veritabanını güncellediği bir P2P ağıdır. Bunu, sürekli "
"büyüyen bir **işlemler** zinciri oluşturarak topluca yaparlar. Performans "
"nedenleriyle işlemler **bloklar** halinde gruplandırılmıştır."

#: ../../theory/naive-blockchain.rst:9
msgid ""
"For the “outside world”, the blockchain looks like a computer. This "
"blockchain computer has a memory (= shared database) and can execute "
"programs (= transactions). Execution of a program changes the state of the "
"memory. Anybody can send a program to the computer and the computer will do "
"a best effort attempt to execute this program."
msgstr ""
"“Dış dünya” için blokzincir bir bilgisayara benziyor. Bu blokzincir "
"bilgisayarın bir hafızası vardır (= paylaşılan veritabanı) ve programları "
"çalıştırabilir (= işlemler). Bir programın yürütülmesi belleğin durumunu "
"değiştirir. Herhangi biri bilgisayara bir program gönderebilir ve bilgisayar"
" bu programı yürütmek için elinden gelenin en iyisini yapacaktır."

#: ../../theory/naive-blockchain.rst:11
#, python-format
msgid ""
"We say that a blockchain computer is **decentralized**, i.e. there is no "
"single point of failure in the infrastructure. A significant portion of the "
"network of validators could be suddenly destroyed and nevertheless the "
"blockchain will continue to work. Also, the system is resistant to malicious"
" validators (as long as the total weight of malicious validators is below "
"50% of the total weight of all validators)."
msgstr ""
"Bir blokzincir bilgisayarının **merkeziyetsiz** olduğunu söylüyoruz, yani "
"altyapıda tek bir arıza noktası yok. Doğrulayıcılar ağının önemli bir kısmı "
"aniden yok edilebilir ve yine de blokzincir çalışmaya devam edecektir. "
"Ayrıca, sistem kötü niyetli doğrulayıcılara karşı dirençlidir (kötü niyetli "
"doğrulayıcıların toplam ağırlığı, tüm doğrulayıcıların toplam ağırlığının "
"%50'sinin altında olduğu sürece)."

#: ../../theory/naive-blockchain.rst:13
msgid ""
"The core of blockchain mechanics is the continuous work of validators "
"struggling to agree on a consistent history of programs executed on the "
"blockchain computer. We describe this central idea as “achieving "
"**consensus** on the chain of blocks”. Because every block contains a chain "
"of transactions, this “consistent history” results in being a sequence of "
"transactions."
msgstr ""
"Blokzincir mekaniğinin özü, blokzincir bilgisayarında yürütülen programların"
" tutarlı bir geçmişi üzerinde anlaşmaya varmak için mücadele eden "
"doğrulayıcıların sürekli çalışmasıdır. Bu ana fikri “bloklar zinciri "
"üzerinde **mutabakata** ulaşmak” olarak tanımlıyoruz. Her blok bir işlem "
"zinciri içerdiğinden, bu “tutarlı geçmiş” bir işlemler dizisi olarak "
"sonuçlanır."

#: ../../theory/naive-blockchain.rst:15
msgid ""
"Note that in this spec we use the terms **shared database** and **blockchain"
" computer memory** interchangeably."
msgstr ""
"Bu belirtimde **paylaşılan veritabanı** ve **blokzincir bilgisayar belleği**"
" terimlerini birbirinin yerine kullandığımızı unutmayınız."

#: ../../theory/naive-blockchain.rst:18
msgid "Computing model"
msgstr "Bilgi işlem modeli"

#: ../../theory/naive-blockchain.rst:21
msgid "Memory and programs"
msgstr "Bellek ve programlar"

#: ../../theory/naive-blockchain.rst:23
msgid ""
"We need to define the “computational semantics” of a blockchain computer; "
"what programs are and how they execute. However, because the consensus "
"protocol we introduce is compatible with a wide range of computing models, "
"it is convenient to approach this abstractly. Therefore, we represent the "
"“computational semantics” of a blockchain computer as a triple "
":math:`\\langle GS, Zero, P\\rangle` where:"
msgstr ""
"Bir blokzincir bilgisayarının “hesaplamalı semantiğini” tanımlamamız "
"gerekiyor; programlar nedir ve nasıl yürütülür. Ancak, tanıttığımız "
"mutabakat protokolü çok çeşitli hesaplama modelleriyle uyumlu olduğundan, "
"buna teorik olarak yaklaşmak uygundur. Bu nedenle, bir blokzincir "
"bilgisayarının \"hesaplamalı semantiğini\" üçlü bir :math:`\\langle GS, "
"Zero, P\\rangle` olarak temsil ediyoruz ki burada:"

#: ../../theory/naive-blockchain.rst:29
msgid ""
":math:`GS` is a set of states of the shared database (think that each point "
":math:`gs \\in GS` represents a “snapshot” of the shared database) we call "
"“global states”"
msgstr ""
":math:`GS`, \"küresel durumlar\" dediğimiz, paylaşılan veritabanının bir "
"dizi durumudur (her :math:`gs \\in GS` 'nin paylaşılan veritabanının bir "
"\"anlık görüntüsünü\" temsil ettiğini düşünün)"

#: ../../theory/naive-blockchain.rst:30
msgid ":math:`Zero \\in GS` is the initial state of the database"
msgstr ":math:`Zero \\in GS`  veritabanının ilk durumudur"

#: ../../theory/naive-blockchain.rst:31
msgid ""
":math:`P \\subset Partial(GS \\rightarrow GS)` is a non-empty set of partial"
" functions from :math:`GS` to :math:`GS`, closed under composition; elements"
" of :math:`P` we call **transactions** (we think of them as “executable "
"programs”)"
msgstr ""
":math:`P \\subset Partial(GS \\rightarrow GS)`, :math:`GS` den :math:`GS` ye"
" kısmi fonksiyonların boş olmayan kümesidir, bileşimi kapalıdır,  :math:`P` "
"'nin elemanlarına **işlemler** (onları \"çalıştırılabilir programlar\" "
"olarak düşünüyoruz) diyoruz.  "

#: ../../theory/naive-blockchain.rst:33
msgid ""
"Given a state :math:`gs \\in GS` and a transaction :math:`p \\in P`, we can "
"calculate the value :math:`p(gs)` only in the case when :math:`p` is defined"
" at :math:`gs`. We refer to this as **the execution of p**."
msgstr ""
":math:`gs \\in GS`  ve :math:`p \\in P` durumları verildiğinde, "
":math:`p(gs)` değerini sadece :math:`p` :math:`gs` 'de tanımlandığında "
"hesaplayabiliriz. Bunu **p'nin yürütülmesi** olarak adlandırıyoruz."

#: ../../theory/naive-blockchain.rst:35
msgid ""
"When :math:`p` is not defined at point :math:`gs`, we say that **execution "
"of p on state gs failed**. This is how we represent errors in program "
"execution."
msgstr ""
":math:`p`, :math:`gs` noktasında tanımlanmadığında, **p'nin gs durumunda "
"yürütülmesinin başarısız olduğunu** söyleriz. Program yürütmedeki hataları "
"bu şekilde tarif ediyoruz."

#: ../../theory/naive-blockchain.rst:38
msgid "Executing sequences of transactions"
msgstr "İşlem dizilerinin yürütülmesi"

#: ../../theory/naive-blockchain.rst:40
msgid ""
"We want to generalize this notion to sequences of transactions in such a way"
" that the information on execution errors is retained."
msgstr ""
"Bu kavramı, yürütme hataları hakkındaki bilgilerin korunacağı şekilde işlem "
"dizilerine genelleştirmek istiyoruz."

#: ../../theory/naive-blockchain.rst:42
msgid ""
"Having a sequence of transactions :math:`p_1, p_2, ...., p_n\\in P` we'll "
"keep the information on execution success/error as a function :math:`status:"
" [1,2,...,n] \\rightarrow \\{false, true\\}`."
msgstr ""
" :math:`p_1, p_2, ...., p_n\\in P` bir dizi işlem verilmiş olsun, yürütme "
"başarısı/ hatası bilgisini, :math:`status: [1,2,...,n] \\rightarrow "
"\\{false, true\\}` fonksiyonu halinde saklayacağız."

#: ../../theory/naive-blockchain.rst:44
msgid ""
"For any :math:`p \\in P` let :math:`\\triangle p: GS \\rightarrow GS` be a "
"total function that extends :math:`p` by applying identity whenever "
":math:`p` is not defined, hence formally as:"
msgstr ""
"Herhangi bir :math:`p \\in P` için, :math:`\\triangle p: GS \\rightarrow "
"GS`, p tanımlanmadığında özdeşlik uygulayarak p'yi genişleten bir toplam "
"fonksiyon olsun, dolayısıyla daha resmi şekliyle:"

#: ../../theory/naive-blockchain.rst:46
msgid ""
"\\triangle p(x)=\\begin{cases}\n"
"p(x), & x \\in dom(p)\\\\\n"
"x, & otherwise\n"
"\\end{cases}"
msgstr ""
"\\triangle p(x)=\\begin{cases}\n"
"p(x), & x \\in dom(p)\\\\\n"
"x, & yoksa\n"
"\\end{cases}"

#: ../../theory/naive-blockchain.rst:54
msgid ""
"**Status(i)** represents the overall result (success vs failure) of the "
"execution of **i-th** transaction in the sequence."
msgstr ""
"**Durum(i)**, sırayla **i'inci** işleminin yürütülmesinin genel sonucunu "
"(başarısızlık veya başarı) temsil eder."

#: ../../theory/naive-blockchain.rst:56
msgid "Let:"
msgstr "Şu şekilde alır isek:"

#: ../../theory/naive-blockchain.rst:58
msgid ""
":math:`TSeq` be the set of finite sequences of transactions: :math:`TSeq = "
"P^{Int}`"
msgstr ""
":math:`TSeq` sonlu işlem dizileri kümesi olsun: :math:`TSeq = P^{Int}`"

#: ../../theory/naive-blockchain.rst:59
msgid ":math:`StatusTraces` be the set of finite sequences of Booleans"
msgstr ":math:`StatusTraces` Boolean sonlu dizileri kümesi olsun"

#: ../../theory/naive-blockchain.rst:61
msgid "We define the execution of a sequence of transactions as:"
msgstr "Bir dizi işlemin yürütülmesini şu şekilde tanımlarız:"

#: ../../theory/naive-blockchain.rst:63
msgid ""
"exec: GS \\times TSeq \\rightarrow GS \\times StatusTraces \\\\\n"
"exec(gs, [p1, p2, ...., pn]) = (resultGS, trace)"
msgstr ""
"exec: GS \\times TSeq \\rightarrow GS \\times StatusTraces \\\\\n"
"exec(gs, [p1, p2, ...., pn]) = (resultGS, trace)"

#: ../../theory/naive-blockchain.rst:69
msgid "… where:"
msgstr "… ki burada:"

#: ../../theory/naive-blockchain.rst:71
msgid ""
":math:`resultGS = \\Delta pn \\circ \\Delta pn-1 \\circ ... \\circ \\Delta "
"p1 (gs)`"
msgstr ""
":math:`resultGS = \\Delta pn \\circ \\Delta pn-1 \\circ ... \\circ \\Delta "
"p1 (gs)`"

#: ../../theory/naive-blockchain.rst:72
msgid ""
":math:`trace(i) = \\begin{cases} false, & execution \\space of \\space p_i "
"\\space failed \\\\ true, & otherwise \\end{cases}`"
msgstr ""
":math:`trace(i) = \\begin{cases} yanlış, & p_i \\space 'ın \\space \\space "
"yürütülmesi başarısız \\\\ doğru, & yoksa \\end{cases}`"

#: ../../theory/naive-blockchain.rst:74
msgid ""
"Intuitively, **exec** takes a pair - the initial global state and a sequence"
" of transactions to execute. The result is also a pair - the resulting "
"global state reached by sequentially applying all transactions and a trace "
"of this execution saying which transactions failed along the way."
msgstr ""
"Sezgisel olarak, **exec** bir çift alır - ilk küresel durum ve yürütülecek "
"bir işlem dizisi. Sonuç da bir çifttir - tüm işlemlerin sırayla "
"uygulanmasıyla ulaşılan sonuçtaki küresel durum ve yol boyunca hangi "
"işlemlerin başarısız olduğunu söyleyen bu yürütmenin bir izi."

#: ../../theory/naive-blockchain.rst:77
msgid "Executing sequences of blocks"
msgstr "Blok dizilerinin yürütülmesi"

#: ../../theory/naive-blockchain.rst:79
msgid ""
"A block contains sequences of transactions. Given some initial global state "
":math:`gs \\in GS`, whenever we say “execute a block” we mean executing the "
"sequence of transactions it contains starting from :math:`gs`. We usually "
"call :math:`gs` the **pre-state** of the block, and we say **post-state** to"
" denote the resulting global state returned by :math:`exec(gs, sequence)`."
msgstr ""
"Bir blok, işlem dizilerini içerir. :math:`gs \\in GS` ilk küresel durumu "
"verildiğinde, \"bir bloğun yürütülmesi\" dediğimizde :math:`gs` 'den "
"başlayarak içerdiği işlem dizisini yürütmekten bahsediyoruz. Genellikle "
":math:`gs` 'ye bloğun **ön durumu** deriz, ve :math:`exec(gs, sequence)` "
"tarafından döndürülen sonuç kürüsel durumuna da bloğun **durum sonrası** "
"deriz."

#: ../../theory/naive-blockchain.rst:81
msgid ""
"Given any sequence of blocks we may also **execute the sequence of blocks** "
"because it is effectively a sequence of sequences of transactions, so it may"
" be flattened to a single sequence of transactions."
msgstr ""
"Herhang bir blok dizisi alalım, aynı zamanda **blok dizisini de "
"yürütebiliriz** çünkü bu fiilen bir işlem dizilerinin dizisidir, bu nedenle "
"tek bir işlem dizisine düzleştirilebilir."

#: ../../theory/naive-blockchain.rst:83
msgid ""
"Given any set of blocks :math:`B`, we sometimes consider different linear "
"orders of such set. Given a linear order :math:`R` on set :math:`B`, we are "
"speaking about **executing the set of blocks B along linear order R**, with "
"the obvious semantics of taking all the blocks, arranging them in a sequence"
" following the order :math:`R`, and then executing the resulting sequence of"
" transactions."
msgstr ""
"Herhangi bir :math:`B` blok kümesi verildiğinde, bazen bu kümenin farklı "
"doğrusal sıralamalarını dikkate alırız. :math:`B` kümesinde :math:`R` "
"doğrusal sıralaması verildiğinde, üm blokların alınıp :math:`R` sıralamasını"
" takip edecek şekilde düzenlendiği ve sonrasında elde edilen işlem dizisinin"
" yürütüldüğü **R doğrusal sıralamasında B blok kümesinin yürütülmesi**nden "
"bahsediyoruzdur."

#: ../../theory/naive-blockchain.rst:86
msgid "Blockchain participants"
msgstr "Blokzincir katılımcıları"

#: ../../theory/naive-blockchain.rst:88
msgid ""
"We envision the infrastructure of blockchain participants as a collection of"
" actors (processes) communicating over a network, and where each process "
"plays one of the following roles:"
msgstr ""
"Blokzincir katılımcılarının altyapısını, bir ağ üzerinden iletişim kuran ve "
"her sürecin aşağıdaki rollerden birini oynadığı bir aktörler (süreçler) "
"topluluğu olarak öngörüyoruz:"

#: ../../theory/naive-blockchain.rst:90
msgid ""
"**validators (aka “ring 0”)** - form a P2P network that attempts to reach "
"consensus on the ever-growing history of executed transactions; they do this"
" by creating and validating blocks"
msgstr ""
"**doğrulayıcılar (“halka 0” olarak da bilinirler)** - yürütülen işlemlerin "
"sürekli büyüyen geçmişi üzerinde mutabakata varmaya çalışan bir P2P ağı "
"oluşturur; bunu bloklar oluşturarak ve doğrulayarak yaparlar"

#: ../../theory/naive-blockchain.rst:91
msgid ""
"**finalizers (aka “ring 1”)** - they observe validators and try to deduce "
"the subset of history that is considered as “confirmed” (the “confirmed” "
"predicate is parameterized so to reflect the expected trust level)"
msgstr ""
"**kesinleştiriciler (diğer adıyla “halka 1”)** - doğrulayıcıları gözlemler "
"ve “onaylanmış” olarak kabul edilen geçmişin alt kümesini çıkarmaya "
"çalışırlar (“onaylanmış” dayanak, beklenen güven düzeyini yansıtacak şekilde"
" parametrelendirilir)"

#: ../../theory/naive-blockchain.rst:92
msgid ""
"**clients (aka “ring 2” or “dapps”)** - use the blockchain computer - they "
"send programs to be executed and react to execution results; a client "
"connects to a validator (one or many) to send transactions while it also "
"connects to a finalizer (one or many) to observe execution results"
msgstr ""
"**istemciler (“halka 2” veya “dapps” olarak da bilinir)** - blokzincir "
"bilgisayarını kullanırlar - yürütülecek programları gönderirler ve yürütme "
"sonuçlarına tepki verirler; bir istemci, işlem göndermek için doğrulayıcıya "
"(bir veya daha fazla) bağlanırken, yürütme sonuçlarını gözlemlemek için "
"kesinleştiriciye (bir veya daha fazla) bağlanır"

#: ../../theory/naive-blockchain.rst:95
msgid "Stake management"
msgstr "Hisse yönetimi"

#: ../../theory/naive-blockchain.rst:102
msgid ""
"In proof-of-stake blockchains, **stake** is a representation of the voting "
"power a validator has. We leave the question of exact representation of "
"stakes open. We only summarize here the minimal assumptions we need for the "
"mechanics of the blockchain to work."
msgstr ""
"Hisse kanıtı blokzincirlerinde **hisse**, doğrulayıcının sahip olduğu oylama"
" gücünün bir temsilidir. Hisselerin tam olarak temsili sorusunu açık "
"bırakıyoruz. Burada sadece blokzincirin mekaniğinin çalışması için ihtiyaç "
"duyduğumuz minimum varsayımları özetliyoruz."

#: ../../theory/naive-blockchain.rst:105
msgid "Encoding of stakes"
msgstr "Hisselerin kodlanması"

#: ../../theory/naive-blockchain.rst:107
msgid ""
"The main assumption is that a global state encodes (among other things) the "
"“weights map” - a mapping of validators to their voting power. So, "
"mathematically we expect the existence of a function that assigns to every "
"global state a function mapping validators to their weights:"
msgstr ""
"Ana varsayım, bir küresel durumun (diğer şeylerin yanı sıra) \"ağırlık "
"haritasını\" - doğrulayıcıların oylama güçleriyle eşleştirilmesini - "
"kodlamasıdır. Dolayısıyla, matematiksel olarak, her bir küresel durumda bir "
"fonksiyon eşleme doğrulayıcısını ağırlığına atayan bir fonksiyonun varlığını"
" bekliyoruz:"

#: ../../theory/naive-blockchain.rst:109
msgid ""
"weights\\_map: GS \\rightarrow Int^{ValidatorId} \\\\\n"
"weights\\_map(gs): ValidatorId \\rightarrow Int"
msgstr ""
"weights\\_map: GS \\rightarrow Int^{ValidatorId} \\\\\n"
"weights\\_map(gs): ValidatorId \\rightarrow Int"

#: ../../theory/naive-blockchain.rst:115
msgid ""
"Intuitively, the stake of a validator will be (usually) defined by the "
"amount of internal blockchain “money” allocated to the corresponding "
"account."
msgstr ""
"Sezgisel olarak, bir doğrulayıcının hissesi (genellikle) ilgili hesaba "
"tahsis edilen dahili blokzincir “parasının” miktarı ile tanımlanacaktır."

#: ../../theory/naive-blockchain.rst:118
msgid "Bonding and unbonding"
msgstr "Bağlama ve çözülme"

#: ../../theory/naive-blockchain.rst:120
msgid ""
"Blockchain users can increase/decrease the stake of a given validator. This "
"is to happen via executing (special) transactions."
msgstr ""
"Blokzincir kullanıcıları, belirli bir doğrulayıcının hissesini "
"artırabilir/azaltabilir. Bu, (özel) işlemlerin yürütülmesi yoluyla "
"gerçekleşecektir."

#: ../../theory/naive-blockchain.rst:122
msgid "Minimal stake **MIN_STAKE** is a parameter of the blockchain."
msgstr "Minimum hisse **MIN_STAKE**, blok zincirinin bir parametresidir."

#: ../../theory/naive-blockchain.rst:125
msgid "Unbonding stages"
msgstr "Çözülme aşamaları"

#: ../../theory/naive-blockchain.rst:127
msgid ""
"Unbonding is always a total unbonding -- a validator transitioning to "
"stake=0. There is no partial unbonding."
msgstr ""
"Çözülme her zaman tam bir çözülmedir -- bir doğrulayıcının hisse=0'a geçişi."
" Kısmi çözülme yoktur."

#: ../../theory/naive-blockchain.rst:129
msgid ""
"Unbonding must be go in stages, leading to the following states of a "
"validator:"
msgstr ""
"Çözülme, bir doğrulayıcının aşağıdaki durumlarına yol açacak şekilde, "
"aşamalar halinde yapılmalıdır:"

#: ../../theory/naive-blockchain.rst:131
msgid "STAKED"
msgstr "STAKED"

#: ../../theory/naive-blockchain.rst:132
msgid "VOTING_ONLY"
msgstr "VOTING_ONLY"

#: ../../theory/naive-blockchain.rst:133
msgid "UNBONDING_ESCROW"
msgstr "UNBONDING_ESCROW"

#: ../../theory/naive-blockchain.rst:134
msgid "ZEROED"
msgstr "ZEROED"

#: ../../theory/naive-blockchain.rst:136
msgid "While in STAKED, a validator can produce only blocks."
msgstr "STAKED durumundayken, bir doğrulayıcı yalnızca blok üretebilir."

#: ../../theory/naive-blockchain.rst:138
msgid "While in VOTING_ONLY, a validator can produce only ballots."
msgstr ""
"VOTING_ONLY aşamasındayken, bir doğrulayıcı yalnızca oy pusulası üretebilir."

#: ../../theory/naive-blockchain.rst:140
msgid ""
"While in UNBONDING_ESCROW and ZEROED, a validator is not supposed to produce"
" messages."
msgstr ""
"UNBONDING_ESCROW ve ZEROED durumundayken, bir doğrulayıcının mesaj üretmesi "
"beklenmez."

#: ../../theory/naive-blockchain.rst:142
msgid ""
"The how of transitioning between states is beyond the scope of this "
"specification (it can be based on wall clock, p-time, j-daglevel, block "
"generation and other approaches)."
msgstr ""
"Durumlar arasında geçişin nasıl yapılacağı bu spesifikasyonun kapsamı "
"dışındadır (duvar saati, p-zamanı, j-daglevel, blok üretimi ve diğer "
"yaklaşımlara dayalı olabilir)."

#: ../../theory/naive-blockchain.rst:145
msgid "Slashing"
msgstr "Kesme (slashing)"

#: ../../theory/naive-blockchain.rst:146
msgid ""
"Slashing is forced unbonding where the money used for the stake is burned. "
"The  intention is to penalizing equivocators."
msgstr ""
"Kesme, hisse için kullanılan paranın yakıldığı yerde zorla çözülür. Amaç, "
"şüphelileri cezalandırmaktır."

#: ../../theory/naive-blockchain.rst:150
msgid "Blockdag"
msgstr "Blockdag"

#: ../../theory/naive-blockchain.rst:154
msgid "Visual introduction"
msgstr "Görsel tanıtım"

#: ../../theory/naive-blockchain.rst:156
msgid ""
"The consensus protocol is based on a data structure we call a **blockdag**, "
"represented as a graph it looks like the following:"
msgstr ""
"Mutabakat protokolü, **blockdag** olarak adlandırdığımız ve aşağıdaki gibi "
"bir grafik olarak temsil edilen bir veri yapısına dayanmaktadır:"

#: ../../theory/naive-blockchain.rst:162
msgid "The meaning of symbols:"
msgstr "Sembollerin anlamları:"

#: ../../theory/naive-blockchain.rst:168
msgid "The 3 types of vertices in the graph are as follows:"
msgstr "Grafikteki 3 köşe noktası aşağıdaki gibidir:"

#: ../../theory/naive-blockchain.rst:170
msgid ""
"**normal blocks** - contain transactions to be executed against the "
"blockchain computer"
msgstr ""
"**normal bloklar** - blokzincir bilgisayarına karşı yürütülecek işlemleri "
"içerir"

#: ../../theory/naive-blockchain.rst:171
msgid ""
"**ballots** - do not contain transactions, but participate in the consensus"
msgstr "**oy pusulaları** - işlemleri içermez, ancak mutabakata katılır"

#: ../../theory/naive-blockchain.rst:172
msgid ""
"**genesis** - a special block that stands as a root node of the structure"
msgstr "**doğuş (genesis)** - yapının kök düğümü olarak duran özel bir blok"

#: ../../theory/naive-blockchain.rst:174
msgid "Additionally we say:"
msgstr "Ek olarak:"

#: ../../theory/naive-blockchain.rst:176
msgid "**block** - when we mean “normal block or genesis”"
msgstr "**blok** - \"normal blok veya doğuş\" ifade ederken"

#: ../../theory/naive-blockchain.rst:177
msgid "**message** - when we mean “normal block or ballot”"
msgstr "**mesaj** - “normal blok veya oy pusulası” derken"

#: ../../theory/naive-blockchain.rst:178
msgid "**vertex** - when we mean “normal block or ballot or genesis”"
msgstr "**köşe** - “normal blok veya oy pusulası veya doğuş” derken"

#: ../../theory/naive-blockchain.rst:180
msgid ""
"We visually mark the creator of a message by placing it in a relevant "
"swimlane. Genesis is outside swimlanes because genesis is given at "
"blockchain initialization (= it does not have a creator)."
msgstr ""
"Bir mesajın yaratıcısını ilgili bir kulvara yerleştirerek görsel olarak "
"işaretleriz. Doğuş kulvarların dışındadır çünkü doğuş blokzincirin "
"başlangıcında verilir (= bir yaratıcısı yoktur)."

#: ../../theory/naive-blockchain.rst:182
msgid ""
"Every normal block points to its **main parent** block (we visualize this "
"with red arrows). Hence, blocks form a tree we call the **main tree**."
msgstr ""
"Her normal blok, **ana üst öge** bloğuna işaret eder (bunu kırmızı oklarla "
"görselleştiririz). Dolayısıyla bloklar, **ana ağaç** dediğimiz bir ağaç "
"oluşturur."

#: ../../theory/naive-blockchain.rst:184
msgid ""
"Additionally, any normal block may point to an arbitrary number of blocks as"
" **secondary parents**. We visualize them with blue arrows. Blocks + red "
"arrows + blue arrows together form a directed acyclic graph we call **the "
"p-dag**."
msgstr ""
"Ek olarak, herhangi bir normal blok, **ikincil üst öge** olarak isteğe bağlı"
" sayıda bloğa işaret edebilir. Onları mavi oklarla görselleştiriyoruz. "
"Bloklar + kırmızı oklar + mavi oklar birlikte **p-dag** olarak "
"adlandırdığımız yönlendirilmiş çevrimsiz bir grafik oluşturur."

#: ../../theory/naive-blockchain.rst:186
msgid ""
"Any ballot points to exactly one block. We call this block “the target block"
" of a ballot”."
msgstr ""
"Herhangi bir oy pusulası tam olarak bir bloğa işaret eder. Bu bloğa “oy "
"pusulasının hedef bloğu” diyoruz."

#: ../../theory/naive-blockchain.rst:188
msgid ""
"Additionally, any message may point to an arbitrary number of vertices as "
"**additional justifications**. We visualize them with **dashed arrows**."
msgstr ""
"Ek olarak, herhangi bir mesaj **ek gerekçeler** olarak isteğe bağlı sayıda "
"köşeye işaret edebilir. Bunları **kesikli oklarla** görselleştiriyoruz."

#: ../../theory/naive-blockchain.rst:190
msgid ""
"All arrows together with all vertices form a directed acyclic graph we call "
"the **j-dag**."
msgstr ""
"Tüm oklar, tüm köşelerle birlikte **j-dag** olarak adlandırdığımız "
"yönlendirilmiş çevrimsiz bir grafik oluşturur."

#: ../../theory/naive-blockchain.rst:193
msgid "DAG vs POSET language"
msgstr "DAG ve POSET dili"

#: ../../theory/naive-blockchain.rst:195
msgid "DAG is a common abbreviation for “directed acyclic graph”."
msgstr "DAG, \"yönlendirilmiş çevrimsiz grafik\" için yaygın bir kısaltmadır."

#: ../../theory/naive-blockchain.rst:197
msgid "POSET is a common abbreviation for “partially ordered set”."
msgstr "POSET, “kısmen sıralı küme” için yaygın bir kısaltmadır."

#: ../../theory/naive-blockchain.rst:200
msgid ""
"When a DAG has at most one edge between any pair of vertices, we say this "
"DAG is “simple”."
msgstr ""
"Bir DAG, herhangi bir köşe çifti arasında en fazla bir kenara sahip "
"olduğunda, bu DAG'ın “basit” olduğunu söyleriz."

#: ../../theory/naive-blockchain.rst:202
msgid ""
"Any POSET can be seen as a simple DAG when you define an edge **a "
"\\rightarrow b** to be present whenever **a < b**."
msgstr ""
"Herhangi bir POSET, **a < b** olduğunda mevcut olacak bir kenar **a "
"\\rightarrow b** tanımladığınızda basit bir DAG olarak görülebilir."

#: ../../theory/naive-blockchain.rst:204
msgid ""
"Any simple DAG leads to a POSET by taking its transitive closure and saying "
"that **a < b** iff there is an edge **a \\rightarrow b**. By symmetry, "
"taking **a < b** iff there is an edge **b \\rightarrow a**  is also a POSET "
"(just based on inverted order). Going in the other direction - from POSET to"
" a DAG - is analogous."
msgstr ""
"Geçişli kapalılık (transitive closure) alınıp, **a < b** olduğu söylenirse, "
"**a \\rightarrow b** şeklinde bir köşe var ise, herhangi bir basit DAG, bir "
"POSET'e yol açar. Simetrik olarak, **a < b** alırsak,  **b \\rightarrow a** "
"şeklinde bir köşe var ise, bu da bir POSET'tir (tersten sıralamayı baz "
"alarak). Diğer yönde  gidince de - POSET'ten DAG'a - benzerdir.  "

#: ../../theory/naive-blockchain.rst:206
msgid ""
"In practice, POSET is “like a simple DAG” where we do not distinguish "
"between DAGs with the same transitive closure. In particular, for "
"visualization purposes it is convenient to draw a POSET as a transitive "
"reduction of a corresponding DAG."
msgstr ""
"Pratikte POSET, aynı geçişli kapalılığa sahip DAG'ler arasında ayrım "
"yapmadığımız “basit bir DAG gibidir”. Özellikle, görselleştirme açısından, "
"bir POSET'i karşılık gelen bir DAG'nin geçişli bir indirgemesi olarak çizmek"
" uygundur."

#: ../../theory/naive-blockchain.rst:208
msgid ""
"When talking about **j-dag** and **p-dag**, we blur the difference between "
"DAG language and POSET language, because essentially one language is "
"convertible to another."
msgstr ""
"**j-dag** ve **p-dag** hakkında konuşurken, DAG dili ile POSET dili "
"arasındaki farkı bulanıklaştırıyoruz çünkü esasen bir dil diğerine "
"dönüştürülebilir."

#: ../../theory/naive-blockchain.rst:211
msgid "Understanding the layers of the blockdag"
msgstr "Blockdag'ın katmanlarını anlama"

#: ../../theory/naive-blockchain.rst:212
msgid ""
"Here we explain only the intuition behind the blockdag. These ideas are "
"formalized later in this document."
msgstr ""
"Burada sadece blockdagin arkasındaki sezgiyi açıklıyoruz. Bu fikirler bu "
"belgede daha sonra resmileştirilmiştir."

#: ../../theory/naive-blockchain.rst:214
msgid ""
"**J-dag** is all about attesting what I have seen so far. When I am a "
"validator creating a new message (= block or ballot), I have to attest what "
"is my current protocol state -- i.e., what my current blockdag looks like. I"
" do this by including on the justifications list (which is part of the new "
"message) pointers to all **j-dag** tips present in my blockdag. Please note "
"that we continue to use the terminology established for j-dag from previous "
"chapters (*See* the topic on J-dag)."
msgstr ""
"**J-dag** şimdiye kadar gördüklerimi doğrulamakla ilgili. Yeni bir mesaj (= "
"blok veya oy pusulası) oluşturan bir doğrulayıcı olduğumda, mevcut protokol "
"durumumun ne olduğunu - yani mevcut blockdag'imin nasıl göründüğünü "
"onaylamam gerekiyor. Bunu, engelleme listemde bulunan tüm **j-dag** "
"ipuçlarına (yeni mesajın bir parçası olan) işaretçileri ekleyerek yapıyorum."
" Lütfen önceki bölümlerden j-dag için oluşturulmuş terminolojiyi kullanmaya "
"devam ettiğimizi unutmayın (*Bkz.* J-dag başlığı)."

#: ../../theory/naive-blockchain.rst:217
msgid ""
"**Main-tree** encodes the multi-variant progress of a transaction's history."
" When a validator creating a block B picks block A as the main parent of B, "
"it means “I want transactions included in B to extend the history of the "
"blockchain that ended at block A with all transactions in A already "
"executed”. This tree is analogous to a similar tree of blocks that forms in "
"a previous generation of blockchains, like Bitcoin or Ethereum."
msgstr ""
"**Ana ağaç**, bir işlemin geçmişinin çok değişkenli ilerlemesini kodlar. Bir"
" B bloğu oluşturan bir doğrulayıcı, A bloğunu B'nin üst ögesi olarak "
"seçtiğinde, \"B'ye dahil edilen işlemlerin, A bloğunda sona eren "
"blokzincirin geçmişini A'da halihazırda yürütülen tüm işlemlerle birlikte "
"genişletmesini istiyorum\" anlamına gelir. Bu ağaç, Bitcoin veya Ethereum "
"gibi önceki nesil blokzincirlerde oluşan benzer blok ağacına benzer."

#: ../../theory/naive-blockchain.rst:219
msgid ""
"**P-dag** and the concept of secondary parents, corresponds to “merging of "
"histories” -- a subtle optimization on the way we process transactions. In "
"blockchains such as Ethereum, effectively only a single path of the main-"
"tree ends up as “transactions that have been actually executed” while all "
"the rest of the main-tree ends up being wasted, or - as we say - “orphaned”."
" In fact, the amount of wasted work can be reduced by “merging”. While "
"creating a new block, a validator performs careful analysis of all branches "
"of the main-tree and attempts to merge as many of them possible without "
"introducing a concurrency conflict."
msgstr ""
"**P-dag** ve ikincil üst öge kavramı, \"geçmişlerin birleştirilmesine\" "
"tekabül eder - işlemleri işleme şeklimizde ince bir optimizasyon. Ethereum "
"gibi blokzincirlerde, ana ağacın yalnızca tek bir yolu \"gerçekten yürütülen"
" işlemler\" olarak sonuçlanırken, ana ağacın geri kalanının tamamı boşa "
"harcanır veya - tabiri caizse - \"yetim kalır\". . Aslında, boşa harcanan iş"
" miktarı “birleştirme” ile azaltılabilir. Yeni bir blok oluştururken, bir "
"doğrulayıcı ana ağacın tüm dallarının dikkatli bir analizini gerçekleştirir "
"ve bir eşzamanlılık çakışması oluşturmadan mümkün olduğunca çoğunu "
"birleştirmeye çalışır."

#: ../../theory/naive-blockchain.rst:222
msgid "Core mechanics of the blockchain"
msgstr "Blok zincirinin temel mekaniği"

#: ../../theory/naive-blockchain.rst:223
msgid "The blockdag emerges as a combination of these central ideas:"
msgstr ""
"Blockdag, bu belli başlı fikirlerin bir kombinasyonu olarak ortaya çıkıyor:"

#: ../../theory/naive-blockchain.rst:225
msgid ""
"Independently proposing updates of the shared database inevitably leads to a"
" tree of transactions (blocks) because the proposing validator must choose "
"which version of history it is about to extend. This is how the **main-"
"tree** pops up."
msgstr ""
"Paylaşılan veritabanının güncellemelerini bağımsız olarak önermek, "
"kaçınılmaz olarak bir işlem ağacına (bloklara) yol açar, çünkü teklifte "
"bulunan doğrulayıcı, hangi geçmiş sürümünün genişletileceğini seçmek "
"zorundadır. İşte **Ana ağaç** bu şekilde ortaya çıkar."

#: ../../theory/naive-blockchain.rst:226
msgid ""
"All that remains is to add the mechanics for validators to collectively "
"agree on which branch of the main-tree is the “official” one."
msgstr ""
"Geriye kalan tek şey, doğrulayıcıların ana ağacın hangi dalının “resmi” "
"olduğu konusunda toplu olarak mutabakata varmaları için mekanikleri "
"eklemektir."

#: ../../theory/naive-blockchain.rst:227
msgid ""
"We solve this problem by recursively applying the Abstract Casper Consensus "
"(a.k.a. ACC)."
msgstr ""
"Bu sorunu, Özet Casper Mutabakatı'nı (namı diğer ACC) özyinelemeli olarak "
"uygulayarak çözüyoruz."

#: ../../theory/naive-blockchain.rst:228
msgid ""
"The Secondary parents idea is a further refinement of the solution by "
"merging as many non-agreed paths of a main-tree as possible without "
"introducing inconsistencies."
msgstr ""
"İkincil üst öge fikri, ana ağacın üzerinde mutabakata varılmamış yolların "
"olabildiğince çok birleştirilerek çözümün daha da iyileştirilmesidir."

#: ../../theory/naive-blockchain.rst:230
msgid ""
"The single most crucial trick here is the recursive application of the "
"Abstract Casper Consensus -- to first try to understand this trick before "
"diving into detailed specs of how validators and finalizers operate."
msgstr ""
"Buradaki en önemli nokta, Özet Casper Mutabakatının özyinelemeli "
"uygulamasıdır - doğrulayıcıların ve sonlandırıcıların nasıl çalıştığına dair"
" ayrıntılı özelliklere dalmadan önce bu noktayı anlamaya çalışmaktır."

#: ../../theory/naive-blockchain.rst:232
msgid ""
"Let **b** be any block. So, **b** is a vertex in the main-tree. We will "
"consider a projection of validators P2P protocol to a particular Abstract "
"Casper Consensus model instance we will be calling **b-game**."
msgstr ""
"**b** herhangi bir blok olsun. Yani, **b** ana ağaçta bir tepe noktasıdır. "
"Doğrulayıcı P2P protokolünün, **b-game** olarak adlandıracağımız belirli bir"
" Soyut Casper Mutabakat model örneğine projeksiyonunu ele alacağız."

#: ../../theory/naive-blockchain.rst:235
msgid "Abstract Casper Consensus concept"
msgstr "Özet Casper Mutabakat kavramı"

#: ../../theory/naive-blockchain.rst:235
msgid "How this concept maps to b-game"
msgstr "Bu kavram b-game ile nasıl eşleşir?"

#: ../../theory/naive-blockchain.rst:238
msgid "validators"
msgstr "doğrulayıcılar"

#: ../../theory/naive-blockchain.rst:238
msgid "validators with non-zero weight in post-state of **b**"
msgstr "**b** durum sonrasında sıfırdan farklı ağırlığa sahip doğrulayıcılar"

#: ../../theory/naive-blockchain.rst:241
msgid "validator weights"
msgstr "doğrulayıcı ağırlıkları"

#: ../../theory/naive-blockchain.rst:241
msgid "**weights-map(globals-states-db(b.po st-state-hash))**"
msgstr "**weights-map(globals-states-db(b.po st-state-hash))**"

#: ../../theory/naive-blockchain.rst:244
msgid "message"
msgstr "mesaj"

#: ../../theory/naive-blockchain.rst:244
msgid "message (= block or ballot)"
msgstr "mesaj (=blok veya oy pusulası)"

#: ../../theory/naive-blockchain.rst:246
msgid "j-dag"
msgstr "j-dag"

#: ../../theory/naive-blockchain.rst:248
msgid "consensus value"
msgstr "mutabakat değeri"

#: ../../theory/naive-blockchain.rst:248
msgid "direct child of **b** in the **main-tree**"
msgstr "**ana ağaçta** **b**'nin doğrudan alt ögesi"

#: ../../theory/naive-blockchain.rst:251
msgid "message **m** is voting for consensus value **c**"
msgstr "mesaj **m**, mutabakat değeri **c** için oy veriyor "

#: ../../theory/naive-blockchain.rst:251
msgid ""
"for a block **m**: **m** is a descendant of **c** along the **main-tree**, "
"for a ballot **m**: **m.target-block** is a descendant of **c** along the "
"**main-tree** when above conditions are not met, we consider **m** as voting"
" for nothing (empty vote)"
msgstr ""
"bir blok için **m**: **m**, **ana ağaç** boyunca **c**'nin alt soyudur, oy "
"pusulası için **m**: **m.target-block**, **ana ağaç** boyunca **c**'nin alt "
"soyudur, yukarıdaki koşullar karşılanmadığında, **m**'in oy kullanmadığını "
"kabul ederiz (boş oy)"

#: ../../theory/naive-blockchain.rst:261
msgid "The contents of the table above may be explained as follows:"
msgstr "Yukarıdaki tablonun içeriği şu şekilde açıklanabilir:"

#: ../../theory/naive-blockchain.rst:263
msgid ""
"Hypothetically assuming that validators already achieved consensus on the "
"block **b** as being the part of an “official” chain of blocks, they will "
"have to decide which direct child of **b** (in main-tree) will be the next "
"“official” chain."
msgstr ""
"Doğrulayıcıların, **b** bloğunun “resmi” bloklar zincirinin bir parçası "
"olduğu üzerinde mutabakata vardıklarını varsayarsak, onların **b**'nin (ana "
"ağaçta) hangi direkt alt ögesinin sonraki “resmi” zincir olacağına karar "
"vermeleri gerekecektir."

#: ../../theory/naive-blockchain.rst:264
msgid ""
"So the focus now is on the block **b** and on its direct main-tree children."
msgstr ""
"Bu nedenle, odak şimdi **b** bloğu ve onun direkt ana ağaç alt ögeleri "
"üzerindedir."

#: ../../theory/naive-blockchain.rst:265
msgid ""
"We setup the Abstract Casper Consensus instance “relative to block **b**” "
"where consensus values are direct children of **b**."
msgstr ""
"Mutabakat değerlerinin **b**'nin doğrudan alt ögeleri olduğu “**b** bloğuna "
"göreli” Özet Casper Mutabakat örneğini kurduk."

#: ../../theory/naive-blockchain.rst:266
msgid ""
"Any block **x** can be seen as a vote for some child of **b** only if **x** "
"is a descendant of **b** in the main-tree. So if **x** is not a descendant "
"of **b**, we consider **x** as carrying an empty vote."
msgstr ""
"Herhangi bir **x** bloğu, ancak **x** ana ağaçta **b**'nin soyundan "
"geliyorsa, **b**'nin bazı alt ögeleri için oy olarak görülebilir. "
"Dolayısıyla **x**, **b**'nin soyundan değilse, **x**'i boş oy olarak kabul "
"ederiz."

#: ../../theory/naive-blockchain.rst:268
msgid ""
"**Note:** when defining the players of **b-game**, we exclude all "
"equivocators, as seen in the current protocol state. This means that b-game "
"is not “absolute”, it is rather depending on the current perspective on the "
"blockchain that given validator has. Also, the collection of equivocators "
"grows over time, which means that over time we may need to recalculate "
"b-game, excluding more validators. This aspect plays a crucial role in how "
"**finalizers** work - (*see below* the topic **Operation of a finalizer**)."
msgstr ""
"**Not:** **b-oyunu** oyuncularını tanımlarken, mevcut protokol durumunda "
"görüldüğü gibi tüm çelişkilileri hariç tutuyoruz. Bu, b-oyunun “mutlak” "
"olmadığı, daha ziyade verilen doğrulayıcının sahip olduğu blokzincirdeki "
"mevcut bakış açısına bağlı olduğu anlamına gelir. Ayrıca, çelişkililerin "
"toplamı zamanla büyür, bu da zamanla b-oyununu daha fazla doğrulayıcı hariç "
"tutarak yeniden hesaplamamız gerekebileceği anlamına gelir. Bu özellik, "
"**kesinleştiricilerin** nasıl çalıştığı konusunda çok önemli bir rol oynar -"
" (*aşağıya bakın* **Kesinleştiricilerin çalışması** konusuna bakın)."

#: ../../theory/naive-blockchain.rst:270
msgid ""
"Not all **b-games** tend to be equally important. What happens is presented "
"with the following pattern:"
msgstr ""
"Tüm **b-oyunları** eşit derecede önemli olma eğiliminde değildir. Neler "
"olduğu aşağıdaki modelde sunulmuştur:"

#: ../../theory/naive-blockchain.rst:272
msgid ""
"The **Genesis** block is given. So, **Genesis-game** is the first game."
msgstr ""
"**Doğuş (genesis)** bloğu verilmiştir. Yani, **Genesis-oyunu** ilk oyundur."

#: ../../theory/naive-blockchain.rst:273
msgid ""
"As the blockdag grows, the **Genesis-game** is progressing towards finality."
msgstr "Blockdag büyüdükçe, **Genesis oyunu** kesinliğe doğru ilerler."

#: ../../theory/naive-blockchain.rst:274
msgid ""
"Finality of the **Genesis-game** means picking some direct child of "
"**Genesis**. Let us name this child **LFB1**"
msgstr ""
"**Genesis oyununun** kesinliği, **Genesis**'in doğrudan bir alt ögesini "
"seçmek anlamına gelir. Bu çocuğa **LFB1** adını verelim"

#: ../../theory/naive-blockchain.rst:275
msgid ""
"Then, the **LFB1-game** becomes the “important” game that everybody looks "
"at."
msgstr "Ardından, **LFB1 oyunu** herkesin baktığı “önemli” oyun haline gelir."

#: ../../theory/naive-blockchain.rst:276
msgid ""
"As the blockdag grows, the **LFB1-game** is progressing towards finality."
msgstr "Blockdag büyüdükçe, **LFB1 oyunu** kesinliğe doğru ilerler."

#: ../../theory/naive-blockchain.rst:277
msgid ""
"Finality of the **LFB1-game** means picking some direct child of **LFB1**. "
"Let us name this child **LFB2**"
msgstr ""
"**LFB1 oyununun** kesinliği, **LFB1**'in bazı doğrudan alt öğelerini seçmek "
"anlamına gelir. Bu alt ögeye **LFB2** adını verelim"

#: ../../theory/naive-blockchain.rst:278
msgid "This pattern goes on forever."
msgstr "Bu model sonsuza kadar devam eder."

#: ../../theory/naive-blockchain.rst:280
msgid ""
"“LFB” stands for “last finalized block”. For symmetry, we set **LFB0** = "
"**Genesis**."
msgstr ""
"\"LFB\", \"son kesinleşmiş blok\" anlamına gelir. Simetri için **LFB0** = "
"**Genesis** olarak ayarlanmıştır."

#: ../../theory/naive-blockchain.rst:283
msgid "Why do we need ballots ?"
msgstr "Neden oy pusulasına ihtiyacımız var?"

#: ../../theory/naive-blockchain.rst:285
msgid ""
"The security of proof-of-stake blockchain is based on the stake in two ways:"
msgstr "Hisse kanıtı blok zincirinin güvenliği, hisseye iki şekilde dayanır:"

#: ../../theory/naive-blockchain.rst:287
msgid ""
"Large investment (=money) is needed to revert/overtake the history of "
"transactions using honest means."
msgstr ""
"Dürüst araçlar kullanarak işlemlerin geçmişini geri almak/ele geçirmek için "
"büyük yatırım (=para) gereklidir."

#: ../../theory/naive-blockchain.rst:288
msgid ""
"Malicious behavior (= hacking) implies that the stake will get slashed."
msgstr ""
"Kötü niyetli davranış (= hackleme), hissenin kesileceği anlamına gelir."

#: ../../theory/naive-blockchain.rst:290
msgid ""
"Therefore, we would like only bonded validators to be able to participate in"
" blockchain evolution. The problem here is that - when a validator unbonds, "
"some of the **b-games** he was a player of might not be completed (= "
"finalized) yet. We would like to allow the validator to still participate in"
" these games while not allowing him to join new games. This is where ballots"
" come into play. Ballots make it possible for a validator that is no longer "
"bonded to continue the consensus game."
msgstr ""
"Bu nedenle, blokzincir evrimine yalnızca bağlı doğrulayıcıların "
"katılabilmesini istiyoruz. Buradaki sorun şu ki - bir doğrulayıcı "
"çözüldüğünde, oyuncusu olduğu bazı **b-oyunları** henüz tamamlanmamış (= "
"kesinleşmemiş) olabilir. Doğrulayıcının yeni oyunlara katılmasına izin "
"vermeden bu oyunlara katılmaya devam etmesine izin vermek istiyoruz. İşte "
"burada oy pusulaları devreye giriyor. Oy pusulaları, artık bağlı olmayan bir"
" doğrulayıcının mutabakat oyununa devam etmesini mümkün kılar."

#: ../../theory/naive-blockchain.rst:293
msgid "Merging of histories"
msgstr "Geçmişlerin birleştirilmesi"

#: ../../theory/naive-blockchain.rst:296
msgid "Topological sortings of p-past-cone"
msgstr "p-past-cone topolojik sıralamaları"

#: ../../theory/naive-blockchain.rst:298
msgid "This is a previous example of a blockdag, reduced to **p-dag** only:"
msgstr "Bu, yalnızca **p-dag**'a indirgenmiş önceki bir blockdag örneğidir:"

#: ../../theory/naive-blockchain.rst:304
msgid ""
"We define **p-past-cone(b)** as the set of all blocks :math:`x` such that "
":math:`x \\leqslant b` (in the POSET corresponding to p-dag, :math:`x "
"\\leqslant y \\iff y \\rightarrow x`)."
msgstr ""
"**p-past-cone(b)**'yi tüm :math:`x` blokların kümesi olarak tanımlarız, öyle"
" ki :math:`x \\leqslant b` (p-dag'a karşılık gelen POSET'te :math: `x "
"\\leqslant y \\iff y \\rightarrow x`)."

#: ../../theory/naive-blockchain.rst:306
msgid ""
"**Example:** Let’s look at the block :math:`3`. Its p-past-cone is "
":math:`\\{Genesis, 1, 2, 3\\}`. Let’s look at the block :math:`9`. Its p"
"-past-cone is :math:`\\{Genesis, 1,2,3,4,5,9\\}`."
msgstr ""
"**Örnek:** Blok :math:`3` 'e bakalım. p-past-cone değeri :math:`\\{Genesis, "
"1, 2, 3\\}` şeklindedir. Block :math:`9` 'a bakalım. p-past-cone değeri "
":math:`\\{Genesis, 1,2,3,4,5,9\\}` şeklindedir."

#: ../../theory/naive-blockchain.rst:308
msgid ""
"Of course, any **p-past-cone(b)** inherits the order from the whole "
"**p-dag**, so it can be seen as a POSET as well."
msgstr ""
"Elbette, herhangi bir **p-past-cone(b)**, sırayı tüm **p-dag**'dan devralır,"
" dolayısıyla bir POSET olarak da görülebilir."

#: ../../theory/naive-blockchain.rst:310
msgid ""
"For :math:`\\langle A,R\\rangle` any POSET, topological sorting of "
":math:`\\langle A,R\\rangle` is any linear order :math:`\\langle "
"A,T\\rangle` such that :math:`identity: \\langle A,R\\rangle \\rightarrow "
"\\langle A,T\\rangle` is monotonic. In other words, topological sorting is "
"converting a POSET into a total order in a way that preserves the original "
"order. For a given POSET, this can usually be done in many ways."
msgstr ""
" :math:`\\langle A,R\\rangle` için herhangi bir POSET,  :math:`\\langle "
"A,R\\rangle`  'nin topolojik sıralaması, :math:`identity: \\langle "
"A,R\\rangle \\rightarrow \\langle A,T\\rangle` 'nin monoton olduğu herhangi "
"bir doğrusal sıralama :math:`\\langle A,T\\rangle` 'dir. Diğer bir deyişle, "
"topolojik sıralama, bir POSET'i, orjiinal sıralamanın bir şekilde korunduğu,"
" toplam sıralamaya dönüştürmektedir. Verilen bir POSET için bu genellikle "
"pek çok yolla yapılabilir."

#: ../../theory/naive-blockchain.rst:314
msgid ""
"\\ **Example:**\\  Let’s take the :math:`p\\_past\\_cone(3)` from our "
"example. As a POSET it looks like this:"
msgstr ""
"\\ **Örnek:**\\  Örneğimizdeki :math:`p\\_past\\_cone(3)` 'ü alalım. Bir "
"POSET olarak şu şekilde görünecektir:"

#: ../../theory/naive-blockchain.rst:320
msgid "It can be topo-sorted in two ways only:"
msgstr "Yalnızca iki şekilde topo-sıralanabilir:"

#: ../../theory/naive-blockchain.rst:326
msgid ""
"Example: Let’s take the p-past-cone(9) from our example. As a POSET it looks"
" like this:"
msgstr ""
"Örnek: Örneğimizden p-past-cone(9)'u alalım. POSET olarak şöyle görünür:"

#: ../../theory/naive-blockchain.rst:332
msgid "It can be topo-sorted in many ways. One such topo-sort is shown below:"
msgstr ""
"Birçok yönden topo-sıralanabilir. Böyle bir topo-sıralama aşağıda "
"gösterilmiştir:"

#: ../../theory/naive-blockchain.rst:339
msgid "The context of merging problem"
msgstr "Birleştirme sorunu bağlamı"

#: ../../theory/naive-blockchain.rst:341
msgid ""
"Let’s assume that current p-dag as seen by a validator **v** looks like "
"this:"
msgstr ""
"Bir **v** doğrulayıcısı tarafından görüldüğü şekliyle mevcut p-dag'ın şöyle "
"göründüğünü varsayalım:"

#: ../../theory/naive-blockchain.rst:347
msgid ""
"To add a new block :math:`x`, validator :math:`V` needs to decide which "
"blocks to take as parents of :math:`x`. In other words, decide which "
"variants of a transactions history block :math:`x` will continue. Merging is"
" all about defining what it means that **x** continues more than one version"
" of the history:"
msgstr ""
"Yeni bir blok :math:`x` eklemek için, doğrulayıcı :math:`V` hangi blokların "
":math:`x` ögesinin üst ögesi olarak alınacağına karar vermelidir. Başka bir "
"deyişle, bir işlem geçmişi bloğu :math:`x` 'in hangi varyantlarının devam "
"edeceğine karar vermelidir. Birleştirme, **x**'in geçmişin birden fazla "
"versiyonuna devam etmesinin ne anlama geldiğini tanımlamakla ilgilidir:"

#: ../../theory/naive-blockchain.rst:353
msgid ""
"We have blocks 8, 9 and 10 as current tips of p-dag, so they are candidates "
"for becoming parents of the new block. But usually, we won’t be able to take"
" all such tips as parents because the versions of the transactions history "
"they represent are in conflict."
msgstr ""
"Mevcut p-dag ipuçları olarak 8, 9 ve 10 numaralı bloklarımız var, bu nedenle"
" yeni bloğun üst ögesi olmaya adaylar. Ancak genellikle, temsil ettikleri "
"işlem geçmişinin sürümleri çelişkili olduğundan, üst ögeler olarak bu tür "
"ipuçlarının hepsini alamayacağız."

#: ../../theory/naive-blockchain.rst:357
msgid "Formal definition of merging"
msgstr "Birleştirmenin resmi tanımı"

#: ../../theory/naive-blockchain.rst:359
msgid ""
"We say that a set of blocks :math:`B = \\{b_1, b_2, ..., b_n\\}` is "
"**mergeable** (= **not in conflict**) when the following holds:"
msgstr ""
"Aşağıdakiler geçerli olduğunda :math:`B = \\{b_1, b_2, ..., b_n\\}` blok "
"kümesinin **birleştirilebilir** (= **çatışmasız**) olduğunu söyleriz:"

#: ../../theory/naive-blockchain.rst:361
msgid ""
"take the sum :math:`S` of :math:`p\\_past\\_cone(b_i)` for :math:`i=1,..., "
"n` - this is a sub-POSET of p-dag"
msgstr ""
":math:`i=1,..., n` için :math:`p\\_past\\_cone(b_i)`'nin :math:`S`  "
"toplamını alın - bu, p-dag'ın alt POSET'idir"

#: ../../theory/naive-blockchain.rst:363
msgid "given any topo-sort :math:`T` of :math:`S`"
msgstr ":math:`S` 'in herhangi bir :math:`T` topo-sıralaması verilir"

#: ../../theory/naive-blockchain.rst:365
msgid "the execution of transactions in :math:`B` along :math:`T` give:"
msgstr ""
":math:`B` ile birlikte :math:`T` içindeki işlemlerin yürütülmesi şunu verir:"

#: ../../theory/naive-blockchain.rst:367
msgid "the same final global state (regardless of the selection of **T)**"
msgstr "aynı nihai küresel durum (**T** seçiminden bağımsız olarak)"

#: ../../theory/naive-blockchain.rst:369
msgid ""
"the same subset of transactions that failed (regardless of the selection of "
"**T**)"
msgstr ""
"başarısız olan işlemlerin aynı alt kümesi (**T** seçiminden bağımsız olarak)"

#: ../../theory/naive-blockchain.rst:372
msgid "Operation of a validator"
msgstr "Doğrulayıcının çalışması"

#: ../../theory/naive-blockchain.rst:374
msgid ""
"The spec is written from the perspective of a validator. We say it as "
"**local validator** in order to reference the validator which is running the"
" algorithm. Let **vid** be the id of the local validator."
msgstr ""
"Belirtim (spesifikasyon), bir doğrulayıcının bakış açısından yazılmıştır. "
"Algoritmayı çalıştıran doğrulayıcıyı belirtmek için **yerel doğrulayıcı** "
"diyoruz. **vid** yerel doğrulayıcının kimliği olsun."

#: ../../theory/naive-blockchain.rst:377
msgid "Validators P2P protocol - messages"
msgstr "Doğrulayıcılar P2P protokolü - mesajlar"

#: ../../theory/naive-blockchain.rst:379
msgid "Validators exchange messages which can be of 2 types:"
msgstr "Doğrulayıcılar, 2 tipte olabilen mesaj alışverişi yapar:"

#: ../../theory/naive-blockchain.rst:381
msgid "**blocks**"
msgstr "**bloklar**"

#: ../../theory/naive-blockchain.rst:382
msgid "**ballots**"
msgstr "**oy pusulaları**"

#: ../../theory/naive-blockchain.rst:384
msgid "A **block** contains the following data:"
msgstr "Bir **blok** aşağıdaki verileri içerir:"

#: ../../theory/naive-blockchain.rst:386 ../../theory/naive-blockchain.rst:399
msgid "**block id**"
msgstr "**blok kimliği**"

#: ../../theory/naive-blockchain.rst:387
msgid "**creator id** (= id of validator that created this block)"
msgstr "**oluşturan kimliği** (=bu bloğu oluşturan doğrulayıcının kimliği)"

#: ../../theory/naive-blockchain.rst:388
msgid "**main parent** (id of another block)"
msgstr "**ana üst öge** (bir başka bloğun kimliği)"

#: ../../theory/naive-blockchain.rst:389
msgid "**secondary parents** (collection of block ids, may be empty)"
msgstr "**ikincil ana öge** (blok kimlikleri derlemesi, boş olabilir)"

#: ../../theory/naive-blockchain.rst:390
msgid ""
"**justifications** (collection of message ids that the creator confirms as "
"seen at the moment of creation of this block; excluding main parent and "
"secondary parents; may be empty)"
msgstr ""
"**gerekçeler** (bu bloğun oluşturulduğu anda görülen oluşturucunun "
"onayladığı mesaj kimliklerinin toplamı; ana üst öge ve ikincil üst ögeler "
"hariç; boş olabilir)"

#: ../../theory/naive-blockchain.rst:391
msgid "**transactions list** (nonempty)"
msgstr "**işlemler listesi** (boş olamaz)"

#: ../../theory/naive-blockchain.rst:392
msgid ""
"**pre-state-hash** - hash of global state that represents state after "
"executing all parents of this block"
msgstr ""
"**pre-state-hash** - bu bloğun tüm üst öğelerini yürüttükten sonra durumu "
"temsil eden küresel durumun özeti"

#: ../../theory/naive-blockchain.rst:393
msgid ""
"**post-state hash** - hash of global state achieved after executing "
"transactions in this block (and all previous blocks, as implied by p-dag)"
msgstr ""
"**durum sonrası karma** - bu blokta (ve p-dag tarafından belirtildiği gibi "
"önceki tüm bloklarda) işlemler yürütüldükten sonra elde edilen küresel "
"durumun özet değeri"

#: ../../theory/naive-blockchain.rst:395
msgid ""
"For a block :math:`b` we define the collection "
":math:`b.all\\_justifications` as main parent + secondary parents + "
"justifications. This collection is always non-empty because **main parent** "
"is a mandatory field."
msgstr ""
"Bir :math:`b` bloğu için, :math:`b.all\\_justifications` toplamını ana üst "
"öge + ikincil üst ögeler + gerekçeler olarak tanımlarız. Bu toplam her zaman"
" boş olmayan kümedir çünkü **ana üst öge** zorunlu bir alandır."

#: ../../theory/naive-blockchain.rst:397
msgid "A **ballot** contains the following data:"
msgstr "Bir **oy pusulası** şu verileri içerir:"

#: ../../theory/naive-blockchain.rst:400
msgid "**creator id** (= id of validator that created this ballot)"
msgstr ""
"**oluşturan kimliği** (=bu oy pusulasını oluşturan doğrulayıcının kimliği)"

#: ../../theory/naive-blockchain.rst:401
msgid "**target block** (id of a block)"
msgstr "**hedef blok** (bir bloğun kimliği)"

#: ../../theory/naive-blockchain.rst:402
msgid ""
"**justifications** (collection of message ids that the creator confirms as "
"seen at the moment of creation of this ballot, excluding the target block; "
"may be empty)"
msgstr ""
"**gerekçeler** (bu oy pusulasının oluşturulduğu anda görülen ouşturucunun "
"onayladığı mesaj kimliklerinin toplamı, hedef blok hariç; boş olabilir)"

#: ../../theory/naive-blockchain.rst:404
msgid ""
"For a ballot **b** we define the collection :math:`b.all\\_justifications` "
"as target block + additional justifications. This collection is always non-"
"empty because target block is a mandatory field."
msgstr ""
"Bir **b** oy pusulası için  :math:`b.all\\_justifications` toplamını, hedef "
"blok + ek gerekçeler olarak tanımlarız. Bu toplam her zaman boş olmayan küme"
" şeklindedir, çünkü hedef blok, zorunlu alandır."

#: ../../theory/naive-blockchain.rst:406
msgid ""
"From the definitions above it follows that for every message :math:`m` there"
" is a **j-dag** path from :math:`m` to :math:`Genesis`."
msgstr ""
"Yukarıdaki tanımlamalara bakarak, her bir :math:`m` mesajı için "
":math:`m`'den :math:`Genesis`'e bir **j-dag** yolu vardır."

#: ../../theory/naive-blockchain.rst:409
msgid "Validators P2P protocol - behavior"
msgstr "Doğrulayıcılar P2P protokolü - davranış"

#: ../../theory/naive-blockchain.rst:411
msgid ""
"We use the same assumptions on a message-passing network as were stated in "
"the Abstract Casper Consensus model. So, validators only exchange "
"information by broadcasting messages where the broadcasting implementation "
"provides an exactly-once delivery guarantee, but the delays and shuffling of"
" messages are arbitrary."
msgstr ""
"Özet Casper Mutabakat modelinde belirtilen varsayımların aynısını bir mesaj "
"ileten ağda kullanıyoruz. Bu nedenle, doğrulayılar, yalnızca mesajlar "
"yayınlayarak bilgi alışverişinde bulunurlar ki orada uygulama yayınlamak tam"
" olarak bir kerede teslimat garantisi sunar, ama mesaj  ertelemeleri ve "
"karıştırmaları gelişigüzeldir."

#: ../../theory/naive-blockchain.rst:413
msgid ""
"During its lifetime, a validator maintains the following data structures:"
msgstr "Doğrulayıcı, kullanım ömrü boyunca aşağıdaki veri yapılarını korur:"

#: ../../theory/naive-blockchain.rst:415
msgid ""
"**deploys-buffer** - a buffer of transactions sent by clients, to be "
"executed on the blockchain computer"
msgstr ""
"**deploys-buffer** - blokzincir bilgisayarında yürütülmek üzere müşteriler "
"tarafından gönderilen işlemlerin arabelleği"

#: ../../theory/naive-blockchain.rst:416
msgid ""
"**blockdag** - keeping all blocks and ballots either produced by or received"
" from other validators"
msgstr ""
"**blockdag** - diğer onaylayıcılar tarafından üretilen veya onlardan alınan "
"tüm blokları ve oy pusulalarını saklamak"

#: ../../theory/naive-blockchain.rst:417
msgid ""
"**messages-buffer** - a buffer of messages received, but not yet "
"incorporated into the **blockdag**"
msgstr ""
"**messages-buffer** - alınan, ancak henüz **blockdag**'a dahil edilmemiş "
"mesajların arabelleği"

#: ../../theory/naive-blockchain.rst:418
msgid ""
"**latest-honest-messages** - a mapping from validator id to message id, "
"pointing every validator known in the **blockdag**, excluding "
"**equivocators**, to the corresponding swimlane tip"
msgstr ""
"**latest-honest-messages** - doğrulayıcı kimliğinden mesaj kimliğine "
"**blockdag**'deki bilinen her bir doğrulayıcıyı işaret eden, "
"**çelişkiller**'i hariç tutan, karşılık gelen kulvar ipucuna bir eşleştirme."

#: ../../theory/naive-blockchain.rst:419
msgid ""
"**equivocators** - a collection of validators for which current blockdag "
"contains an equivocation"
msgstr ""
"**çelişkililer** - şu anki blokdag'in bir çelişki barındırdığı "
"doğrulayıcılar grubu"

#: ../../theory/naive-blockchain.rst:420
msgid ""
"**reference-finalizer** - an instance of finalizer used internally (*see* "
"**Operation of a finalizer** later in this spec for more information about "
"what finalizers are)"
msgstr ""
"**referans-kesinleştirici** - dahil olarak kullanılan, kesinleştiricinin bir"
" örneği (Kesinleştiricilerin ne olduğu ile ilgili daha fazla bilgi için bu "
"spesifikasyonda *bkz* **Kesinleştiricinin çalışması** )"

#: ../../theory/naive-blockchain.rst:421
msgid "**global-states-db** - mapping of global state hash to global state"
msgstr ""
"**global-states-db** - küresel durum özetinin küresel duruma eşleştirilmesi"

#: ../../theory/naive-blockchain.rst:423
msgid ""
"A message :math:`m` can be added to the :math:`blockdag` only if all "
"justifications of :math:`m` are already present in the blockdag. So if a "
"validator receives a message before receiving some of its justifications, "
"the received message must wait in the :math:`messages\\_buffer`."
msgstr ""
":math:`m`, :math:`blockdag`'e, sadece, :math:`m`'in tüm gerekçeleri, "
"blockdag'de halihazırda hazır ise eklenebilir. Bu nedenle, bir doğrulayıcı "
"gerekçelerinin bazılarını almadan önce bir mesaj alırsa, alınan mesaj "
":math:`messages\\_buffer`'da beklemelidir. "

#: ../../theory/naive-blockchain.rst:425
msgid ""
"A validator is concurrently executing two infinite loops of processing:"
msgstr "Doğrulayıcı aynı anda iki sonsuz işlem döngüsü yürütüyor:"

#: ../../theory/naive-blockchain.rst:427
msgid "**Listening loop:**"
msgstr "**Dinleme döngüsü:**"

#: ../../theory/naive-blockchain.rst:429
msgid ""
"Listen to messages incoming from other validators. Whenever a message "
":math:`m` (block or ballot) arrives, follow this handling scenario:"
msgstr ""
"Diğer doğrulayıcılardan gelen mesajları dinle. Bir :math:`m` mesajı  (blok "
"veya oy pusulası) geldiğinde, şu işleme senaryosunu izle:"

#: ../../theory/naive-blockchain.rst:431
msgid ""
"Validate the formal structure of :math:`m`. In case of any error - drop "
":math:`m` (invalid message) and exit."
msgstr ""
":math:`m`'in biçimsel yapısını doğrula. Herhangi bir hata durumunda - "
":math:`m` 'i (geçersiz mesaj) bırak ve çık."

#: ../../theory/naive-blockchain.rst:433
msgid ""
"Check if all justifications of :math:`m` are already included in "
":math:`blockdag`."
msgstr ""
":math:`m`'in tüm gerekçelerinin zaten :math:`blockdag` içinde olup "
"olmadığını kontrol et."

#: ../../theory/naive-blockchain.rst:435
msgid "if yes: continue"
msgstr "evet ise: devam et"

#: ../../theory/naive-blockchain.rst:437
msgid "otherwise: append :math:`m` to the :math:`messages\\_buffer`, then exit"
msgstr ""
"aksi takdirde: :math:`m` ögesini :math:`messages\\_buffer`'a ekle, ardından "
"çık"

#: ../../theory/naive-blockchain.rst:439
msgid ""
"Perform processing specific to type of :math:`m` (block or ballot) - see "
"below."
msgstr ""
":math:`m` (blok veya oy pusulası) türüne özel işlem gerçekleştir - aşağıya "
"bakın."

#: ../../theory/naive-blockchain.rst:441
msgid "If :math:`equivocators` does not contain :math:`m.creator`:"
msgstr ":math:`equivocators`, :math:`m.creator` içermiyorsa:"

#: ../../theory/naive-blockchain.rst:443
msgid ""
"Check if :math:`m` introduces new equivocation - this is the case when "
":math:`latest\\_honest\\_messages(m.creator)` is not member of "
":math:`j\\_past\\_cone(m)`"
msgstr ""
":math:`m`'in yeni bir çelişkili davranış getirip getirmediğini kontrol et - "
"bu :math:`latest\\_honest\\_messages(m.creator)`, "
":math:`j\\_past\\_cone(m)`'in üyesi olmadığında meydana gelen durumdur"

#: ../../theory/naive-blockchain.rst:445
msgid "If yes then add :math:`m.creator` to :math:`equivocators`"
msgstr "Evet ise, :math:`m.creator` ögesini :math:`equivocators`a ekle."

#: ../../theory/naive-blockchain.rst:447
msgid ""
"If :math:`equivocators` does not contain :math:`m.creator`, update "
":math:`latest\\_honest\\_messages` map by setting "
":math:`latest\\_honest\\_messages(m.creator) = m`"
msgstr ""
"Eğer, :math:`equivocators`, :math:`m.creator` içermiyorsa, "
":math:`latest\\_honest\\_messages(m.creator) = m`'i ayarlayarak "
":math:`latest\\_honest\\_messages`'ı güncelle "

#: ../../theory/naive-blockchain.rst:449
msgid ""
"Check if there is any message :math:`x` in :math:`messages\\_buffer` that "
"can now leave the buffer and be included in the :math:`blockdag` because of "
":math:`x.all\\_justifications` are now present in the :math:`blockdag`. For "
"first such :math:`x` found, apply steps (3) - (4) - (5) ."
msgstr ""
":math:`messages\\_buffer`'da, :math:`x.all\\_justifications` 'ın şimdi "
":math:`blockdag`'de bulunması nedeniyle, şu anda arabellekten ayrılabilecek "
"ve  :math:`blockdag`'de dahil edilebilecek, herhangi bir :math:`x` mesajı "
"olup olmadığını kontrol et. Bulunan böyle bir :math:`x` için, (3) - (4) - "
"(5) nolu adımları uygula."

#: ../../theory/naive-blockchain.rst:451
msgid ""
"(“Buffer pruning cascade”) Repeat step (6) as many times as there are blocks"
" that can be released from the buffer."
msgstr ""
"(“Arabellek budama kademesi”) Arabellekten serbest bırakılabilen bloklar "
"olduğu sürece adım (6)'yı tekrarla."

#: ../../theory/naive-blockchain.rst:453
msgid "Processing specific to type of :math:`m` goes as follows:"
msgstr ":math:`m` türüne özel işlem şu şekilde gerçekleşir:"

#: ../../theory/naive-blockchain.rst:455
msgid "If :math:`m` is a block:"
msgstr "Eğer :math:`m` bir blok ise:"

#: ../../theory/naive-blockchain.rst:457
msgid ""
"Validate whether :math:`m` parents (main parent and secondary parents) were "
"selected correctly:"
msgstr ""
":math:`m`'in üst ögelerinin (ana üst öge ve ikincil üst ögeler) doğru "
"seçilip seçilmediğini doğrula."

#: ../../theory/naive-blockchain.rst:459 ../../theory/naive-blockchain.rst:478
msgid ""
"run the fork-choice for the protocol state derived from justifications of "
":math:`m`"
msgstr ""
":math:`m` gerekçelerinden türetilen protokol durumu için fork-choice'i "
"çalıştır"

#: ../../theory/naive-blockchain.rst:461
msgid "compare calculated parents with actual parent of :math:`m`:"
msgstr ""
"Hesaplanan üst ögeleri, :math:`m`'in gerçek üst ögeleri ile karşılaştır"

#: ../../theory/naive-blockchain.rst:463 ../../theory/naive-blockchain.rst:481
msgid "if they are the same: append :math:`m` to :math:`blockdag`."
msgstr "Eğer aynı iseler: :math:`m`'i, :math:`blockdag`'e ekle."

#: ../../theory/naive-blockchain.rst:464 ../../theory/naive-blockchain.rst:482
msgid "otherwise - drop the block (invalid block) and exit"
msgstr "değilse - bloğu bırak (geçersiz blok) ve çık"

#: ../../theory/naive-blockchain.rst:466
msgid ""
"Check if parents of :math:`m` are not conflicting. If they are conflicting, "
"then drop the block (invalid block) and exit."
msgstr ""
":math:`m` ögesinin üst ögelerinin çelişkili olup olmadığını kontrol et. "
"Çakışıyorlarsa, bloğu bırak (geçersiz blok) ve çık."

#: ../../theory/naive-blockchain.rst:468
msgid ""
"Calculate pre-state for :math:`m` by executing the transactions in the "
"merged history that is determined by all parents of :math:`m`. Check if "
"calculated hash of pre-state is equal to pre-state-hash stored in :math:`m`."
" If not, then drop :math:`m` (invalid block) and exit."
msgstr ""
":math:`m`'in tüm üst ögeleri tarafından belirlenen birleştirilmiş geçmişteki"
" işlemleri yürüterek :math:`m` için ön durumu hesapla. Ön durumun "
"hesaplanmış özetinin :math:`m`'de depolanan pre-state-hash'e eşit olup "
"olmadığını kontrol et. Eğer değilse, :math:`m`'i bırak (geçersiz blok) ve "
"çık."

#: ../../theory/naive-blockchain.rst:470
msgid ""
"Calculate post-state for :math:`m` by sequentially applying all transactions"
" in :math:`m` on top of global state calculated in step (3). Check if "
"calculated hash of post-state is equal to post-state-hash stored in "
":math:`m`. If not, then drop :math:`m` (invalid block) and exit."
msgstr ""
"Adım (3)'te hesaplanan küresel durumun üstüne :math:`m' içindeki tüm "
"işlemleri sırayla uygulayarak :math:`m` için durum sonrasını hesapla. "
"Hesaplanan durum sonrası özeti değerinin, :math:`m`'de saklanan post-state-"
"hash değerine eşit olup olmadığını kontrol et. Değilse, :math:`m` (geçersiz "
"blok) ögesini bırak ve çık."

#: ../../theory/naive-blockchain.rst:472
msgid "Store post-state calculated in step (4) in :math:`global\\_states\\_db`."
msgstr ""
"Adım(4)'te hesaplanan durum sonrasını :math:`global\\_states\\_db`'de "
"depola."

#: ../../theory/naive-blockchain.rst:474
msgid "If :math:`m` is a ballot:"
msgstr "Eğer :math:`m` bir oy pusulası ise:"

#: ../../theory/naive-blockchain.rst:476
msgid "Validate whether :math:`m.target\\_block` was selected correctly:"
msgstr ""
":math:`m.target\\_block`'un doğru şekilde seçilip seçilmediğini doğrula:"

#: ../../theory/naive-blockchain.rst:479
msgid ""
"compare calculated main parent candidate with actual "
":math:`m.target\\_block`:"
msgstr ""
"Hesaplanan ana üst öge adayını gerçek :math:`m.target\\_block` ile kıyasla:"

#: ../../theory/naive-blockchain.rst:484
msgid "**Publishing loop:**"
msgstr "**Yayınlama döngüsü:**"

#: ../../theory/naive-blockchain.rst:486
msgid ""
"Sleep unless the next time for proposing a block arrives (typically this may"
" be a periodic activity based on wall clock)."
msgstr ""
"Blok önerme gelmedikçe uyu (tipik olarak bu, duvar saatine dayalı periyodik "
"bir aktivite olabilir)."

#: ../../theory/naive-blockchain.rst:488
msgid ""
"Run fork-choice against the current blockdag (see next section). The result "
"is:"
msgstr ""
"Şu anki blockdag'e karşılık fork-choice'i çalıştır (sonraki kısma bakınız). "
"Sonuç şu şekildedir:"

#: ../../theory/naive-blockchain.rst:490
msgid "Main parent - :math:`mp`."
msgstr "Ana üst öge - :math:`mp`."

#: ../../theory/naive-blockchain.rst:491
msgid "Collection of secondary parents - :math:`sp` - sorted by preference."
msgstr "İkincil üst ögelerin toplamı - :math:`sp` - tercihe göre sıralı."

#: ../../theory/naive-blockchain.rst:493
msgid ""
"Pick the maximal non-conflicting subset :math:`mncsp \\subset sp`, "
"respecting the selection of :math:`mp` and the ordering of :math:`sp`."
msgstr ""
":math:`mp` seçimine ve :math:`sp` sıralamasına uyarak, çakışmayan maksimum "
"alt kümeyi :math:`mncsp \\subset sp` seç."

#: ../../theory/naive-blockchain.rst:495
msgid ""
"Calculate merged global state :math:`merged\\_gs` derived from "
":math:`\\{mp\\} \\cup mncsp`."
msgstr ""
":math:`\\{mp\\} \\cup mncsp`'den türetilen, :math:`merged\\_gs` "
"birleştirilmiş küresel durumu hesaplayın."

#: ../../theory/naive-blockchain.rst:497
msgid ""
"Check the weight of local validator in merged global state: "
":math:`weights\\_map(merged\\_gs)(vid)`"
msgstr ""
"Birleştirilmiş küresel durumda yerel doğrulayıcının ağırlığını kontrol edin:"
" :math:`weights\\_map(merged\\_gs)(vid)`"

#: ../../theory/naive-blockchain.rst:499
msgid ""
"If weight is non-zero and :math:`deploys-buffer` is nonempty, we will be "
"creating and publishing a new block."
msgstr ""
"Eğer ağırlık sıfırdan farklı ise ve :math:`deploys-buffer`, boş değilse, "
"yeni bir blok oluşturup yayınlıyor olacağız."

#: ../../theory/naive-blockchain.rst:501
msgid "otherwise - check the status of local validator:"
msgstr "değilse - yerel doğrulayıcının durumunu kontrol et:"

#: ../../theory/naive-blockchain.rst:503
msgid "VOTING_ONLY => create and publish a new ballot"
msgstr "VOTING_ONLY => yeni bir oy pusulası oluştur ve yayınla"

#: ../../theory/naive-blockchain.rst:504
msgid "otherwise => exit"
msgstr "aksi halde => çıkış"

#: ../../theory/naive-blockchain.rst:506
msgid "Case 1: new block"
msgstr "Durum 1: yeni blok"

#: ../../theory/naive-blockchain.rst:508
msgid ""
"Take desired subset of transactions :math:`trans` from :math:`deploys-"
"buffer` (this part of behavior is subject to a separate spec; on this level "
"of abstraction we accept any strategy of picking transactions from the "
"buffer)."
msgstr ""
":math:`deploys-buffer`'dan :math:`trans` istenen işlemler alt kümesini al "
"(davranışın bu kısmı ayrı bir spesifikasyona tabidir; soyutlamanın bu "
"seviyesinde arabellekten işlem seçmenin herhangi bir stratejisini kabul "
"ediyoruz). "

#: ../../theory/naive-blockchain.rst:509
msgid ""
"Apply :math:`trans` sequentially on top of :math:`merged\\_gs`. Let "
":math:`post\\_gs` be the resulting global state."
msgstr ""
":math:`merged\\_gs` üzerine :math:`trans` sıralı olarak uygula. "
":math:`post\\_gs` sonuç küresel durumu olacaktır."

#: ../../theory/naive-blockchain.rst:510
msgid "Create new block:"
msgstr "Yeni blok oluştur:"

#: ../../theory/naive-blockchain.rst:512 ../../theory/naive-blockchain.rst:528
msgid "block id = hash of the binary representation of this block"
msgstr "blok kimliği = bu bloğun ikili kodlu gösteriminin özeti"

#: ../../theory/naive-blockchain.rst:513 ../../theory/naive-blockchain.rst:529
msgid "creator id = :math:`vid`"
msgstr "oluşturan kimliği = :math:`vid`"

#: ../../theory/naive-blockchain.rst:514
msgid "main parent = :math:`mp`"
msgstr "ana üst öge = :math:`mp`"

#: ../../theory/naive-blockchain.rst:515
msgid "secondary parents = :math:`mncsp`"
msgstr "ikincil üst ögeler = :math:`mncsp`"

#: ../../theory/naive-blockchain.rst:516
msgid ""
"justifications = :math:`latest\\_honest\\_messages` after removing main "
"parent, secondary parents, and redundant messages (see explanation below)"
msgstr ""
"gerekçeler = :math:`latest\\_honest\\_messages` ana üst ögenin kaldrılması "
"sonrasında, ikincil üst ögeler, ve fazlalık mesajlar (aşağıda açıklamasını "
"bulabilirsiniz)"

#: ../../theory/naive-blockchain.rst:517
msgid "transactions list = :math:`trans`"
msgstr "işlemler listesi =  :math:`trans`"

#: ../../theory/naive-blockchain.rst:518
msgid "pre-state-hash = :math:`hash(merged\\_gs)`"
msgstr "pre-state-hash = :math:`hash(merged\\_gs)`"

#: ../../theory/naive-blockchain.rst:519
msgid "post-state hash = :math:`hash(post\\_gs)`"
msgstr "durum sonrası özeti = :math:`hash(post\\_gs)`"

#: ../../theory/naive-blockchain.rst:521
msgid "Store :math:`post\\_gs` in :math:`global\\_states\\_db`"
msgstr ":math:`post\\_gs`'yi :math:`global\\_states\\_db`'de depola"

#: ../../theory/naive-blockchain.rst:522
msgid "Broadcast new block across validators P2P network."
msgstr "Doğrulayıcılar P2P ağı genelinde yeni blok yayınlayın."

#: ../../theory/naive-blockchain.rst:524
msgid "Case 2: new ballot"
msgstr "Durum 2: yeni oy pusulası"

#: ../../theory/naive-blockchain.rst:526
msgid "Create new ballot:"
msgstr "Yeni oy pusulası oluştur:"

#: ../../theory/naive-blockchain.rst:530
msgid "target block = :math:`mp`"
msgstr "hedef blok = :math:`mp`"

#: ../../theory/naive-blockchain.rst:531
msgid ""
"justifications = :math:`latest\\_honest\\_messages` after removing: target "
"block and redundant messages (see explanation below)"
msgstr ""
"gerekçeler = :math:`latest\\_honest\\_messages` şunları kaldırınca: hedef "
"blok ve fazlalık mesajlar (açıklamasını aşağıda bulabilirsiniz)"

#: ../../theory/naive-blockchain.rst:533
msgid "Broadcast new ballot across validators P2P network."
msgstr "Doğrulayıcılar P2P ağı genelinde yeni oy pusulası yayınlayın."

#: ../../theory/naive-blockchain.rst:535
msgid ""
"Note: we generally want to keep the collection :math:`m.justifications` as "
"short as possible. For this, we never include there main parent, secondary "
"parents, and target block. Also, we want the collection of justifications "
"included in the message to be transitively reduced (= included "
"justifications form an antichain)."
msgstr ""
"Not: Biz genellikle :math:`m.justifications` toplamını mümkün olduğunca kısa"
" tutmak isteriz. Bunun için asla ana üst öge, ikincil üst ögeler ve hedef "
"bloğu dahil etmiyoruz. Ayrıca, mesaja dahil edilen gerekçeler toplamının "
"geçişli olarak azaltılmasını istiyoruz (= dahil edilen gerekçeler bir "
"antizincir oluşturur)."

#: ../../theory/naive-blockchain.rst:539
msgid "Relative votes"
msgstr "Göreceli oylar"

#: ../../theory/naive-blockchain.rst:541
msgid ""
"We will need the concept of “last message created by validator **v** that "
"was a non-empty vote in **b-game**”. Given any block :math:`b` and any "
"validator :math:`V` let us take look at the swimlane of :math:`V`. If "
":math:`v` is honest, then this swimlane is a chain. Any message :math:`m` "
"counts as a non-empty vote in **b-game** only if:"
msgstr ""
"“**b-oyunu**'nda boş olmayan oy olan **v** doğrulayıcısı tarafından "
"oluşturulan son mesaj” kavramına ihtiyacımız olacak. Herhangi bir :math:`b` "
"bloğu ve herhangi bir doğrulayıcı :math:`V` verilsin, :math:`V`'nin "
"kulvarına bakalım. Eğer :math:`v`, dürüst ise, bu kulvar bir zincirdir. "
"Sadece şu durumlarda, :math:`m` **b-oyunu**'nda boş olmayan bir oy olarak "
"sayılır:"

#: ../../theory/naive-blockchain.rst:543
msgid ""
":math:`m` is a block and the ancestor of :math:`m` (in main-tree) is "
":math:`b`"
msgstr ""
":math:`m` bir bloktur ve :math:`m`'in (ana ağaçta) üst soyu :math:`b`'dir."

#: ../../theory/naive-blockchain.rst:544
msgid ""
":math:`m` is a ballot and the ancestor of :math:`m.target\\_block` (in main-"
"tree) is :math:`b`"
msgstr ""
":math:`m` bir oy pusulasıdır ve :math:`m.target\\_block`'un (ana ağaçta) üst"
" soyu :math:`b`'dir"

#: ../../theory/naive-blockchain.rst:546
msgid ""
"We start from the latest (= top-most on the diagram) message in the "
":math:`swimlane(v)` and we traverse the swimlane down, stopping as soon as "
"we find a message that counts as a non-empty vote in **b-game**."
msgstr ""
":math:`swimlane(v)` 'deki en son (=şemada en üst) mesajdan başlarız ve "
"**b-oyunu**'nda boş olmayan olarak sayılabilecek bir mesaj  bulana kadar "
"aşağı doğru kulvarın üzerinden geçeriz, "

#: ../../theory/naive-blockchain.rst:548
msgid "\\ **Example:**\\"
msgstr "\\ **Örnek:**\\"

#: ../../theory/naive-blockchain.rst:550
msgid ""
"Below is the original example of the blockdag, but with all messages that "
"are non-empty votes in 3-game highlighted with green:"
msgstr ""
"Blockdag'in orijinal örneği aşağıdadır, ancak 3-oyunda boş oy olmayan tüm "
"mesajlar yeşil ile vurgulanmıştır:"

#: ../../theory/naive-blockchain.rst:556 ../../theory/naive-blockchain.rst:763
msgid "**Example:**"
msgstr "**Örnek:**"

#: ../../theory/naive-blockchain.rst:558
msgid "Let us again look at the example of a blockdag:"
msgstr "Tekrar blockdag örneğine bakalım:"

#: ../../theory/naive-blockchain.rst:564
msgid ""
"Let’s apply this definition using validator 3 as the example and find the "
"last votes of validator 3 in various games."
msgstr ""
"Bu tanımı, doğrulayıcı 3'ü örnek olarak kullanarak uygulayalım ve çeşitli "
"oyunlarda doğrulayıcı 3'ün son oylarını bulalım."

#: ../../theory/naive-blockchain.rst:567
msgid "Block b"
msgstr "Blok b"

#: ../../theory/naive-blockchain.rst:567
msgid "Last non-empty vote of validator 3 in b-game"
msgstr "b-oyununda doğrulayıcı 3'ün boş olmayan son oyu"

#: ../../theory/naive-blockchain.rst:569
msgid "Genesis"
msgstr "Doğuş (genesis)"

#: ../../theory/naive-blockchain.rst:569 ../../theory/naive-blockchain.rst:571
#: ../../theory/naive-blockchain.rst:574
msgid "14"
msgstr "14"

#: ../../theory/naive-blockchain.rst:570
msgid "1"
msgstr "1"

#: ../../theory/naive-blockchain.rst:570 ../../theory/naive-blockchain.rst:572
msgid "9"
msgstr "9"

#: ../../theory/naive-blockchain.rst:571
msgid "2"
msgstr "2"

#: ../../theory/naive-blockchain.rst:572
msgid "3"
msgstr "3"

#: ../../theory/naive-blockchain.rst:573
msgid "4"
msgstr "4"

#: ../../theory/naive-blockchain.rst:573 ../../theory/naive-blockchain.rst:575
msgid "(none)"
msgstr "(yok)"

#: ../../theory/naive-blockchain.rst:574
msgid "5"
msgstr "5"

#: ../../theory/naive-blockchain.rst:575
msgid "6"
msgstr "6"

#: ../../theory/naive-blockchain.rst:579
msgid "Fork choice"
msgstr "Fork choice"

#: ../../theory/naive-blockchain.rst:581
msgid ""
"The goal of fork-choice is to take the decision on top of the version of the"
" shared database history we want to build in the next step. This decision "
"can be seen as an iterative application of the reference estimator from the "
"“Abstract Casper Consensus”. As a result we want to get a list of blocks "
"(ordered by preference) which will serve as parent candidates for the new "
"block."
msgstr ""
"Fork-choice'in amacı, bir sonraki adımda oluşturmak istediğimiz paylaşılan "
"veritabanı geçmişinin sürümünün üzerine karar vermektir. Bu karar, “Özet "
"Casper Mutabakatı”ndan referans tahmincisinin yinelemeli bir uygulaması "
"olarak görülebilir. Sonuç olarak, yeni blok için üst öge adayları olarak "
"hizmet edecek blokların (tercihe göre sıralanmış) bir listesini almak "
"istiyoruz."

#: ../../theory/naive-blockchain.rst:583
msgid "The algorithm goes as follows:"
msgstr "Algoritma şu şekilde devam eder:"

#: ../../theory/naive-blockchain.rst:585
msgid ""
"Decide which protocol state :math:`ps` to use: 1. When using fork choice for"
" creation of new block this is the point where the validator can decide on "
"the subset of his local knowledge to reveal to outside world. Ideally, the "
"validator reveals all local knowledge, so it takes as protocol state the "
"whole local blockdag."
msgstr ""
"Hangi :math:`ps` protokol durumunun kullanılacağına karar ver: 1. Yeni blok "
"oluşturmak için fork choice kullanırken bu, doğrulayıcının yerel bilgisinin "
"alt kümesini dış dünyaya göstermek için karar verebileceği noktadır. İdeal "
"olarak, doğrulayıcı tüm yerel bilgileri ortaya çıkarır, bu nedenle protokol "
"durumu olarak tüm yerel blockdag'i alır."

#: ../../theory/naive-blockchain.rst:588
msgid ""
"When using fork choice for validation of received message :math:`m`, the "
"protocol state to take is :math:`j\\_past\\_cone(m)`."
msgstr ""
"Alınan :math:`m` mesajının doğrulaması için fork choice kullanırken, "
"alınması gereken protokol durumu :math:`j\\_past\\_cone(m)`'dir."

#: ../../theory/naive-blockchain.rst:590
msgid ""
"Take :math:`HV` - all honest validators (all creators of messages in "
":math:`ps` minus those seen equivocating with messages in :math:`ps`)."
msgstr ""
":math:`HV`'yi al - tüm dürüst doğrulayıcılar (:math:`ps`'deki mesajların tüm"
" oluşturucuları eksi :math:`ps` ile çelişkili görülenler)."

#: ../../theory/naive-blockchain.rst:591
msgid ""
"Find latest message :math:`lm(v)` created by each validator :math:`v \\in "
"HV`, ignoring validators that produced no message."
msgstr ""
"Hiç mesaj üretmemiş doğrulayıcıları görmezden gelerek, her bir :math:`v \\in"
" HV` doğrulayıcı tarafından oluşturulan son mesajları :math:`lm(v)` bul."

#: ../../theory/naive-blockchain.rst:592
msgid "For all validators that have :math:`lm(v)` defined take:"
msgstr "Tanımlı :math:`lm(v)` sahip tüm doğrulayıcılar için şu şekilde al:"

#: ../../theory/naive-blockchain.rst:594
msgid ""
"tipBlock(v)=\\begin{cases} lm(v), & lm(v) \\space is \\space a \\space block"
" \\\\lm(v).target\\_block, & otherwise \\end{cases}"
msgstr ""
"tipBlock(v)=\\begin{cases} lm(v), & lm(v) \\space bir \\space  \\space blok "
"\\\\lm(v).target\\_block, & yoksa \\end{cases}"

#: ../../theory/naive-blockchain.rst:599
msgid ""
"Take :math:`lca\\_block` = latest common ancestor along main-tree of all "
":math:`tipBlock(v)`"
msgstr ""
":math:`lca\\_block` = :math:`tipBlock(v)`'nin ana ağaç boyunca en son ortak "
"üst soyu olarak al"

#: ../../theory/naive-blockchain.rst:601
msgid ""
"Initialize resulting collection of blocks as one-element list :math:`Result "
"= [lca\\_block]`"
msgstr ""
"Elde edilen blok toplamını, bir elemanlı liste olarak olarak başlat "
":math:`Result = [lca\\_block]`"

#: ../../theory/naive-blockchain.rst:603
msgid ""
"For each block :math:`b` in :math:`Result` replace :math:`b` with its direct"
" children in main-tree: :math:`c_1, c_2, ..., c_n`, where the list of "
"children is ordered following this recipe:"
msgstr ""
":math:`Result`'taki her bir :math:`b` bloğu için, :math:`b`'yi ana ağaçtaki "
"kendisinin direkt alt ögesi ile değiştir: :math:`c_1, c_2, ..., c_n` ki "
"burada alt ögeler şu tarife göre sıralanmıştır:"

#: ../../theory/naive-blockchain.rst:605
msgid ""
"For each honest validator :math:`v` find :math:`lmb(v)` - the last message "
"by :math:`v` voting in **b-game.**"
msgstr ""
"Her bir :math:`v` dürüst doğrulayıcı için :math:`lmb(v)`'yi bul - "
"**b-oyunu**nda oy kullanan :math:`v`'nin son mesajı."

#: ../../theory/naive-blockchain.rst:607
msgid ""
"Find a child :math:`c_i` that :math:`lmb(v)` is voting for - by traversing "
"down the main-tree."
msgstr ""
"Ana ağaç boyunca takip ederek, :math:`lmb(v)`'nin oy kullandığı bir "
":math:`c_i` alt ögesi bul."

#: ../../theory/naive-blockchain.rst:609
msgid "Using :math:`validator\\_weights(b)` count the votes."
msgstr ":math:`validator\\_weights(b)`'yi kullanarak oyları say."

#: ../../theory/naive-blockchain.rst:611
msgid ""
"Order the sequence :math:`c_i` by calculated votes, using :math:`ci.id` (= "
"block hash) as tie-breaker."
msgstr ""
":math:`ci.id`'yi (= blok özeti) eşitliği bozen set olarak kullanarak "
":math:`c_i`'yi hesaplanan oylara göre sırala. "

#: ../../theory/naive-blockchain.rst:613
msgid "Repeat step 7 as long as it is changing **Result**."
msgstr "**Sonuc**u değiştirene kadar adım 7'yi tekrarla."

#: ../../theory/naive-blockchain.rst:615
msgid ""
"The **Result** is the list of blocks we want. The first block on the list is"
" the main parent candidate, remaining blocks are secondary parents "
"candidates."
msgstr ""
"**Sonuç** bizim istediğimiz blokların listesidir. Listedeki ilk blok, ana "
"üst öge adayıdır, kalan bloklar ikincil üst öge adaylarıdır."

#: ../../theory/naive-blockchain.rst:618
msgid "Operation of a finalizer"
msgstr "Kesinleştiricinin çalışması"

#: ../../theory/naive-blockchain.rst:621
msgid "The objective"
msgstr "Amaç"

#: ../../theory/naive-blockchain.rst:623
msgid ""
"Finalizer observes the growing blockchain. The objective is to recognize the"
" subset of transactions history that:"
msgstr ""
"Kesinleştirici, büyüyen blok zincirini gözlemler. Amaç, işlem geçmişinin alt"
" kümesini tanımaktır ki bu alt küme:"

#: ../../theory/naive-blockchain.rst:625
msgid "is already agreed (as a result of on-going consensus)"
msgstr ""
"halihazırda kararlaştırılmıştır (devam eden bir mutabakatın sonucu olarak)"

#: ../../theory/naive-blockchain.rst:626
msgid ""
"cannot be reverted (unless the equivocators collection exceeds - by total "
"weight - predefined threshold)"
msgstr ""
"geri çevrilemez (çelişkililer toplamı - toplam ağırlık olarak - önceden "
"tanımlanmış eşiği aşmıyorsa)"

#: ../../theory/naive-blockchain.rst:629
msgid "Parameters"
msgstr "Parametreler"

#: ../../theory/naive-blockchain.rst:631
msgid ""
"In general - different finalizers will be based on different finality "
"criteria. For the current design we assume that the criterion described in "
"the previous chapter is in use."
msgstr ""
"Genel olarak - farklı kesinleştiriciler farklı kesinlik kritererini baz "
"alacaklardır. Şu anki tasarım için, önceki kısımda açıklanan kriterlerin "
"kullanımda olacağını varsayıyoruz. "

#: ../../theory/naive-blockchain.rst:633
msgid "Hence, the finalizer is parameterized by:"
msgstr "Sonuç olarak, kesinleştirici şu şekilde parametrelerle açıklanabilir:"

#: ../../theory/naive-blockchain.rst:635
msgid "the type of finality detector to be used"
msgstr "kullanılacak kesinlik algılayıcının türü"

#: ../../theory/naive-blockchain.rst:637
msgid "**K** - acknowledgement level"
msgstr "**K** - onay seviyesi"

#: ../../theory/naive-blockchain.rst:639
msgid "**WP** (weight percentage) - expressed as a number between 0 and 1"
msgstr "**WP** (ağırlık yüzdesi) - 0 ila 1 arasında bir sayı ile ifade edilir"

#: ../../theory/naive-blockchain.rst:642
msgid "State"
msgstr "Durum"

#: ../../theory/naive-blockchain.rst:644
msgid ""
"The assumption is that a finalizer can traverse the blockdag, reading "
"contents of blocks. Also, for any block b it should be able to read post-"
"state of b, and in particular get the weights-map from this post-state."
msgstr ""
"Varsayım, bir kesinleştiricinin blockdag'i geçerek blokların içeriğini "
"okuyabileceğidir. Ayrıca, herhangi bir b bloğu için b'nin durum sonrasını "
"okuyabilmeli ve özellikle bu durum sonrasından ağırlık haritasını "
"alabilmelidir."

#: ../../theory/naive-blockchain.rst:646
msgid ""
"The internal state of the “reference” implementation of a finalizer would "
"be:"
msgstr ""
"Bir kesinleştiricinin \"referans\" uygulamasının dahili durumu şöyle "
"olacaktır:"

#: ../../theory/naive-blockchain.rst:648
msgid "**equivocators: Set[ValidatorId]**"
msgstr "**equivocators: Set[ValidatorId]**"

#: ../../theory/naive-blockchain.rst:650
msgid "**current-game-id: Int**"
msgstr "**current-game-id: Int**"

#: ../../theory/naive-blockchain.rst:652
msgid ""
"current finality detector instance - the one observing **LFB(current-game-"
"id)-game**"
msgstr ""
"mevcut kesinlik algılayıcı örneği - **LFB(current-game-id)-game** "
"gözlemleyen örnek"

#: ../../theory/naive-blockchain.rst:654
msgid "**LFB: Seq[Block]** for **i=0 … current-game-id**"
msgstr "**i=0 … current-game-id** için **LFB: Seq[Block]** "

#: ../../theory/naive-blockchain.rst:656
msgid "**initial-players: Seq[Set[ValidatorId]]**"
msgstr "**initial-players: Seq[Set[ValidatorId]]**"

#: ../../theory/naive-blockchain.rst:658
msgid "**excluded-players: Seq[Set[ValidatorId]]**"
msgstr "**excluded-players: Seq[Set[ValidatorId]]**"

#: ../../theory/naive-blockchain.rst:660
msgid "**FTT: Seq[Int]**"
msgstr "**FTT: Seq[Int]**"

#: ../../theory/naive-blockchain.rst:662
msgid ""
"Initial state (on the beginning of the blockchain, the only block is "
"Genesis):"
msgstr ""
"Başlangıç durumu (blok zincirinin başlangıcındaki tek blok Genesis'tir):"

#: ../../theory/naive-blockchain.rst:664
msgid "**equivocators** = empty set"
msgstr "**equivocators** = boş küme"

#: ../../theory/naive-blockchain.rst:665
msgid "**current-game-id** = 0"
msgstr "**current-game-id** = 0"

#: ../../theory/naive-blockchain.rst:666
msgid ""
"current finality detector instance = new instance (according to configured "
"type of finality detector to be used)"
msgstr ""
"mevcut kesinlik algılayıcı örneği = yeni örnek (kullanılacak yapılandırılmış"
" kesinlik algılayıcı tipine göre)"

#: ../../theory/naive-blockchain.rst:667
msgid "**LFB** = empty sequence"
msgstr "**LFB** = boş sıra"

#: ../../theory/naive-blockchain.rst:668
msgid ""
"**initial-players** = one element sequence, with the single element being "
"the set of ids of validators bonded at Genesis"
msgstr ""
"**initial-players** = tek eleman Genesis'e bağlı doğrulayıcıların kimlikleri"
" kümesi olmak üzere, tek öge dizisi "

#: ../../theory/naive-blockchain.rst:670
msgid ""
"**excluded-players** = one element sequence, with the single element being "
"the empty set"
msgstr ""
"**excluded-players** = tek eleman boş küme olmak üzere, tek öge dizisi"

#: ../../theory/naive-blockchain.rst:672
msgid "**FTT(0) = ceiling(WP \\* total-weight(post-state of Genesis))**"
msgstr "**FTT(0) = ceiling(WP \\* total-weight(post-state of Genesis))**"

#: ../../theory/naive-blockchain.rst:675
msgid "Behaviour - the general plan"
msgstr "Davranış - genel plan"

#: ../../theory/naive-blockchain.rst:677
msgid ""
"The operation of a finalizer can be decomposed as the following, partially "
"independent activities:"
msgstr ""
"Kesinleştiricinin çalışması aşağıdaki şekilde kısmen bağımsız aktiviteler "
"olarak parçalara ayrılabilir:"

#: ../../theory/naive-blockchain.rst:679
msgid ""
"Maintaining equivocators collection corresponding to current protocol state."
msgstr "Şu anki protokol durumuna karşılık çelişkililer toplamını korumak."

#: ../../theory/naive-blockchain.rst:680
msgid "Building the **LFB** chain"
msgstr "**LFB** zincirini inşa etmek"

#: ../../theory/naive-blockchain.rst:681
msgid ""
"Propagating **LFB** chain finality via secondary parents (indirect "
"finalization)."
msgstr ""
"**LFB** zinciri kesinliğinin ikincil üst ögeler aracılığıyla yayılması "
"(dolaylı kesinleştirme)."

#: ../../theory/naive-blockchain.rst:682
msgid ""
"Monitoring old games in **LFB** chain for the possibility of equivocation "
"catastrophe."
msgstr ""
"Çelişkili davranış felaketi olasılığı için **LFB** zincirindeki eski "
"oyunların izlenmesi."

#: ../../theory/naive-blockchain.rst:683
msgid ""
"Reacting to equivocation catastrophe (by recalculating the **LFB** chain)."
msgstr ""
"Çelişkili davranış felaketine tepki vermek (**LFB** zincirini tekrar "
"hesaplayarak)."

#: ../../theory/naive-blockchain.rst:684
msgid ""
"Publishing the stream of finalized blocks (over some streaming API) - this "
"includes possibly also maintaining the collection of subscribers."
msgstr ""
"Kesinleşmiş blokların akışını yayınlamak (bazı akış API'ları üzerinden) - "
"buna muhtemelen abone koleksiyonunun korunması da dahildir."

#: ../../theory/naive-blockchain.rst:687
msgid "LFB chain"
msgstr "LFB zinciri"

#: ../../theory/naive-blockchain.rst:689
msgid ""
"**LFB(i)** is supposed to be the “i-th last finalized block”. **LFB** chain "
"is achieved in the following way:"
msgstr ""
"**LFB(i)** “i-inci son kesinleşmiş blok” manasına gelmektedir. **LFB** "
"zinciri şu şekilde elde edilir:"

#: ../../theory/naive-blockchain.rst:691
msgid "Take **LFB(0) = Genesis**"
msgstr "**LFB(0) = Genesis** olarak al"

#: ../../theory/naive-blockchain.rst:693
msgid ""
"Let’s assume that LFB(m) is the last-so-far element of the chain. So in "
"other words, it is the last finalized block."
msgstr ""
"LFB(m)'nin zincirin şimdiye kadarki son elemanı olduğunu varsayalım. Yani "
"başka bir deyişle, son kesinleşmiş bloktur."

#: ../../theory/naive-blockchain.rst:695
msgid ""
"For deciding which main-tree child of LFB(m) should be taken as LFB(m+1) we "
"need to start a new empty instance of finality detector."
msgstr ""
"LFB(m)'nin hangi ana ağaç alt öğesinin LFB(m+1) olarak alınması gerektiğine "
"karar vermek için yeni bir boş kesinlik algılayıcı örneği başlatmamız "
"gerekir."

#: ../../theory/naive-blockchain.rst:697
msgid ""
"**initial-players(m)** = validators staked at post-state of **m**, excluding"
" current contents of **equivocators**"
msgstr ""
"**çelişkililer**in şu anki içeriğini hariç tutarak, **initial-players(m)** ="
" **m**'in durum sonrasında stake edilen doğrulayıcıları"

#: ../../theory/naive-blockchain.rst:699
msgid "**excluded-players(m)** = empty set"
msgstr "**excluded-players(m)** = boş küme"

#: ../../theory/naive-blockchain.rst:701
msgid "Finality detector observes the LFB(m)-game, with:"
msgstr "Kesinlik algılayıcı LFB(m)-game'i şununla gözlemler:"

#: ../../theory/naive-blockchain.rst:703
msgid ""
"game-level acknowledgement level **K** same as defined by parameters of this"
" finalizer"
msgstr ""
"oyun seviyesi onay seviyesi **K** bu kesinleştiricinin parametreleri "
"tarafından tanımlananla aynı"

#: ../../theory/naive-blockchain.rst:705
msgid ""
"**FTT(m) = ceiling(WP \\* total-weight(post-state of m))**, where "
"\\**ceiling(_)*\\* is integer rounding towards positive infinity."
msgstr ""
"**FTT(m) = ceiling(WP \\* total-weight(post-state of m))**, ki burada "
"\\**ceiling(_)*\\* pozitif sonsuza doğru yuvarlanan tam sayıdır."

#: ../../theory/naive-blockchain.rst:707
msgid ""
"Once **LFB(m)**-game reaches finality, the next element of **LFB** chain is "
"established."
msgstr ""
"**LFB(m)**-game sona erdiğinde, **LFB** zincirinin bir sonraki öğesi "
"kurulur."

#: ../../theory/naive-blockchain.rst:710
msgid "Indirect finalization"
msgstr "Dolaylı kesinleştirme"

#: ../../theory/naive-blockchain.rst:712
msgid ""
"Once **LFB(m)** is established, we consider the whole **p-past-"
"cone(LFB(m))** as finalized."
msgstr ""
"**LFB(m)** kurulduğunda, tüm **p-past-cone(LFB(m))** 'nin kesinleştiğini "
"düşünürüz."

#: ../../theory/naive-blockchain.rst:715
msgid "Equivocation catastrophe"
msgstr "Çelişkili davranış felaketi"

#: ../../theory/naive-blockchain.rst:717
msgid ""
"For any **LFB(m)**, the **LFB(m)-game** may “crash” by total weight of "
"equivocators exceeding **FTT(m)**. Such situation we call **the equivocation"
" catastrophe**."
msgstr ""
"Herhangi bir **LFB(m)** için, **LFB(m)-game**, çelişkililerin **FTT(m)**'yi "
"aşması ile \"çökebilir\". Bu duruma **çelişkili davranış felaketi** diyoruz."

#: ../../theory/naive-blockchain.rst:719
msgid ""
"Discovery of equivocation catastrophe works as follows. -- Whenever a new "
"message **m** is added to a local blockdag, the following handling is done "
"by the finalizer:"
msgstr ""
"Çelişkili davranış felaketinin keşfi aşağıdaki gibi çalışır. -- Yerel bir "
"blockdag'e yeni bir **m** mesajı eklendiğinde, kesinleştirici tarafından "
"aşağıdaki işlemler yapılır:"

#: ../../theory/naive-blockchain.rst:721
msgid ""
"If **m.creator** is already included in **equivocators** collection - do "
"nothing."
msgstr ""
"Eğer **m.creator**, zaten **çelişkililer* toplamında dahil ise - hiçbirşey "
"yapma."

#: ../../theory/naive-blockchain.rst:723
msgid ""
"Otherwise - check if m is not introducing a new equivocation. If yes - add "
"**m.creator** to equivocators and:"
msgstr ""
"Değilse - m'in yeni bir çelişkili davranış getirmediğini kontrol et. Eğer "
"cevap evet ise - **m.creator**'u çelişkililere ekle ve:"

#: ../../theory/naive-blockchain.rst:725
msgid "for every i such that m \\in initial-players(i):"
msgstr "m \\in initial-players(i) şeklindeki her bir i için:"

#: ../../theory/naive-blockchain.rst:727
msgid "add m to **excluded-players(i)**"
msgstr "m'i **excluded-players(i)**'a ekle"

#: ../../theory/naive-blockchain.rst:729
msgid ""
"using weights map from **LFB(i)** post-state, check if total weight of "
"**excluded-players(i)** exceeds **FTT(i)**"
msgstr ""
"**LFB(i)** durum sonrasından ağırlık eşleştirmelerini kullanarak, "
"**excluded-players(i)**'ın ağırlığının **FTT(i)**'ı aşıp aşmadığını kontrol "
"et"

#: ../../theory/naive-blockchain.rst:731
msgid ""
"if for some **LFB(i)** exceeding **FTT(i)** case happened - take the "
"smallest such **i** - we will call the block **LFB(i)** **the catastrophic "
"point**"
msgstr ""
"Eğer bazı **LFB(i)**'lar için **FTT(i)**'ı aşma durumu gerçekleşti ise - "
"**i** için en düşüğü al - **LFB(i)** bloğuna **felaket noktası** diyeceğiz"

#: ../../theory/naive-blockchain.rst:733
msgid ""
"Once an equivocation catastrophe is discovered, the following handling must "
"be applied:"
msgstr ""
"Bir çelişkili davranış felaketi keşfedildiğinde, aşağıdaki işlem "
"uygulanmalıdır:"

#: ../../theory/naive-blockchain.rst:735
msgid ""
"Starting from the catastrophic point, re-calculate the **LFB chain** "
"(initializing initial players accordingly to current contents of "
"**equivocators**)."
msgstr ""
"Felaket noktasından başlayarak, **LFB zincirini** yeniden hesapla (ilk "
"oyuncuları mevcut **çelişkililer**in içeriğine göre başlatarak)."

#: ../../theory/naive-blockchain.rst:736
msgid ""
"2. Find the first **i** such that the new LFB-chain differs from old LFB "
"chain at index **i**. Usually such **i** will be bigger than the "
"catastrophic point. 2. Publish a rollback event at the level of external "
"API. 4. Publish re-calculated LFB stream, starting from first difference."
msgstr ""
"2. Yeni LFB zincirinin **i** dizininde eski LFB zincirinden farklı olacağı "
"şekilde ilk **i**'yi bul. Genellikle böyle bir **i** felaket noktasından "
"daha büyük olacaktır. 2. Harici API düzeyinde bir geri alma olayı yayınla. "
"4. İlk farktan başlayarak yeniden hesaplanan LFB akışını yayınla."

#: ../../theory/naive-blockchain.rst:741
msgid "External API of a finalizer"
msgstr "Kesinleştiricinin harici API'ı"

#: ../../theory/naive-blockchain.rst:743
msgid ""
"The API should be stream-based. The decision on the actual streaming "
"technology to use is beyond the scope of this specification."
msgstr ""
"API akış tabanlı olmalıdır. Kullanılacak gerçek akış teknolojisinin kararı "
"bu spesifikasyonun kapsamı dışındadır."

#: ../../theory/naive-blockchain.rst:745
msgid "We only assume that:"
msgstr "Sadece şunu varsayıyoruz:"

#: ../../theory/naive-blockchain.rst:747
msgid "external software components may subscribe to the API (to be notified"
msgstr "harici yazılım bileşenleri API'ye abone olabilir (bildirilecek"

#: ../../theory/naive-blockchain.rst:750
msgid "subscribed observers may unsubscribe"
msgstr "abone olan gözlemciler abonelikten çıkabilir"

#: ../../theory/naive-blockchain.rst:749
msgid "what a subscribed observer receives is a sequence of events"
msgstr "abone olmuş bir gözlemcinin aldığı şey bir dizi olaydır"

#: ../../theory/naive-blockchain.rst:752
msgid "**Events:**"
msgstr "**Olaylar:**"

#: ../../theory/naive-blockchain.rst:755
msgid "Event type"
msgstr "Olay türü"

#: ../../theory/naive-blockchain.rst:755
msgid "Contents"
msgstr "İçerik"

#: ../../theory/naive-blockchain.rst:755
msgid "Semantics"
msgstr "Semantik"

#: ../../theory/naive-blockchain.rst:757
msgid "NEXT_LFB"
msgstr "NEXT_LFB"

#: ../../theory/naive-blockchain.rst:757
msgid "event idLFB(i).idisequence of indirectly finalized blocks"
msgstr "Dolaylı olarak kesinleşmiş blokların idLFB(i).idisequence olayı"

#: ../../theory/naive-blockchain.rst:757
msgid "published as soon as **LFB(i)** is finalized"
msgstr "**LFB(i)** kesinleştiği gibi yayınlanır"

#: ../../theory/naive-blockchain.rst:759
msgid "CATASTROPHY"
msgstr "FELAKET"

#: ../../theory/naive-blockchain.rst:759
msgid "event idsequence id of catastrophy point"
msgstr "felaket noktasının idsequence kimlik olayı"

#: ../../theory/naive-blockchain.rst:759
msgid "signal that equivocation catastrophe happened"
msgstr "çelişkili davranış felaketinin gerçekleştiğine dair sinyal"

#: ../../theory/naive-blockchain.rst:766
msgid "Event"
msgstr "Olay"

#: ../../theory/naive-blockchain.rst:766
msgid "Current snapshot of LFB chain"
msgstr "LFB zincirinin şu anki anlık görüntüsü"

#: ../../theory/naive-blockchain.rst:768
msgid "NEXT_LFB(1, 231, 0, <>)"
msgstr "NEXT_LFB(1, 231, 0, <>)"

#: ../../theory/naive-blockchain.rst:769
msgid "NEXT_LFB(2, 420, 1, <>)"
msgstr "NEXT_LFB(2, 420, 1, <>)"

#: ../../theory/naive-blockchain.rst:769
msgid "(231, 420)"
msgstr "(231, 420)"

#: ../../theory/naive-blockchain.rst:770
msgid "NEXT_LFB(3, 801, 2, <524,525>)"
msgstr "NEXT_LFB(3, 801, 2, <524,525>)"

#: ../../theory/naive-blockchain.rst:770
msgid "(231, 420, 801)"
msgstr "(231, 420, 801)"

#: ../../theory/naive-blockchain.rst:771
msgid "CATASTROPHY(4, 2)"
msgstr "CATASTROPHY(4, 2)"

#: ../../theory/naive-blockchain.rst:772
msgid "NEXT_LFB(5, 421, 1, <105, 116, 228>)"
msgstr "NEXT_LFB(5, 421, 1, <105, 116, 228>)"

#: ../../theory/naive-blockchain.rst:772
msgid "(231, 421)"
msgstr "(231, 421)"

#: ../../theory/naive-blockchain.rst:773
msgid "NEXT_LFB(6, 480, 2, <>)"
msgstr "NEXT_LFB(6, 480, 2, <>)"

#: ../../theory/naive-blockchain.rst:773
msgid "(231, 421, 480)"
msgstr "(231, 421, 480)"
