# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, CasperLabs LLC
# This file is distributed under the same license as the CasperLabs Tech
# Spec package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
# 
# Translators:
# ilker <bilkerarslan40@gmail.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CasperLabs Tech Spec\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-26 20:13+0000\n"
"PO-Revision-Date: 2021-06-26 21:48+0000\n"
"Last-Translator: ilker <bilkerarslan40@gmail.com>, 2021\n"
"Language-Team: Turkish (https://www.transifex.com/caspernetwork/teams/122124/tr/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Language: tr\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../implementation/appendix.rst:4
msgid "Appendix"
msgstr "Ek Bölüm"

#: ../../implementation/appendix.rst:9
msgid "A - Casper Rust Library"
msgstr "A - Casper Rust Kütüphanesi"

#: ../../implementation/appendix.rst:11
msgid ""
"Casper provides low-level bindings for host-side (“external”) functions for "
"developers creating smart contracts in other programming languages. "
"Developers can import these functions into a wasm module used as a contract "
"on the Casper Network. Thus, the contract will have access to features "
"specific to the Casper platform which are not supported by general wasm "
"instructions (e.g., accessing the global state, creating new ``URef``\\ s). "
"These are defined and automatically imported if the `Casper Rust library "
"<https://crates.io/crates/casper-contract>`__ is used to develop the "
"contract. For an up-to-date description of exported functions, please visit "
"the `casper-contract <https://docs.rs/casper-"
"contract/latest/casper_contract/ext_ffi/index.html>`__ crate documentation."
msgstr ""
"Casper, diğer programlama dillerinde akıllı kontratlar oluşturan "
"geliştiriciler için ana bilgisayar tarafı (“harici”) işlevler için düşük "
"düzeyli bağlamalar sağlar. Geliştiriciler, bu işlevleri Casper Network'te "
"kontrat olarak kullanılan bir wasm modülüne aktarabilir. Böylece kontrat, "
"genel wasm talimatları tarafından desteklenmeyen Casper platformuna özgü "
"özelliklere (örneğin, küresel duruma erişme, yeni ``URef``\\ ler oluşturma) "
"erişime sahip olacaktır. Bunlar tanımlanır ve kontratı geliştirmek için "
"`Casper Rust library <https://crates.io/crates/casper-contract>`__ "
"kullanılırsa otomatik olarak içe aktarılır. Dışa aktarılan işlevlerin güncel"
" bir açıklaması için lütfen `casper-contract <https://docs.rs/casper-"
"contract/latest/casper_contract/ext_ffi/index.html>`__ paket belgelerini "
"ziyaret edin."

#: ../../implementation/appendix.rst:16
msgid "B - Serialization Format"
msgstr "B - Serileştirme Formatı"

#: ../../implementation/appendix.rst:18
msgid ""
"The Casper serialization format is used to transfer data between wasm and "
"the Casper host runtime. It is also used to persist global-state data in the"
" Merkle trie. The definition of this format is described in the :ref:`global"
" state <global-state-head>` section."
msgstr ""
"Casper serileştirme formatı, wasm ve Casper ana bilgisayar çalışma zamanı "
"arasında veri aktarmak için kullanılır. Ayrıca Merkle ağacında küresel durum"
" verilerini sürdürmek için kullanılır. Bu format tanımı :ref:`global state "
"<global-state-head>` bölümünde açıklanmıştır."

#: ../../implementation/appendix.rst:20
msgid ""
"A Rust reference implementation for those implementing this specification in"
" another programming language can be found here:"
msgstr ""
"Bu belirtimi başka bir programlama dilinde uygulayanlar için bir Rust "
"referans uygulaması burada bulunabilir:"

#: ../../implementation/appendix.rst:22
msgid ""
"`bytesrepr <https://docs.rs/casper-"
"types/latest/casper_types/bytesrepr/index.html>`_"
msgstr ""
"`bytesrepr <https://docs.rs/casper-"
"types/latest/casper_types/bytesrepr/index.html>`_"

#: ../../implementation/appendix.rst:23
msgid ""
"`cl_value.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/cl_value.rs.html>`_"
msgstr ""
"`cl_value.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/cl_value.rs.html>`_"

#: ../../implementation/appendix.rst:24
msgid ""
"`account <https://docs.rs/casper-"
"types/latest/casper_types/account/index.html>`_"
msgstr ""
"`account <https://docs.rs/casper-"
"types/latest/casper_types/account/index.html>`_"

#: ../../implementation/appendix.rst:25
msgid ""
"`contract <https://docs.rs/casper-"
"types/latest/casper_types/contracts/struct.Contract.html>`_"
msgstr ""
"`contract <https://docs.rs/casper-"
"types/latest/casper_types/contracts/struct.Contract.html>`_"

#: ../../implementation/appendix.rst:26
msgid ""
"`uint.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/uint.rs.html>`_"
msgstr ""
"`uint.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/uint.rs.html>`_"

#: ../../implementation/appendix.rst:28
msgid ""
"Additionally, examples of all data types and their serializations are found "
"in the `GitHub code base <https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L26>`_."
" These examples include a set of useful `serialization tests "
"<https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L1189>`_."
msgstr ""
"Ek olarak, tüm veri türlerinin örnekleri ve bunların serileştirmeleri "
"`GitHub code base <https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L26>`_"
" adresinde bulunur. Bu örnekler, bir dizi yararlı `serialization tests "
"<https://github.com/CasperLabs/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L1189>`_"
" içerir."

#: ../../implementation/appendix.rst:35
msgid "C - Parallel Execution"
msgstr "C - Paralel Yürütme"

#: ../../implementation/appendix.rst:38
msgid "Introduction"
msgstr "Giriş"

#: ../../implementation/appendix.rst:40
msgid ""
"The state of the Casper Network is represented by the :ref:`global state "
"<global-state-head>`. The evolution of this state is captured by the "
"blockchain itself, and eventually agreed upon by all nodes in the network "
"via the consensus mechanism. In this section we are concerned with only a "
"single step of that evolution. We think of such a step as performing some "
"\"computation\" that changes the global state. A :ref:`deploy <execution-"
"semantics-deploys>` is a user request for computation, and contains two "
"atomic units of computation: the payment code and the session code (the "
"details of which are discussed elsewhere). For the purpose of this section, "
"we think of each of these units as a (mathematical) function which takes the"
" current global state as input, perhaps along with some other arguments, and"
" produces a new global state as output. However, since the overall global "
"state is ambient from the perspective of the session/payment code itself, "
"the global state is not an explicit parameter in any user's source code, nor"
" is there any explicit return value."
msgstr ""
"Casper Network'ün durumu :ref:`global state <global-state-head>` ile temsil "
"edilir. Bu durumun evrimi, blok zincirinin kendisi tarafından yakalanır ve "
"sonunda ağdaki tüm düğümler tarafından mutabakat mekanizması aracılığıyla "
"kararlaştırılır. Bu bölümde, bu evrimin yalnızca tek bir adımıyla "
"ilgileniyoruz. Küresel durumu değiştiren bazı \"hesaplamalar\" yapan bir "
"adım olarak düşünüyoruz. A :ref:`deploy <execution-semantics-deploys>`, "
"hesaplama için bir kullanıcı isteğidir ve iki atomik hesaplama birimi "
"içerir: ödeme kodu ve oturum kodu (ayrıntıları başka bir yerde "
"tartışılmıştır). Bu bölümün amacı için, bu birimlerin her birini, belki "
"başka argümanlarla birlikte mevcut küresel durumu girdi olarak alan ve çıktı"
" olarak yeni bir küresel durum üreten (matematiksel) bir fonksiyon olarak "
"düşünüyoruz. Bununla birlikte, genel küresel durum, oturum/ödeme kodunun "
"kendi perspektifinden olduğu için, küresel durum, herhangi bir kullanıcının "
"kaynak kodunda açık bir parametre değildir ve herhangi bir açık dönüş değeri"
" de yoktur."

#: ../../implementation/appendix.rst:55
msgid ""
"In this section we refine this idea of computation modeled as functions, and"
" describe how it is used to enable parallel execution."
msgstr ""
"Bu bölümde, işlevler olarak modellenen bu hesaplama fikrini iyileştireceğiz "
"ve paralel yürütmeyi etkinleştirmenin nasıl kullanıldığını açıklayacağız."

#: ../../implementation/appendix.rst:61
msgid "Computation as functions on the global state"
msgstr "Küresel durumda fonksiyon olarak hesaplama"

#: ../../implementation/appendix.rst:63
msgid ""
"As discussed in the introduction, we think of computation on the Casper "
"platform as being functions from the global state, :math:`G`, to itself. "
"Naturally, we can compose two such functions, to obtain another function. "
"This corresponds to sequential execution. For example, you can think of the "
"sequence ``payment_code -> session_code`` as being the composition of two "
"individual functions, capturing the effects of the payment and session "
"codes, respectively. If there are smart contracts which are called during "
"those execution phases, you could even break these down further into a "
"sequence of those calls: ``deployed_payment_wasm -> contract_a -> contract_b"
" -> stored_session_code -> contract_c -> ...``. For notational purposes, we "
"will call the set of functions :math:`\\left\\{ f \\ \\vert \\ f: G "
"\\rightarrow G \\right\\} = End(G)`, meaning \"endomorphisms of :math:`G`.\""
msgstr ""
"Giriş bölümünde tartışıldığı gibi, Casper platformundaki hesaplamanın, "
"küresel durumdan, :math:`G`, kendisine yönelik işlevler olduğunu "
"düşünüyoruz. Doğal olarak, başka bir fonksiyon elde etmek için böyle iki "
"fonksiyon oluşturabiliriz. Bu, sıralı yürütmeye karşılık gelir. Örneğin, "
"``payment_code -> session_code`` dizisini, sırasıyla ödeme ve oturum "
"kodlarının etkilerini yakalayan iki ayrı işlevin bileşimi olarak "
"düşünebilirsiniz. Bu yürütme aşamalarında çağrılan akıllı kontratlar varsa, "
"bunları bu çağrıların bir dizisine ayırabilirsiniz: ``deployed_payment_wasm "
"-> contract_a -> contract_b -> stored_session_code -> contract_c -> ...``. "
"Gösterim amacıyla, işlevler kümesini :math:`\\left\\{ f \\ \\vert \\ f: G "
"\\rightarrow G \\right\\} = End(G)` olarak adlandıracağız, yani "
"\":math:`G'nin endomorfizmaları\" `.\""

#: ../../implementation/appendix.rst:74
msgid ""
"While this simple model captures sequential execution, it does not model "
"parallel execution. Parallel execution is important because it can enable "
"the execution engine to run more than one deploy at the same time, possibly "
"improving block processing times. Note: each deploy itself is still single-"
"threaded; we will not support parallel execution within a single contract or"
" deploy. This optimization is purely for the performance of the node "
"implementation, not contract developers."
msgstr ""
"Bu basit model sıralı yürütmeyi yakalarken, paralel yürütmeyi modellemez. "
"Paralel yürütme önemlidir, çünkü yürütme motorunun aynı anda birden fazla "
"dağıtımı çalıştırmasını sağlayarak blok işleme sürelerini iyileştirebilir. "
"Not: her dağıtımın kendisi hala tek iş parçacıklıdır; tek bir kontrat veya "
"dağıtım içinde paralel yürütmeyi desteklemeyeceğiz. Bu optimizasyon, kontrat"
" geliştiricileri için değil, yalnızca düğüm uygulamasının performansı "
"içindir."

#: ../../implementation/appendix.rst:83
msgid "Computation as functions from :math:`G` to :math:`End(G)`"
msgstr ":math:`G` ile :math:`End(G)` arasındaki fonksiyonlar olarak hesaplama"

#: ../../implementation/appendix.rst:85
msgid ""
"The problem with functions on the global state itself is they mutate the "
"state, potentially causing problems if we wanted to apply two such functions"
" at the same time. Therefore, we will instead think of computations as "
"outputting a description of the changes to the global state that they would "
"make if given the chance. Or phrased another way, the execution of a deploy "
"will return a function that could be applied to the global state to obtain "
"the post-state we would have obtained from running the computation while "
"mutating the global state. The reason this helps is because we can apply "
"multiple such functions to the same global state at the same time; they are "
"pure functions that do not modify the global state. Thus we can execute "
"multiple deploys in parallel and later combine their outputs (more on this "
"later)."
msgstr ""
"Küresel durumun kendisindeki fonksiyonlarla ilgili sorun, durumu mutasyona "
"uğratmaları ve bu tür iki fonksiyonu aynı anda uygulamak istersek potansiyel"
" olarak sorunlara neden olmalarıdır. Bu nedenle, bunun yerine hesaplamaları,"
" şans verildiğinde küresel durumda yapacakları değişikliklerin bir tanımını "
"çıktı olarak düşüneceğiz. Veya başka bir şekilde ifade edilirse, bir "
"dağıtımın yürütülmesi, küresel durumu değiştirirken hesaplamayı çalıştırarak"
" elde edeceğimiz son durumu elde etmek için küresel duruma uygulanabilecek "
"bir fonksiyon döndürür. Bunun yardımcı olmasının nedeni, aynı küresel duruma"
" aynı anda birden çok fonksiyonu uygulayabilmemizdir; ki bunlar küresel "
"durumu değiştirmeyen saf fonksiyonlardır. Böylece birden fazla dağıtımı "
"paralel olarak yürütebilir ve daha sonra çıktılarını birleştirebiliriz "
"(bununla ilgili daha fazla bilgi daha sonra verilecektir)."

#: ../../implementation/appendix.rst:103
msgid ""
"The way this is modeled in the Casper execution engine is via the "
"|TrackingCopy|_. Executing deploys (and the contracts they call) read/write "
"from the |TrackingCopy|_ instead of the global state directly. The "
"|TrackingCopy|_ *tracks* the operations and returns the |Transforms|_ which "
"act on each key in the global state effected by the execution. Using the "
"nomenclature from the theory, this collection of keys and transforms "
"describes a function :math:`f: G \\rightarrow G` which is an endomorphism on"
" :math:`G`, i.e. an element of :math:`End(G)`."
msgstr ""
"Bunun Casper yürütme motorunda modellenme şekli |TrackingCopy|_ "
"aracılığıyladır. Dağıtımları (ve çağırdıkları sözleşmeleri) doğrudan küresel"
" durum yerine |TrackingCopy|_'den okumak/yazmak. |TrackingCopy|_ *işlemleri "
"izler* ve yürütmenin etkilediği küresel durumda her bir anahtar üzerinde "
"etkili olan |Transforms|_ ları döndürür. Teorideki terminolojiyi kullanarak,"
" bu anahtarlar ve dönüşümler toplamı, :math:`G` üzerinde bir endomorfizm "
"olan :math:`f: G \\rightarrow G` fonksiyonunu tanımlar, yani :math:`End(G)` "
"'nin bir ögesi."

#: ../../implementation/appendix.rst:113
msgid ""
"An important note about the returned |Transforms|_ is there is exactly one "
"``Transform`` per key that was used during the execution. Initially, this "
"may be unintuitive because a contract can use the same key multiple times, "
"however, because each deploy executes sequentially, we can use the "
"composition property discussed in the previous section to combine multiple "
"sequential operations into a single operation. Consider the following "
"example."
msgstr ""
"Döndürülen |Transforms|_ ile ilgili önemli bir not, yürütme sırasında "
"kullanılan anahtar başına tam olarak bir ``Transform`` olmasıdır. "
"Başlangıçta, bir sözleşme aynı anahtarı birden çok kez kullanabileceğinden "
"bu sezgisel olmayabilir, ancak her konuşlandırma sırayla yürütüldüğünden, "
"birden çok sıralı işlemi tek bir işlemde birleştirmek için önceki bölümde "
"tartışılan kompozisyon özelliğini kullanabiliriz. Aşağıdaki örneği düşünün."

#: ../../implementation/appendix.rst:130
msgid ""
"The above function reads a local variable, performs a computation which "
"depends on the current value of that variable, then writes an updated value."
" Suppose we execute this function on a global state where the value of the "
"local key is ``7``. Then the sequence of transforms on the global state "
"would be ``Read -> Write(22)`` since ``n`` would be odd and thus ``f_n`` "
"would be computed using the ``else`` case. From the perspective of state "
"changes, we only need to keep the ``Write(22)`` transform because final "
"state is the same as if we had also included the ``Read`` transform. In "
"fact, by the same reasoning, we know that we only need to keep the last "
"``Write``, whatever it happens to be, since it will be the final value on "
"the key after the computation finishes. Notice that the resulting global "
"state function does not exactly reproduce the original contract execution "
"steps; it is a *reduced trace* where only the final effect on the global "
"state is recorded [#]_. In particular, this means applying the results of "
"these executions is very fast relative to the original execution (this will "
"be importnat for how we use these traces in the next section). Also notice "
"that the transforms which are produced depend on the initial state. This "
"might be obvious since we are modeling compuation as functions :math:`f: G "
"\\rightarrow End(G)`, so this statement is simply that the function really "
"depends on its input. However, this is again an imporant concept to keep in "
"mind when working with this model of computation. Going back to our example,"
" if the value of the local key was ``16`` then the transform produced would "
"be ``Write(8)``, entirely different from the case where the initial value "
"was ``7``."
msgstr ""
"Yukarıdaki fonksiyon yerel bir değişkeni okur, o değişkenin mevcut değerine "
"bağlı bir hesaplama yapar ve sonra güncellenmiş bir değer yazar. Bu işlevi, "
"yerel anahtarın değerinin ``7`` olduğu küresel bir durumda çalıştırdığımızı "
"varsayalım. Sonra küresel durumdaki dönüşümlerin sırası ``Read -> "
"Write(22)`` olur, çünkü ``n`` tek olur ve bu nedenle ``f_n``, ``else`` "
"durumu kullanılarak hesaplanır. Durum değişiklikleri açısından, sadece "
"``Write(22)`` dönüşümünü korumamız gerekiyor çünkü son durum, ``Read`` "
"dönüşümünü de dahil etmişiz gibidir. Aslında, aynı mantıkla, ne olursa "
"olsun, sadece son ``Write``ı tutmamız gerektiğini biliyoruz, çünkü bu, "
"hesaplama bittikten sonra anahtar üzerindeki son değer olacaktır. Ortaya "
"çıkan küresel durum işlevinin orijinal sözleşme yürütme adımlarını tam "
"olarak yeniden üretmediğine dikkat edin; yalnızca küresel durum üzerindeki "
"nihai etkinin kaydedildiği *azaltılmış bir izdir* [#]_. Bu, özellikle, bu "
"yürütmelerin sonuçlarının uygulanmasının orijinal yürütmeye göre çok hızlı "
"olduğu anlamına gelir (bu, sonraki bölümde bu izleri nasıl kullandığımız "
"için önemli olacaktır). Ayrıca üretilen dönüşümlerin başlangıç ​​durumuna "
"bağlı olduğuna dikkat edin. Hesaplamayı :math:`f: G \\rightarrow End(G)` "
"fonksiyonları olarak modellediğimiz için bu açık olabilir, bu nedenle bu "
"ifade basitçe fonksiyonun gerçekten girdisine bağlı olduğudur. Ancak, bu, "
"hesaplama modeliyle çalışırken akılda tutulması gereken önemli bir "
"kavramdır. Örneğimize geri dönersek, yerel anahtarın değeri ``16`` ise, "
"üretilen dönüşüm ``Write(8)`` olacaktır, bu ilk değerin ``7`` olduğu "
"durumdan tamamen farklı olacaktır."

#: ../../implementation/appendix.rst:155
msgid ""
"There is a special case of constructing reduced traces which is worth "
"calling out explicitly. Suppose the initial value of a key in the global "
"state is ``X``, and after performing the execution, the transform for that "
"key is ``Write(X)``. Then it is valid to replace that transform with "
"``Read``. This is because the computation acts like the identity function "
"(i.e. the function which makes no changes) at this key, and therefore is "
"equal to ``Read``. Notably we cannot simply remove the transfrom from the "
"map because the key was still used in some way during the computation. We "
"must have a record of what keys were used to correctly detect when deploys "
"commute (see the following sections for more details). Replacing a ``Write``"
" with a ``Read`` still has great benefits for parallel exectuion because "
"reads do commute with one another, while writes do not. This optimization in"
" the reduced traces is `applied in our reference implementation "
"<https://github.com/CasperLabs/casper-"
"node/blob/master/execution_engine/src/core/engine_state/execution_result.rs#L439>`__."
msgstr ""
"Açıkça söylemeye değer, indirgenmiş izler oluşturmanın özel bir durumu "
"vardır. Global durumdaki bir anahtarın başlangıç ​​değerinin ``X`` olduğunu "
"ve yürütmeyi gerçekleştirdikten sonra bu anahtarın dönüşümünün ``Write(X)`` "
"olduğunu varsayalım. O zaman bu dönüşümü ``Read`` ile değiştirmek "
"geçerlidir. Bunun nedeni, hesaplamanın bu anahtardaki kimlik işlevi (yani "
"hiçbir değişiklik yapmayan işlev) gibi davranması ve bu nedenle ``Read`` e "
"eşit olmasıdır. Özellikle, hesaplama sırasında anahtar hala bir şekilde "
"kullanıldığından, dönüşümü haritadan basitçe kaldıramayız. Dağıtımların "
"takasını doğru bir şekilde algılamak için hangi anahtarların kullanıldığının"
" bir kaydına sahip olmamız gerekir (daha fazla ayrıntı için aşağıdaki "
"bölümlere bakın). ``Write`` ı ``Read`` ile değiştirmenin paralel yürütme "
"için hala büyük faydaları vardır, çünkü okumalar birbiriyle takas edilirken "
"yazma işlemleri bu şekilde yapmaz. İndirgenmiş izlerdeki bu optimizasyon "
"`referans uygulamamızda uygulanmıştır <https://github.com/CasperLabs/casper-"
"node/blob/master/execution_engine/src/core/engine_state/execution_result.rs#L439>`__."

#: ../../implementation/appendix.rst:172
msgid "Constructing the post-state from parallel execution"
msgstr "Paralel yürütmeden durum sonrası oluşturma"

#: ../../implementation/appendix.rst:174
msgid ""
"Following from the previous section, we know that deploys execute to produce"
" a ``Map<Key, Transform>`` which gives a summary (i.e. \"reduced trace\") of"
" the effects the deploy would have had on each key in the global state (keys"
" not present in the map are not effected). In the reference implementation "
"we call this the ``exec`` phase. Since creating these maps does not mutate "
"the global state, we can run as many of these as we want in parallel. "
"However, after they have been run we need to actually produce a post-state, "
"the new global state after applying the effects of the deploys (this will "
"then be used as the pre-states for deploys in the following batch of "
"executions). In the reference implementation, we call applying the "
"collection of transforms to obtain a post-state the ``commit`` phase."
msgstr ""
"Önceki bölümden yola çıkarak, dağıtımların, dağıtımın küresel durumda her "
"bir anahtar üzerinde sahip olacağı etkilerin bir özetini (yani \"indirgenmiş"
" iz\") veren bir ``Map<Key, Transform>`` üretmek için yürütüldüğünü "
"biliyoruz. (haritada bulunmayan tuşlar etkilenmez). Referans uygulamada buna"
" ``exec`` aşaması diyoruz. Bu haritaları oluşturmak küresel durumu "
"değiştirmediğinden, bunlardan istediğimiz kadarını paralel olarak "
"çalıştırabiliriz. Ancak, bunlar çalıştırıldıktan sonra, dağıtımların "
"etkilerini uyguladıktan sonra yeni küresel durum olan bir durum sonrası "
"üretmemiz gerekir (bu daha sonra sonraki yürütme partilerinde dağıtımlar "
"için ön-durumlar olarak kullanılacaktır). Referans uygulamasında, bir durum "
"sonrası elde etmek için dönüşümlerin koleksiyonunu ``commit`` aşamasını "
"uygulamayı çağırıyoruz."

#: ../../implementation/appendix.rst:186
msgid ""
"Before we can construct the post-state, we must know that one is well-"
"defined. When working with parallel execution with a shared resource, you "
"may encounter \"race conditions\". This is a situation where the outcome of "
"a parallel computation depends on the order or timing of events, in "
"particular when this timing is not explicitly controlled. Or phrased another"
" way, parallelism with a shared resource is a lie and one of the processes "
"will use the resource first, followed by the other one. A classic blockchain"
" example of a race condition is a double spend (which under an accounts "
"model, as opposed to UTXO, is the same as an overdraft on the account); one "
"payer attempts to pay two payees at the same time without enough tokens to "
"actually pay both. One payee or the other is not getting their tokens, "
"depending on the order the transactions are processed."
msgstr ""
"Durum sonrasını inşa etmeden önce, birinin iyi tanımlanmış olduğunu "
"bilmeliyiz. Paylaşılan bir kaynakla paralel yürütme ile çalışırken \"yarış "
"koşulları\" ile karşılaşabilirsiniz. Bu, paralel bir hesaplamanın sonucunun,"
" özellikle bu zamanlama açıkça kontrol edilmediğinde, olayların sırasına "
"veya zamanlamasına bağlı olduğu bir durumdur. Veya başka bir deyişle, "
"paylaşılan bir kaynakla paralellik bir yalandır ve süreçlerden biri önce "
"kaynağı, ardından diğerini kullanır. Bir yarış koşulunun klasik bir "
"blokzincir örneği, çift harcamadır (bu, UTXO'nun aksine bir hesap modeli "
"altında, hesaptaki bir kredili mevduatla aynıdır); bir ödeyen, her ikisini "
"de ödemeye yetecek kadar token olmadan aynı anda iki alacaklıya ödeme "
"yapmaya çalışır. Bir alacaklı veya diğeri, işlemlerin işlenme sırasına bağlı"
" olarak tokenlerini almıyor."

#: ../../implementation/appendix.rst:200
msgid ""
"In our simple model of computation where deploys are functions on the global"
" state, this would correspond to functions that do not *commute*, that is to"
" say, the order in which we apply the functions to the global state matters:"
" :math:`f \\circ g \\not= g \\circ f`. Therefore, in order to prevent race "
"conditions, we will only allow deploys to execute in parallel if they "
"commute. Taking our more sophisticated model of computation, we have two "
"deploys: :math:`f: G \\rightarrow End(G)` and :math:`g: G \\rightarrow "
"End(G)`, and we will only allow both be committed to the same pre-state "
":math:`G` if :math:`f(G) \\circ g(G) = g(G) \\circ f(G)`, i.e. the resulting"
" maps of transforms commute."
msgstr ""
"Dağıtımların küresel durumda fonksiyonlar olduğu basit hesaplama "
"modelimizde, bu, *takas edilmeyen* fonksiyonlara, yani fonksiyonları küresel"
" duruma uygulama sırasına karşılık gelir: :math:` f \\circ g \\not= g \\circ"
" f`. Bu nedenle, yarış koşullarını önlemek için dağıtımların yalnızca takası"
" durumunda paralel olarak yürütülmesine izin vereceğiz. Daha karmaşık "
"hesaplama modelimizi alırsak, iki dağıtımımız var: :math:`f: G \\rightarrow "
"End(G)` ve :math:`g: G \\rightarrow End(G)` ve yalnızca :math:`f(G) \\circ "
"g(G) = g(G) \\circ f(G)` durumunda, aynı  :math:`G` ön durumuna takas "
"edilmelerine izin vereceğiz, yani takas edilen dönüşümlerin son haritaları."

#: ../../implementation/appendix.rst:212
msgid ""
"We will discuss how to compute whether two maps of transforms commute in the"
" next section. For now, we assume that run some set of deploys :math:`d_1, "
"d_2, d_3, \\ldots` in parallel against a fixed pre-state :math:`G` to obtain"
" a set of transform maps :math:`T_1, T_2, T_3, \\ldots`, then select only "
"the transforms that commute :math:`T_i, T_j, T_k, \\ldots` to apply to "
":math:`G`, and thus obtain the post-state :math:`G^\\prime`. The remaining "
"deploys we can all run in parallel against :math:`G^\\prime`, again choosing"
" the commuting ones to commit, obtaining :math:`G^{\\prime\\prime}`, and so "
"on. This final post-state is the same as if we had run all the deploys "
":math:`d_1, d_2, d_3, \\ldots` in sequence against :math:`G`, but perhaps "
"faster (depending on how many could commute [#]_) because we were able to "
"run in parallel batches."
msgstr ""
"Bir sonraki bölümde iki dönüşüm haritasının değişip değişmediğini nasıl "
"hesaplayacağımızı tartışacağız. Şimdilik, :math:`d_1, d_2, d_3, \\ldots` "
"bazı dağıtım setlerini sabit bir ön-duruma :math:`G` karşı paralel olarak "
"çalıştırarak bir dizi dönüşüm haritası :math:`T_1, T_2, T_3, \\ldots` elde "
"ettiğini varsayıyoruz, ardından yalnızca :math:`T_i, T_j, T_k, \\ldots` ile "
"takas edilen dönüşümleri seçin ve :math:`G`ye uygulayın ve böylece "
":math:`G^\\prime` durum sonrasını elde edin. Geri kalan dağıtımları, "
":math:`G^\\prime` karşısında paralel olarak çalıştırabiliriz, yine takas "
"edileceklerin takasını seçerek, :math:`G^{\\prime\\prime}` elde ederek, vb. "
"Bu son durum sonrası, :math:`d_1, d_2, d_3, \\ldots` tüm dağıtımlarını "
":math:`G`ye karşı sırayla çalıştırmış olmamızla aynıdır, ancak belki de daha"
" hızlıdır (kaçının takas edilebileceğine bağlı olarak [ #]_) çünkü paralel "
"gruplar halinde çalışabildik."

#: ../../implementation/appendix.rst:226
msgid ""
"Recall that committing transforms is a very fast operation relative to "
"execution, so it causes little overhead. The main overhead would come from "
"executing the same deploy against multiple different starting states because"
" it failed to commute multiple times. This can be mitigated by favoring "
"including more expensive deploys in each committed batch."
msgstr ""
"Dönüşümleri gerçekleştirmenin yürütmeye göre çok hızlı bir işlem olduğunu "
"hatırlayın, bu nedenle çok az ek yüke neden olur. Ana ek yük, birden çok kez"
" takas edilmesi başarısız olduğu için aynı dağıtımı birden çok farklı "
"başlangıç durumuna karşı yürütmekten gelir. Bu, taahhüt edilen her toplu iş "
"için daha pahalı dağıtımlar dahil edilerek azaltılabilir."

#: ../../implementation/appendix.rst:234
msgid "Detecting when maps of transforms commute"
msgstr "Dönüşüm haritalarının ne zaman takas edildiğini algılama"

#: ../../implementation/appendix.rst:236
msgid ""
"Two transform maps ``m_1: Map<Key, Transform>`` and ``m_2: "
"Map<Key,Transform>`` commute if for all keys ``k`` which are present in both"
" maps, the transforms ``t_1 = m_1[k]`` and ``t_2 = m_2[k]`` commute. "
"Notably, if there are no such keys then the maps trivially commute. Two "
"transforms ``t_1:Transform`` and ``t_2: Transform`` commute if:"
msgstr ""
"İki dönüşüm haritası ``m_1: Map<Key, Transform>`` ve ``m_2: "
"Map<Key,Transform>``, her iki haritada da bulunan tüm ``k`` anahtarları "
"için, dönüşümler ``t_1 = m_1[k]`` ve ``t_2 = m_2[k]`` takas edildiğinde, "
"takas edilir. Özellikle, böyle bir anahtar yoksa, haritalar önemsiz bir "
"şekilde gidip gelir. İki dönüşüm `` t_1:Transform`` ve ```t_2: Transform`` "
"şu durumlarda takas edilir:"

#: ../../implementation/appendix.rst:242
msgid "``t_1 == t_2 == Read``"
msgstr "``t_1 == t_2 == Read``"

#: ../../implementation/appendix.rst:243
msgid ""
"``t_1`` and ``t_2`` are both of the same ``Add*`` transform variant (note "
"they do not need to contain the same values within that variant)"
msgstr ""
"\"t_1\" ve \"t_2\", aynı ``Add*`` dönüşüm varyantıdır (bu varyant içinde "
"aynı değerleri içermeleri gerekmediğini unutmayın)"

#: ../../implementation/appendix.rst:247
msgid ""
"where ``Add*`` is a placeholder representing any of the typed native add "
"operations (``AddInt32``, ``AddInt64``, ``AddInt128``, ``AddInt256``, "
"``AddInt512``, ``AddKeys``).  And they do not commute otherwise. A short "
"montra for this is: reads commute, adds commute, writes conflict. Note that "
"writes *always* conflict, even if they are writing the same value. Consider "
"the following example:"
msgstr ""
"burada ``Add*``, yazılan yerel ekleme işlemlerinden (``AddInt32``, "
"``AddInt64``, ``AddInt128``, ``AddInt256``, ``AddInt512``, ``AddKeys``) "
"herhangi birini temsil eden bir yer tutucudur. Ve başka türlü takas "
"edilmezler. Bunun için kısa bir tekerleme: okumalar takas olur, eklemeler "
"takas olur, yazmalar çakışır. Aynı değeri yazsalar bile yazmaların *her "
"zaman* çakıştığını unutmayın. Aşağıdaki örneği göz önünde bulundurun:"

#: ../../implementation/appendix.rst:270
msgid ""
"If the pre-state :math:`G` has ``local(\"x\") == 7`` then ``f(G)`` results "
"in the transform ``Write(10)``, and so does ``g(G)``. However, if we compose"
" ``g(f(G))`` then we obtain ``Write(100)``, and if we compose ``f(g(G))`` "
"then the result is ``Write(0)`` and hence the functions do not commute."
msgstr ""
":math:`G` ön durumu ``local(\"x\") == 7`` değerine sahipse, o zaman "
"``f(G)``, ``Write(10)`` dönüşümüyle sonuçlanır ve ``g(G)`` de aynı "
"şekildedir. Ancak, ``g(f(G))`` oluşturursak, o zaman ``Write(100)`` elde "
"ederiz ve ``f(g(G))`` oluşturursak sonuç ``Write(0)`` ve bu nedenle işlevler"
" takas edilmiyor."

#: ../../implementation/appendix.rst:277
msgid "Handling Errors"
msgstr "Hataları İdare Etmek"

#: ../../implementation/appendix.rst:279
msgid ""
"The reason we can say \"adds commute\" in our rules is because "
"mathematically addition is commutative. However, this relies on the infinite"
" nature of the number line and real computers are finite. For example, if we"
" considered the addition of three 8-bit numbers: 250, 3, and 5, any two of "
"them can be added and they commute, but attempting to add all three results "
"in an overflow error. Thus the final result depends on the order of "
"addition:"
msgstr ""
"Kurallarımızda \"eklemeler takas edilir\" diyebilmemizin nedeni, "
"matematiksel olarak toplamanın değişmeli olmasıdır. Ancak bu, sayı "
"doğrusunun sonsuz doğasına dayanır ve gerçek bilgisayarlar sonludur. "
"Örneğin, 8 bitlik üç sayının eklenmesini düşünürsek: 250, 3 ve 5, bunlardan "
"herhangi ikisi eklenebilir ve bunlar takas edilirler, ancak üçünü de "
"toplamaya çalışmak bir taşma hatasıyla sonuçlanır. Böylece nihai sonuç, "
"ekleme sırasına bağlıdır:"

#: ../../implementation/appendix.rst:286
msgid "250 + 3 + 5 = 253 (last addition does not happen due to the error)"
msgstr "250 + 3 + 5 = 253 (son ekleme hata nedeniyle olmuyor)"

#: ../../implementation/appendix.rst:287
msgid "250 + 5 + 3 = 255"
msgstr "250 + 5 + 3 = 255"

#: ../../implementation/appendix.rst:288
msgid "3 + 5 + 250 = 8"
msgstr "3 + 5 + 250 = 8"

#: ../../implementation/appendix.rst:290
msgid ""
"Presently we circumvent this error by actually using modular arithmetic "
"(wrapped addition as it is often called in computer science). Addition in "
"modular arithmetic is still a commutative operation, so our theory holds "
"together. In our example above 250 + 5 + 3 is always equal to 3, no matter "
"what. However in the context of financial applications wrapping back to zero"
" is an unexpected behavior. For this reason we use 512-bit numbers in our "
"mint contract to represent balances, and the total number of token units "
"(motes) available is less than ``U512::MAX``, so overflow is impossible."
msgstr ""
"Şu anda bu hatayı modüler aritmetik (bilgisayar bilimlerinde genellikle "
"adlandırıldığı gibi sarmalanmış toplama) kullanarak atlatıyoruz. Modüler "
"aritmetikte toplama hala değişmeli bir işlemdir, bu nedenle teorimiz "
"tutarlıdır. Yukarıdaki örneğimizde, 250 + 5 + 3, ne olursa olsun her zaman "
"3'e eşittir. Ancak finansal uygulamalar bağlamında sıfıra geri sarma "
"beklenmeyen bir davranıştır. Bu nedenle, basım sözleşmemizde bakiyeleri "
"temsil etmek için 512 bitlik sayılar kullanıyoruz ve mevcut toplam token "
"birimi (mot) sayısı ``U512::MAX`` değerinden daha az, dolayısıyla taşma "
"mümkün değil."

#: ../../implementation/appendix.rst:299
msgid ""
"That said, this is not the only error which may arise due to the finite "
"nature of computers. For example, the ``AddKeys`` transform is about adding "
"elements to a map, which is a commutative operation as well (so long as none"
" of the keys already existed in the map, then it is more akin to a write "
"operation). Yet, this operation can also fail due to the physical machine "
"being out of memory, thus once again meaning the order of additions could "
"effect the final state of the map."
msgstr ""
"Bununla birlikte, bilgisayarların sınırlı doğası nedeniyle ortaya "
"çıkabilecek tek hata bu değildir. Örneğin, ``AddKeys`` dönüşümü, aynı "
"zamanda değişmeli bir işlem olan bir haritaya eleman eklemekle ilgilidir "
"(haritada anahtarlardan hiçbiri mevcut olmadığı sürece, bu daha çok bir "
"yazma işlemine benzer). Ancak bu işlem, fiziksel makinenin belleğinin "
"yetersiz olması nedeniyle de başarısız olabilir, bu nedenle bir kez daha, "
"eklemelerin sırasının haritanın son durumunu etkileyebileceği anlamına "
"gelir."

#: ../../implementation/appendix.rst:307
msgid ""
"In a more powerful theory of parallel execution we could consider operations"
" which fail. In this case we could say that transforms ``t_1`` and ``t_2`` "
"commute if they are of the same addition type and the outcome of applying "
"both to the input global state, :math:`G` is not an error. This is a more "
"complex rule because it requires doing some amount of computation during "
"commutativity checking, whereas the previous theory was simple comparison. "
"Yet, this theory might be worth pursuing because it solves the two problems "
"we have listed here (overflow and out-of-memory), along with other problems "
"that we presently cannot handle at all. For example, ``Minus`` could be "
"introduced as a transform, and underflows could be handled using this "
"refined commutativity rule. This has practical application in our system "
"because it would mean transfers from the same source could commute if enough"
" funds are available, whereas presently they will always be conservatively "
"labeled as not commuting."
msgstr ""
"Daha güçlü bir paralel yürütme teorisinde, başarısız olan işlemleri "
"düşünebiliriz. Bu durumda, ``t_1`` ve ``t_2`` dönüşümlerinin, aynı toplama "
"türünden olmaları ve her ikisinin de giriş global durumuna uygulanmasının "
"sonucu olması durumunda, :math:`G` bir hata olmadığını söyleyebiliriz. Bu "
"daha karmaşık bir kuraldır, çünkü önceki teori basit karşılaştırma iken, "
"değişebilirlik kontrolü sırasında bir miktar hesaplama yapılmasını "
"gerektirir. Yine de, bu teori takip etmeye değer olabilir, çünkü burada "
"listelediğimiz iki sorunu (taşma ve yetersiz bellek) ve şu anda hiç baş "
"edemediğimiz diğer sorunları çözer. Örneğin, ``Minus`` bir dönüşüm olarak "
"tanıtılabilir ve bu iyileştirilmiş değişme kuralı kullanılarak alt akışlar "
"işlenebilir. Bu, sistemimizde pratik bir uygulamaya sahiptir, çünkü bu, aynı"
" kaynaktan yapılan transferlerin, yeterli fon mevcut olduğunda takas "
"edilebileceği anlamına gelirken, oysaki şu anda, her zaman, ılımlı olarak "
"takas edilmiyor olarak etiketleneceklerdir."
