
Rust
====

This section explains step by step how to write a new smart contract on Casper.  Start with ``main.rs`` from the previous section.

A Basic Smart Contract in Rust
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The Casper VM executes a smart contract by calling the ``call`` function specified in the contract. If the function is missing, the smart contract is not valid. The simplest possible example is an empty ``call`` function.

.. code-block:: rust

   #[no_mangle]
   pub extern "C" fn call() {}

The ``#[no_mangle]`` attribute prevents the compiler from changing (mangling) the function name when converting to the binary format of Wasm. Without it, the VM exits with the error message: ``Module doesn't have export call``.

Arguments
^^^^^^^^^

It's possible to pass arguments to smart contracts. 
To leverage this feature, use `runtime::get_named_arg <https://docs.rs/casper-contract/latest/casper_contract/contract_api/runtime/fn.get_named_arg.html>`_.  

.. code-block:: rust

   use casperlabs_contract::contract_api::runtime;

   #[no_mangle]
   pub extern "C" fn call() {
       let value: String = runtime::get_named_arg("value");
   }

Storage
^^^^^^^

Saving and reading values to and from the blockchain is a manual process in Casper. It requires more code to be written, but also provides a lot of flexibility. The storage system works similarly to a file system in an operating system.  Let's say we have a string ``"Hello Casper!"`` that needs to be saved. To do this, use the text editor, create a new file, paste the string in and save it under a name in some directory. The pattern is similar on the Casper blockchain. First you have to save your value to the memory using `storage::new_uref <https://docs.rs/casper-contract/latest/casper_contract/contract_api/storage/fn.new_uref.html>`_. This returns a reference to the memory object that holds the ``"Hello Casper!"`` value. You could use this reference to update the value to something else. It's like a file. Secondly you have to save the reference under a human-readable string using `runtime::put_key <https://docs.rs/casper-contract/latest/casper_contract/contract_api/runtime/fn.put_key.html>`_. It's like giving a name to the file. The following function implements this scenario:

.. code-block:: rust

   const KEY: &str = "special_value";

   fn store(value: String) {
       // Store `value` under a new unforgeable reference.
       let value_ref = storage::new_uref(value);

       // Wrap the unforgeable reference in a `Key`.
       let value_key: Key = value_ref.into();

       // Store this key under the name "special_value" in context-local storage.
       runtime::put_key(KEY, value_key);
   }

After this function is executed, the context (Account or Smart Contract) will have the content of the ``value`` stored under ``KEY`` in its named keys space. The named keys space is a key-value storage that every context has. It's like a home directory.

Final Smart Contract
^^^^^^^^^^^^^^^^^^^^

The code below is the simple contract generated by `cargo-casper <https://crates.io/crates/cargo-casper>`_  (found in ``contract/src/main.rs`` of a project created by the tool). It reads an argument and stores it in the memory under a key named ``"special_value"``.

.. code-block:: rust

   #![cfg_attr(
       not(target_arch = "wasm32"),
       crate_type = "target arch should be wasm32"
   )]
   #![no_main]

   use casperlabs_contract::{
       contract_api::{runtime, storage},
   };
   use casperlabs_types::{Key, URef};

   const KEY: &str = "special_value";
   const ARG_MESSAGE: &str = "message";

   fn store(value: String) {
       // Store `value` under a new unforgeable reference.
       let value_ref: URef = storage::new_uref(value);

       // Wrap the unforgeable reference in a value of type `Key`.
       let value_key: Key = value_ref.into();

       // Store this key under the name "special_value" in context-local storage.
       runtime::put_key(KEY, value_key);
   }

   // All session code must have a `call` entrypoint.
   #[no_mangle]
   pub extern "C" fn call() {
       // Get the optional first argument supplied to the argument.
       let value: String = runtime::get_named_arg(ARG_MESSAGE);
       store(value);
   }

Using Error Codes
^^^^^^^^^^^^^^^^^

The Casper VM supports error codes in smart contracts. A contract can stop execution and exit with a given error via the `runtime::revert <https://docs.rs/casper-contract>`_ function:

.. code-block:: rust

   use casperlabs_contract::contract_api::runtime;
   use casperlabs_types::ApiError;

   #[no_mangle]
   pub extern "C" fn call() {
       runtime::revert(ApiError::PermissionDenied)
   }

Casper has `several built-in error variants <https://crates.io/crates/casper-types/latest/casper_types/>`_ , but it's possible to create a custom set of error codes for your smart contract. These can be passed to `runtime::revert <https://docs.rs/casper-contract/latest/casper_contract/contract_api/runtime/fn.revert.html>`_ via  `ApiError::User(<your error code>) <https://docs.rs/casper-types/latest/casper_types/enum.ApiError.html#variant.User>`_.

When a contract exits with an error code, the exit code is visible in the Block Explorer.

Tests
-----

As part of the Casper local environment we provide the in-memory virtual machine you can run your contract against. The testing framework is designed to be used in the following way:


#. Initialize the context.
#. Deploy or call the smart contract.
#. Query the context for changes and assert the result data matches expected values.

TestContext
^^^^^^^^^^^

A  TestContext provides a virtual machine instance. It should be a mutable object as we will change its internal data while making deploys. It's also important to set an initial balance for the account to use for deploys.

.. code-block:: rust

   const MY_ACCOUNT: [u8; 32] = [7u8; 32];

   let mut context = TestContextBuilder::new()
       .with_account(MY_ACCOUNT, U512::from(128_000_000))
       .build();

Account is type of ``[u8; 32]``. Balance is type of ``U512``.

Run Smart Contract
^^^^^^^^^^^^^^^^^^

Before we can deploy the contract to the context, we need to prepare the request. We call the request a session, and each session call should have 4 elements:


* Wasm file path.
* List of arguments.
* Account context of execution.
* List of keys that authorize the call. See: `Permissions model <https://docs.casperlabs.io/en/latest/implementation/accounts.html#permissions-model>`_
.. code-block:: rust

    let VALUE: &str = "hello world";
    let session_code = Code::from("contract.wasm");
    let session_args = runtime_args! {
    "value" => VALUE,
    };
    let session = SessionBuilder::new(session_code, session_args)
    .with_address(MY_ACCOUNT)
    .with_authorization_keys(&[MY_ACCOUNT])
    .build();
    context.run(session);

Executing ``run`` will panic if the code execution fails.

Query and Assert
^^^^^^^^^^^^^^^^

The smart contract we deployed creates a new value ``"hello world"`` under the key ``"special_value"``. Using the ``query`` function it's possible to extract this value from the blockchain.

.. code-block:: rust

   let KEY: &str = "special_value";
   let result_of_query: Result<Value, Error> = context.query(MY_ACCOUNT, &[KEY]);
   let returned_value = result_of_query.expect("should be a value");
   let expected_value = Value::from_t(VALUE.to_string()).expect("should construct Value");
   assert_eq!(expected_value, returned_value);

Note that the ``expected_value`` is a ``String`` type lifted to the ``Value`` type. It was also possible to map ``returned_value`` to the ``String`` type.

Final Test
^^^^^^^^^^

The code below is the simple test generated by `cargo-casper <https://crates.io/crates/cargo-casper>`_ (found in ``tests/src/integration_tests.rs`` of a project created by the tool).

.. code-block:: rust

   #[cfg(test)]
   mod tests {
       use casperlabs_engine_test_support::{Code, Error, SessionBuilder, TestContextBuilder, Value};
       use casperlabs_types::{RuntimeArgs, runtime_args, U512};

       const MY_ACCOUNT: [u8; 32] = [7u8; 32];
       // define KEY constant to match that in the contract
       const KEY: &str = "special_value";
       const VALUE: &str = "hello world";

       #[test]
       fn should_store_hello_world() {
           let mut context = TestContextBuilder::new()
               .with_account(MY_ACCOUNT, U512::from(128_000_000))
               .build();

           // The test framework checks for compiled Wasm files in '<current working dir>/wasm'.  Paths
           // relative to the current working dir (e.g. 'wasm/contract.wasm') can also be used, as can
           // absolute paths.
           let session_code = Code::from("contract.wasm");
           let session_args = runtime_args! {
               "value" => VALUE,
           };
           let session = SessionBuilder::new(session_code, session_args)
               .with_address(MY_ACCOUNT)
               .with_authorization_keys(&[MY_ACCOUNT])
               .build();

           let result_of_query: Result<Value, Error> = context.run(session).query(MY_ACCOUNT, &[KEY]);

           let returned_value = result_of_query.expect("should be a value");

           let expected_value = Value::from_t(VALUE.to_string()).expect("should construct Value");
           assert_eq!(expected_value, returned_value);
       }
   }

   fn main() {
       panic!("Execute \"cargo test\" to test the contract, not \"cargo run\".");
   }

WASM File Size
--------------

We encourage shrinking the WASM file size as much as possible. Smaller deploys cost less and save the network bandwidth. We recommend reading `Shrinking .wasm Code Size <https://rustwasm.github.io/docs/book/reference/code-size.html>`_ chapter of `The Rust Wasm Book <https://rustwasm.github.io/docs/book/>`_.
